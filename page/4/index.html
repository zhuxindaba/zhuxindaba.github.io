<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>zhuxin_blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="zhuxin_blog">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="zhuxin_blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zhuxin_blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="zhuxin_blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  
  <link href="//fonts.googleapis.com/css?family=Inconsolata:400,700|Open+Sans:700,400" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <div id="header-title">
        <h1 id="logo-wrap">
          <a href="/" id="logo">
          
              <span id="subtitle">每天进步一点点</span>
          
          </a>
        </h1>
      </div>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">我的文章</a>
        
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</div>
      <div class="outer">
        <section id="main">
  
    <article id="post-Electron/api_references_synopsis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/Electron/api_references_synopsis/" class="article-date">
  <time datetime="2016-07-06T14:45:21.826Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Electron/">Electron</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/Electron/api_references_synopsis/">API概要</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>如何使用Nodejs和Electron的API</strong></p>
<blockquote>
<p>nodejs所有的内置模块在Electron都是可用的并且第三方模块也支持。<br>Electron也提供了一些额外的内置模块用来开发传统的桌面应用，一些模块只能在主进程中使用，<br>一些只能在渲染进程中使用，也有一些可以同时在主进程和渲染进程中使用。<br>基本规则就是: GUI或者系统底层的模块只能在主进程中使用，要使用这些模块，你应当很熟悉主进<br>程vs渲染进程脚本的概念。<br>主进程中的脚本就像普通的nodejs脚本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const &#123;app, BrowserWindow&#125; = require(&apos;electron&apos;);</span><br><span class="line"></span><br><span class="line">let win = null;</span><br><span class="line"></span><br><span class="line">app.on(&apos;ready&apos;, () =&gt; &#123;</span><br><span class="line">  win = new BrowserWindow(&#123;width: 800, height: 600&#125;);</span><br><span class="line">  win.loadURL(&apos;https://github.com&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>渲染进程和web页面没有什么不同，除了它有使用node模块的能力:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const &#123;app&#125; = require(&apos;electron&apos;).remote;</span><br><span class="line">  console.log(app.getVersion());</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果想运行应用，阅读<code>quik start</code>的<code>run your app</code></p>
</blockquote>
<p><strong>解构赋值</strong></p>
<blockquote>
<p>自0.37起，你可以使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="external">destructuring assignment </a><br>更便捷的使用内置模块.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123;app, BrowserWindow&#125; = require(&apos;electron&apos;);</span><br></pre></td></tr></table></figure></p>
<p>如果你需要Electron全部的模块，你可以引用<code>electron</code>并且使用解构来访问个别的模块:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const electron = require(&apos;electron&apos;);</span><br><span class="line">const &#123;app, BrowserWindow&#125; = electron;</span><br></pre></td></tr></table></figure></p>
<p>这和下面的语法是一样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const electron = require(&apos;electron&apos;);</span><br><span class="line">const app = electron.app;</span><br><span class="line">const BrowserWindow = electron.BrowserWindow;</span><br></pre></td></tr></table></figure></p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/06/Electron/api_references_synopsis/" data-id="ciw22kifk0001noo0vo7il7s0" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-Electron/online_offline_event_detection" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/Electron/online_offline_event_detection/" class="article-date">
  <time datetime="2016-07-06T14:28:51.541Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Electron/">Electron</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/Electron/online_offline_event_detection/">在线离线事件探测</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>使用标准的HTML5API可以在渲染进程中实现在线和离线事件的探测，如下所示</p>
<p><em>main.js</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const electron = require(&apos;electron&apos;);</span><br><span class="line">const app = electron.app;</span><br><span class="line">const BrowserWindow = electron.BrowserWindow;</span><br><span class="line"></span><br><span class="line">let onlineStatusWindow;</span><br><span class="line"></span><br><span class="line">app.on(&apos;ready&apos;, () =&gt; &#123;</span><br><span class="line">  onlineStatusWindow = new BrowserWindow(&#123; width: 0, height: 0, show: false &#125;);</span><br><span class="line">  onlineStatusWindow.loadURL(`file://$&#123;__dirname&#125;/online-status.html`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><em>online-status.html</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const alertOnlineStatus = () =&gt; &#123;</span><br><span class="line">    window.alert(navigator.onLine ? &apos;online&apos; : &apos;offline&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  window.addEventListener(&apos;online&apos;,  alertOnlineStatus);</span><br><span class="line">  window.addEventListener(&apos;offline&apos;,  alertOnlineStatus);</span><br><span class="line"></span><br><span class="line">  alertOnlineStatus();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>主进程是没有<code>navigator</code>这个对象的，所以不能直接的探测这些事件，使用Electron的进程间通信<br>的工具，这些事件将会被传递到主进程，并且根据需要去处理，下面的就是个例子:</p>
<p><em>main.js</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const electron = require(&apos;electron&apos;);</span><br><span class="line">const app = electron.app;</span><br><span class="line">const ipcMain = electron.ipcMain;</span><br><span class="line">const BrowserWindow = electron.BrowserWindow;</span><br><span class="line"></span><br><span class="line">let onlineStatusWindow;</span><br><span class="line"></span><br><span class="line">app.on(&apos;ready&apos;, () =&gt; &#123;</span><br><span class="line">  onlineStatusWindow = new BrowserWindow(&#123; width: 0, height: 0, show: false &#125;);</span><br><span class="line">  onlineStatusWindow.loadURL(`file://$&#123;__dirname&#125;/online-status.html`);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ipcMain.on(&apos;online-status-changed&apos;, (event, status) =&gt; &#123;</span><br><span class="line">  console.log(status);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><em>online-status.html</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const &#123;ipcRenderer&#125; = require(&apos;electron&apos;);</span><br><span class="line">  const updateOnlineStatus = () =&gt; &#123;</span><br><span class="line">    ipcRenderer.send(&apos;online-status-changed&apos;, navigator.onLine ? &apos;online&apos; : &apos;offline&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  window.addEventListener(&apos;online&apos;,  updateOnlineStatus);</span><br><span class="line">  window.addEventListener(&apos;offline&apos;,  updateOnlineStatus);</span><br><span class="line"></span><br><span class="line">  updateOnlineStatus();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/06/Electron/online_offline_event_detection/" data-id="ciw22kifv0003noo0brdo44ta" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-Webpack/long_term_caching" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/05/Webpack/long_term_caching/" class="article-date">
  <time datetime="2016-07-05T14:59:23.538Z" itemprop="datePublished">2016-07-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Webpack/">Webpack</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/05/Webpack/long_term_caching/">长期缓存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>为了有效的缓存文件，URL需要有一个hash或版本号，你可以手动的将输出文件移到一个叫v1.3的文件夹<br>但是这有几个缺点：额外的开发工作并且没有任何改变的文件不能存缓存中获取.<br>Webpack可以在文件名之后添加hash串，加载器（worker-loader, file-loader）输出的文件已经<br>做了这项工作，需要你允许块文件使用它，这里有两个级别</p>
<ul>
<li>计算所有块文件的hash并且添加它</li>
<li>计算每个块文件的hash并且添加它</li>
</ul>
</blockquote>
<p><strong>方式一：对打包文件增加一个hash串</strong></p>
<blockquote>
<p>命令行方式<code>webpack ./entry output.[hash].bundle.js</code>，配置文件方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, &quot;assets&quot;, &quot;[hash]&quot;),</span><br><span class="line">        publicPath: &quot;assets/[hash]/&quot;,</span><br><span class="line">        filename: &quot;output.[hash].bundle.js&quot;,</span><br><span class="line">        chunkFilename: &quot;[id].[hash].bundle.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>方式二：每一个块文件一个hash串</strong><br>可以通过添加[<code>chunkhash</code>]到配置文件的filename属性中<br><code>--output-chunk-file [chunkhash].js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output: &#123; chunkFilename: &quot;[chunkhash].bundle.js&quot; &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：你需要在HTML中引入带有hash串的入口块，你需要从stats中提取出hash串。<br>为了兼容代码热部署，你需要使用方式一，但是不要在<code>publicPath</code>中使用hash串。</p>
</blockquote>
<p><strong>从stats中获取文件名</strong></p>
<blockquote>
<p>你可能需要访问最终的文件以便在HTML中嵌入，这段资料可获得webpack的stats，如果你使用命令<br>行,可通过<code>--with</code>获得json的标准输出。<br>可以在配置文件中添加插件比如<code>assets-webpack-plugin</code>来访问stats对象，这是一个将stats<br>写入文件的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  function() &#123;</span><br><span class="line">    this.plugin(&quot;done&quot;, function(stats) &#123;</span><br><span class="line">      require(&quot;fs&quot;).writeFileSync(</span><br><span class="line">        path.join(__dirname, &quot;..&quot;, &quot;stats.json&quot;),</span><br><span class="line">        JSON.stringify(stats.toJson()));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>stats的JSON格式包含了一个有用的属性<code>assetsByChunkNam</code>,它是一个对象，以块名字为键，对应<br>的文件名为值。<br>注意：如果一个块文件输出了多个资源文件，那么stats是数组，数组的第一个元素是你的<br>javascript资源。</p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/05/Webpack/long_term_caching/" data-id="ciw22kij0000znoo0mco9it5t" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-Electron/desktop_environment_integration" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/05/Electron/desktop_environment_integration/" class="article-date">
  <time datetime="2016-07-05T13:40:08.537Z" itemprop="datePublished">2016-07-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Electron/">Electron</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/05/Electron/desktop_environment_integration/">桌面环境集成</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>对于桌面应用，不同的操作系统在左面环境中提供了不同的特性。比如在windows下应用程序可以将<br>应用程序的图标放在任务栏中的跳转列表上，在Mac上，应用可以将自定义菜单放在dock菜单上。<br>这篇指南将会说明如何利用Electron APIS集成你的应用到桌面环境上。</p>
</blockquote>
<p><strong>Notifications（通知）(Windows, Linux, Mac)</strong></p>
<blockquote>
<p>这三个操作系统都为用户提供了应用发送通知的方法。Electron允许开发者通过<br><a href="https://notifications.spec.whatwg.org/" target="_blank" rel="external">HTML5 Notification API</a>很方便的发送通知.<br>用操作系统原生的通知APIs去显示.<br><strong>注意：</strong>由于这是HTML5的API所以只能在渲染进程中使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let myNotification = new Notification(&apos;Title&apos;, &#123;</span><br><span class="line">  body: &apos;Lorem Ipsum Dolor Sit Amet&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myNotification.onclick = () =&gt; &#123;</span><br><span class="line">  console.log(&apos;Notification clicked&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>尽管代码和用户体验在不同的平台上基本相同，但还是有区别的.</p>
</blockquote>
<p><strong>Windows</strong></p>
<blockquote>
<ul>
<li>在windows10, 通知可以工作。</li>
<li>在windows8.1,8上,需要安装<br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd378459(v=vs.85" target="_blank" rel="external">Application User Model ID</a>.aspx)<br>到开始屏幕上,这不是将你的应用固定到开始屏幕。<br>Windows7及以下，不支持通知，可以通过<br><a href="https://github.com/zhuxindaba/electron/blob/master/docs/api/tray.md#traydisplayballoonoptions-windows" target="_blank" rel="external">Tray API</a><br>发送一个气泡通知。<br>此外，通知的最大长度为250个字符，Windows团队建议通知的长度保持在200个字符。</li>
</ul>
</blockquote>
<p><strong>Linux ToDo</strong></p>
<p><strong>macOS</strong></p>
<blockquote>
<p>通知在macOS上是直接转发的，你应该需要了解<code>Apple&#39;s Human Interface guidelines regarding notifications.</code><br>注意，通知被限制在256bytes，如果超出将会被截断。</p>
</blockquote>
<p><strong>最近文档（Windows和macOS）</strong></p>
<blockquote>
<p>Windows 和 macOS 提供获取最近文档列表的便捷方式，那就是打开跳转列表或者鱼眼菜单。<br>增加一个文件到最近的访问文档，使用<code>app.addRecentDocument</code>API.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.addRecentDocument(&apos;/Users/USERNAME/Desktop/work.type&apos;);</span><br></pre></td></tr></table></figure></p>
<p>使用<code>app.clearRecentDocuments</code>清空最近访问列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.clearRecentDocuments();</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>Windows注意点</strong></p>
<blockquote>
<p>为了可以在windows上使用这个特性，你的应用需要被注册成为一种文件类型的句柄，否则，在你<br>注册之前，文件不会出现在跳转列表,你可以在<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ee872121(v=vs.85" target="_blank" rel="external">ApplicationRegistration</a>.aspx)<br>注册你的应用,并了解相关事宜.</p>
</blockquote>
<p><strong>macOS注意点</strong></p>
<blockquote>
<p>当在最近打开文档中访问该文件时，<code>app</code>模块的’open-file’事件将会被发出。</p>
</blockquote>
<p><strong>自定义菜单(macOS)</strong></p>
<blockquote>
<p>macOS 可以让开发者定制自己的菜单，通常会包含一些常用特性的快捷方式。<br>使用<code>app.dock.setMenu</code>API来设置你自定义的菜单，仅在macOS上可行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const electron = require(&apos;electron&apos;);</span><br><span class="line">const app = electron.app;</span><br><span class="line">const Menu = electron.Menu;</span><br><span class="line"></span><br><span class="line">const dockMenu = Menu.buildFromTemplate([</span><br><span class="line">  &#123; label: &apos;New Window&apos;, click() &#123; console.log(&apos;New Window&apos;); &#125; &#125;,</span><br><span class="line">  &#123; label: &apos;New Window with Settings&apos;, submenu: [</span><br><span class="line">    &#123; label: &apos;Basic&apos; &#125;,</span><br><span class="line">    &#123; label: &apos;Pro&apos;&#125;</span><br><span class="line">  ]&#125;,</span><br><span class="line">  &#123; label: &apos;New Command...&apos;&#125;</span><br><span class="line">]);</span><br><span class="line">app.dock.setMenu(dockMenu);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>用户任务（Windows）</strong></p>
<blockquote>
<p>在 Windows，你可以特别定义跳转列表的 Tasks 目录的行为，引用 MSDN 的文档：<br>Applications define tasks based on both the program’s features and the key things a user is expected to do with them. Tasks should be context-free, in that the application does not need to be running for them to work. They should also be the statistically most common actions that a normal user would perform in an application, such as compose an email message or open the calendar in a mail program, create a new document in a word processor, launch an application in a certain mode, or launch one of its subcommands. An application should not clutter the menu with advanced features that standard users won’t need or one-time actions such as registration. Do not use tasks for promotional items such as upgrades or special offers.<br>It is strongly recommended that the task list be static. It should remain the same regardless of the state or status of the application. While it is possible to vary the list dynamically, you should consider that this could confuse the user who does not expect that portion of the destination list to change.</p>
<p>不同于macOS的菜单，windows上的用户任务的工作方式就像快捷方式一样，当用户点击了一个任务，<br>一个程序将会被传入特定的参数并且运行.<br>在你的应用中使用<code>app.setUserTasks</code>API设置用户任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.setUserTasks([</span><br><span class="line">  &#123;</span><br><span class="line">    program: process.execPath,</span><br><span class="line">    arguments: &apos;--new-window&apos;,</span><br><span class="line">    iconPath: process.execPath,</span><br><span class="line">    iconIndex: 0,</span><br><span class="line">    title: &apos;New Window&apos;,</span><br><span class="line">    description: &apos;Create a new window&apos;</span><br><span class="line">  &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p>
<p>调用<code>app.setUserTasks</code>并传入空数组来清空任务列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.setUserTasks([]);</span><br></pre></td></tr></table></figure></p>
<p>当你的应用关闭时，用户任务会仍然会出现，在你的应用被卸载前，任务指定的图标和程序的路径<br>必须是存在的。</p>
</blockquote>
<p><strong>缩略图工具栏</strong></p>
<blockquote>
<p>在 Windows，你可以在任务栏上添加一个按钮来当作应用的缩略图工具栏。它将提供用户一种用户<br>访问常用窗口的方式，并且不需要恢复或者激活窗口。<br>使用<code>BrowserWindow.setThumbarButtons</code>设置应用程序的缩略工具栏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const &#123;BrowserWindow&#125; = require(&apos;electron&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">let win = new BrowserWindow(&#123;</span><br><span class="line">  width: 800,</span><br><span class="line">  height: 600</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">win.setThumbarButtons([</span><br><span class="line">  &#123;</span><br><span class="line">    tooltip: &apos;button1&apos;,</span><br><span class="line">    icon: path.join(__dirname, &apos;button1.png&apos;),</span><br><span class="line">    click() &#123; console.log(&apos;button1 clicked&apos;); &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    tooltip: &apos;button2&apos;,</span><br><span class="line">    icon: path.join(__dirname, &apos;button2.png&apos;),</span><br><span class="line">    flags: [&apos;enabled&apos;, &apos;dismissonclick&apos;],</span><br><span class="line">    click() &#123; console.log(&apos;button2 clicked.&apos;); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p>
<p>调用<code>BrowserWindow.setThumbarButtons</code>并传入空数组即可清空缩略图工具栏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win.setThumbarButtons([]);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>Unity Launcher Shortcuts (Linux) TODO</strong><br><strong>Progress Bar in Taskbar (Windows, macOS, Unity) TODO</strong></p>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/05/Electron/desktop_environment_integration/" data-id="ciw22kif40000noo03yg3tu8t" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-Webpack/optimization" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/04/Webpack/optimization/" class="article-date">
  <time datetime="2016-07-04T15:17:18.642Z" itemprop="datePublished">2016-07-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Webpack/">Webpack</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/04/Webpack/optimization/">优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>压缩</strong></p>
<blockquote>
<p>通过简单的配置可以让webpack压缩你的javascript代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--optimize-minimize 或new webpack.optimize.UglifyJsPlugin()</span><br></pre></td></tr></table></figure></p>
<p>这是一个简单并有效优化你应用的方式<br>如果你已经知道webpack给每个模块和分块提供了id去标识他们，webpack可以通过一个简单的配置<br>改变id的分配，通过给常用模块最短的id进行优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--optimize-dedupe 或new webpack.optimize.DedupePlugin()</span><br></pre></td></tr></table></figure></p>
<p>入口块有更高的文件大小优先级</p>
</blockquote>
<p><strong>去重</strong></p>
<blockquote>
<p>如果使用一些库时，会发现一些文件是相同的，webpack可以找到这些文件并且去重，这可以阻止<br>在打包文件中包含重复的代码，并且在运行时提供一个复制函数，这不会影响语法问题，可以这样<br>嵌入它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--optimize-dedupe 或 new webpack.optimize.DedupePlugin()</span><br></pre></td></tr></table></figure></p>
<p>这个功能会在入口快之前添加。</p>
</blockquote>
<p><strong>分块</strong></p>
<blockquote>
<p>当在写代码时，可能你已经添加了一下代码分离点来按需加载，在编译之后你可能会发现有太多特别<br>小的分块，Http请求负担加重，幸运的是，你可以后置的去处理这些块文件，可以有两种配置。</p>
<ul>
<li><p>限制块文件的最大个数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--optimize-max-chunks 15或者new webpack.optimize.LimitChunkCountPlugin(&#123;maxChunks: 15&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>限制最小块文件的大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--optimize-min-chunk-size 10000或new webpack.optimize.MinChunkSizePlugin(&#123;minChunkSize: 10000&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>webpack会小心的处理分块合并（优先合并有重复的分块），任何东西都不会合并到入口块中，所以<br>不会影响首页加载时间</p>
</blockquote>
<p><strong>单页面应用</strong></p>
<blockquote>
<p>webpack就是用来处理单页面应用而设计和优化的。<br>你或许已经分离应用到多个分块，根据不同的路由加载不同的块，入口块只包含了路由和一些库，但<br>没有实质内容，这种做法对于应用中的浏览切换时很好的，但是首页加载需要两次请求：一次是路由<br>一次是页面内容。<br>如果你使用了 HTML5 的 history api 来做页面内容和 url 的一一对应，那么服务端就能根据<br>url来知道请求的具体单页应用中的哪一个页面.这样，可以通过服务端直接同时输出请求页面的处理分块，<br>利用浏览器的并行加载来节省网络请求时间.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;entry-chunk.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;3.chunk.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>你可以从stats中提取出分块的名字(<code>stats-webpack-plugin</code>导出构建的stats)</p>
</blockquote>
<p><strong>多页面应用</strong></p>
<blockquote>
<p>当你编译多页面应用时，你想在页面之间共享公共的代码，这对于webpack很简单，只需要使用多个<br>入口点``<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: &quot;./page1&quot;,</span><br><span class="line">        p2: &quot;./page2&quot;,</span><br><span class="line">        p3: &quot;./page3&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;[name].entry.chunk.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这会生成多个入口文件，<code>p1.entry.chunk.js</code>,<code>p2.entry.chunk.js</code>,<code>p3.entry.chunk.js</code>，<br>但是他们可以共享额外的块文件。<br>如果入口块有使用相同的模块，<code>CommonsChunkPlugin</code>可以找出相同的模块然后把他们提取出来<br>放到一个公共分块中,这样，页面中只需要引入两个 script，一个是公共分块另一个则是该页面的入口块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: &quot;./page1&quot;,</span><br><span class="line">        p2: &quot;./page2&quot;,</span><br><span class="line">        p3: &quot;./page3&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;[name].entry.chunk.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new CommonsChunkPlugin(&quot;commons.chunk.js&quot;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样会生成<code>p1.entry.chunk.js</code>、<code>p2.entry.chunk.js</code> 和 <code>p3.entry.chunk.js</code> 以及<br><code>commons.chunk.js</code>。首先加载 commons.chunk.js，然后加载对应的入口块。<br>你可以通过选择入口块生成多个公共块，公共块也可以嵌套使用.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: &quot;./page1&quot;,</span><br><span class="line">        p2: &quot;./page2&quot;,</span><br><span class="line">        p3: &quot;./page3&quot;,</span><br><span class="line">        ap1: &quot;./admin/page1&quot;,</span><br><span class="line">        ap2: &quot;./admin/page2&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;[name].js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new CommonsChunkPlugin(&quot;admin-commons.js&quot;, [&quot;ap1&quot;, &quot;ap2&quot;]),</span><br><span class="line">        new CommonsChunkPlugin(&quot;commons.js&quot;, [&quot;p1&quot;, &quot;p2&quot;, &quot;admin-commons.js&quot;])</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line">// &lt;script&gt;s required:</span><br><span class="line">// page1.html: commons.js, p1.js</span><br><span class="line">// page2.html: commons.js, p2.js</span><br><span class="line">// page3.html: p3.js</span><br><span class="line">// admin-page1.html: commons.js, admin-commons.js, ap1.js</span><br><span class="line">// admin-page2.html: commons.js, admin-commons.js, ap2.js</span><br></pre></td></tr></table></figure></p>
<p>高级用法，公共块的代码也可以直接运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: &quot;./page1&quot;,</span><br><span class="line">        p2: &quot;./page2&quot;,</span><br><span class="line">        commons: &quot;./entry-for-the-commons-chunk&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new CommonsChunkPlugin(&quot;commons&quot;, &quot;commons.js&quot;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>查看<a href="https://github.com/webpack/webpack/tree/master/examples/multiple-entry-points" target="_blank" rel="external"><code>multiple-entry-points example</code></a><br><a href="https://github.com/webpack/webpack/tree/master/examples/multiple-commons-chunks" target="_blank" rel="external"><code>advanced multiple-commons-chunks example.</code></a></p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/04/Webpack/optimization/" data-id="ciw22kijd0015noo0hzi3whou" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-Electron/quik_start" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/04/Electron/quik_start/" class="article-date">
  <time datetime="2016-07-04T14:11:04.268Z" itemprop="datePublished">2016-07-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Electron/">Electron</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/04/Electron/quik_start/">快速开始</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>快速开始</strong></p>
<blockquote>
<p>Electron可以使用纯粹的javaScript通过调用原生的API创建桌面应用，可以把它当做是nodejs<br>运行时多变多样的专注于桌面应用而不是web服务器。<br>这并不意味着Electron是绑定了GUI库的javaScript，Electron使用Web页面作为它的UI，你可以<br>把它当作是简易版的Chrom浏览器，由javascript控制。</p>
</blockquote>
<p><strong>主线程</strong></p>
<blockquote>
<p>在Electron中，运行<code>package.json</code>中<code>main</code>脚本的进程是主进程，在主进程运行的脚本通过创<br>建Web页面来展示GUI.</p>
</blockquote>
<p><strong>渲染进程</strong></p>
<blockquote>
<p>由于Electron使用Chromium来展示web页面，所以Chromium的多进程架构也被利用上了，每一个<br>在Electron的web页面都运行着自己的进程，这样的进程称之为渲染进程。<br>在一般的浏览器中，web页面通常运行在沙河环境下，这样是不能访问原生资源的，然而，Electron<br>用户，有权利在web页面中调用nodejs API，可以与底层操作系统交互.</p>
</blockquote>
<p><strong>主进程与渲染进程的不同</strong></p>
<blockquote>
<p>主进程通过创建<code>BrowserWindow</code>实例来创建web页面，每个<code>BrowserWindow</code>实例在它自己的渲染<br>进程中运行web页面，当一个<code>BrowserWindow</code>实例被销毁后，相应的渲染进程也终止了。<br>主进程管理所有的web页面以及他们相应的渲染进程，每个渲染进程是相互隔离的并且只关心运行在<br>自己上的web页面。<br>在web页面中，调用原生GUI相关的API是不允许的，因为在页面中管理原生的GUI资源是非常危险的<br>并且容易泄露资源，如果你想在web页面中执行GUI的的操作，页面的渲染进程必须与主进程通讯去<br>请求主进程执行这些操作.<br>在Electron中，渲染进程与主进程的通讯有多种方式，比如<code>ipcRender</code>和<code>ipcMain</code>模块去发送<br>消息，并且<code>remote</code>模块用于RPC方式通讯，这是一个常见的问题，<a href="https://github.com/zhuxindaba/electron/blob/master/docs/faq/electron-faq.md#how-to-share-data-between-web-pages" target="_blank" rel="external">如何在web页面中共享数据</a></p>
</blockquote>
<p><strong>完成第一个Electron应用</strong></p>
<blockquote>
<p>通常，一个Electron应用的结构类似下面的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">your-app/</span><br><span class="line">├── package.json</span><br><span class="line">├── main.js</span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure></p>
<p><code>package.json</code>的格式和node的模式是一样的，通过<code>main</code>字段指定的脚本文件就是你的应用<br>程序的启动脚本，它将会运行在主进程中，<code>package.json</code>通常是下面的格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;    : &quot;your-app&quot;,</span><br><span class="line">  &quot;version&quot; : &quot;0.1.0&quot;,</span><br><span class="line">  &quot;main&quot;    : &quot;main.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>如果在<code>package.json</code>中没有声明<code>main</code>字段，Electron会尝试加载<code>index.js</code><br><code>main.js</code>应该用于创建窗口并且处理系统事件，典型的例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">const electron = require(&apos;electron&apos;);</span><br><span class="line">// Module to control application life.</span><br><span class="line">const &#123;app&#125; = electron;</span><br><span class="line">// Module to create native browser window.</span><br><span class="line">const &#123;BrowserWindow&#125; = electron;</span><br><span class="line"></span><br><span class="line">// Keep a global reference of the window object, if you don&apos;t, the window will</span><br><span class="line">// be closed automatically when the JavaScript object is garbage collected.</span><br><span class="line">let win;</span><br><span class="line"></span><br><span class="line">function createWindow() &#123;</span><br><span class="line">  // Create the browser window.</span><br><span class="line">  win = new BrowserWindow(&#123;width: 800, height: 600&#125;);</span><br><span class="line"></span><br><span class="line">  // and load the index.html of the app.</span><br><span class="line">  win.loadURL(`file://$&#123;__dirname&#125;/index.html`);</span><br><span class="line"></span><br><span class="line">  // Open the DevTools.</span><br><span class="line">  win.webContents.openDevTools();</span><br><span class="line"></span><br><span class="line">  // Emitted when the window is closed.</span><br><span class="line">  win.on(&apos;closed&apos;, () =&gt; &#123;</span><br><span class="line">    // Dereference the window object, usually you would store windows</span><br><span class="line">    // in an array if your app supports multi windows, this is the time</span><br><span class="line">    // when you should delete the corresponding element.</span><br><span class="line">    win = null;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This method will be called when Electron has finished</span><br><span class="line">// initialization and is ready to create browser windows.</span><br><span class="line">// Some APIs can only be used after this event occurs.</span><br><span class="line">app.on(&apos;ready&apos;, createWindow);</span><br><span class="line"></span><br><span class="line">// Quit when all windows are closed.</span><br><span class="line">app.on(&apos;window-all-closed&apos;, () =&gt; &#123;</span><br><span class="line">  // On macOS it is common for applications and their menu bar</span><br><span class="line">  // to stay active until the user quits explicitly with Cmd + Q</span><br><span class="line">  if (process.platform !== &apos;darwin&apos;) &#123;</span><br><span class="line">    app.quit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(&apos;activate&apos;, () =&gt; &#123;</span><br><span class="line">  // On macOS it&apos;s common to re-create a window in the app when the</span><br><span class="line">  // dock icon is clicked and there are no other windows open.</span><br><span class="line">  if (win === null) &#123;</span><br><span class="line">    createWindow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// In this file you can include the rest of your app&apos;s specific main process</span><br><span class="line">// code. You can also put them in separate files and require them here.</span><br></pre></td></tr></table></figure></p>
<p>最后，你想展示的<code>index.html</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Hello World!&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello World!&lt;/h1&gt;</span><br><span class="line">    We are using node &lt;script&gt;document.write(process.versions.node)&lt;/script&gt;,</span><br><span class="line">    Chrome &lt;script&gt;document.write(process.versions.chrome)&lt;/script&gt;,</span><br><span class="line">    and Electron &lt;script&gt;document.write(process.versions.electron)&lt;/script&gt;.</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>运行你的应用</strong></p>
<blockquote>
<p>一旦你已经创建了最初的<code>main.js</code>，<code>index.html</code>,<code>package.json</code>，你可能会想尝试在本地<br>运行并测试，看看是不是和期望的那样正常运行。<br><strong>electron-prebuilt</strong><br><code>electron-prebuilt</code>是一个<code>npm</code>模块它包含了所使用的Electron预编译版本，如果你已经全局<br>安装了它，你只需要在你的应用程序目录下执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">electron .</span><br></pre></td></tr></table></figure></p>
<p>如果你是局部安装的，运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/electron .</span><br></pre></td></tr></table></figure></p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/04/Electron/quik_start/" data-id="ciw22kige0007noo0021ac1s8" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-Webpack/style_sheets" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/03/Webpack/style_sheets/" class="article-date">
  <time datetime="2016-07-03T14:54:44.422Z" itemprop="datePublished">2016-07-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Webpack/">Webpack</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/03/Webpack/style_sheets/">样式脚本</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>嵌入的样式脚本</strong></p>
<blockquote>
<p>通过使用<code>style-loader</code>和<code>css-loader</code>，可以webpack打包的javascript文件中嵌入样式脚本.<br>通过这种方式可以是css模块化，这种方式使用很简单<code>require(&quot;./stylesheet.css&quot;)</code>。</p>
</blockquote>
<p><strong>通过npm安装</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install style-loader css-loader --save-dev</span><br></pre></td></tr></table></figure></p>
<p><strong>配置</strong></p>
<blockquote>
<p>通过一下的方式支持<code>require(xxx.css)</code>这种方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    module: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            &#123; test: /\.css$/, loader: &quot;style-loader!css-loader&quot; &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于css预处理语言，可以参照加载器的配置示例，你可以链式的使用它。<br>记住，掌握加载器的执行顺序很难，所以设计好样式让其与顺序无关（但是css文件内的样式顺序<br>还是得依靠的）。<br><strong>使用css</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// in your modules just require the stylesheet</span><br><span class="line">// This has the side effect that a &lt;style&gt;-tag is added to the DOM.</span><br><span class="line">require(&quot;./stylesheet.css&quot;);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>分离css打包文件</strong></p>
<blockquote>
<p>与<code>extract-text-webpack-plugin</code>结合使用，可以生成一个原生的css文件。<br>使用两种方式实现代码分离</p>
<ul>
<li>每个初始块创建一个css文件，然后在其余块中引入（推荐）</li>
<li>每个初始块创建一个 css 文件，其中同时包含了依赖块中的样式<br>推荐第一种方式是因为可以减少页面初始化时间，在小型多入口项目中第二种方式可以利用缓存来减少<br>http消耗</li>
</ul>
</blockquote>
<p><strong>安装<code>extract-text-webpack-plugin</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install extract-text-webpack-plugin --save</span><br></pre></td></tr></table></figure></p>
<p><strong>通用</strong></p>
<blockquote>
<p>使用这个插件需要标记加载器<br><strong>把css从初始化块中分离到css文件中</strong><br>这个例子适用于多入口以及单页面应用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    // The standard entry point and output config</span><br><span class="line">    entry: &#123;</span><br><span class="line">        posts: &quot;./posts&quot;,</span><br><span class="line">        post: &quot;./post&quot;,</span><br><span class="line">        about: &quot;./about&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;[name].js&quot;,</span><br><span class="line">        chunkFilename: &quot;[id].js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            // Extract css files</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader&quot;)</span><br><span class="line">            &#125;,</span><br><span class="line">            // Optionally extract less files</span><br><span class="line">            // or any other compile-to-css language</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.less$/,</span><br><span class="line">                loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader!less-loader&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            // You could also use other loaders the same way. I. e. the autoprefixer-loader</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    // Use the plugin to specify the resulting filename (and add needed behavior to the compiler)</span><br><span class="line">    plugins: [</span><br><span class="line">        new ExtractTextPlugin(&quot;[name].css&quot;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你将获得以下文件</p>
<ul>
<li>posts.js posts.css</li>
<li>post.js post.css</li>
<li>about.js about.css</li>
</ul>
</blockquote>
<p><strong>把所有的样式分离到css文件中</strong></p>
<blockquote>
<p>使用第二种方式只需要设置<code>allChunks</code>为<code>true</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    // ...</span><br><span class="line">    plugins: [</span><br><span class="line">        new ExtractTextPlugin(&quot;style.css&quot;, &#123;</span><br><span class="line">            allChunks: true</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你将会得到以下输出文件</p>
<ul>
<li>posts.js</li>
<li>post.js</li>
<li>about.js</li>
<li>style.css</li>
</ul>
</blockquote>
<p><strong>公共块的样式</strong></p>
<blockquote>
<p>你可以与<code>CommonsChunkPlugin</code>结合使用分离出一个css文件，在这个示例中公共快也会生成一个<br>css文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    // ...</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.optimize.CommonsChunkPlugin(&quot;commons&quot;, &quot;commons.js&quot;),</span><br><span class="line">        new ExtractTextPlugin(&quot;[name].css&quot;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你会获得以下输出文件</p>
<ul>
<li>commons.js commons.css</li>
<li>posts.js posts.css</li>
<li>post.js post.css</li>
<li>about.js about.css</li>
</ul>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/03/Webpack/style_sheets/" data-id="ciw22kikd001mnoo0okg6c8pt" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-Electron/supported_platfroms" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/03/Electron/supported_platfroms/" class="article-date">
  <time datetime="2016-07-03T14:50:43.334Z" itemprop="datePublished">2016-07-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Electron/">Electron</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/03/Electron/supported_platfroms/">支持的平台</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>支持的平台</strong></p>
<blockquote>
<p>以下的平台是Electron支持的</p>
<ul>
<li><strong>macOS</strong><br>只支持macOS64进制的系统，支持的最低版本是macOS 10.9</li>
</ul>
</blockquote>
<ul>
<li><p><strong>Windows</strong></p>
<blockquote>
<p>支持windows7以后的系统，老系统暂不支持，并且不会运行，32位和64位都支持，<code>ARM</code>版本的windows<br>暂不支持</p>
</blockquote>
</li>
<li><p><strong>Linux</strong></p>
<blockquote>
<p>预编译的<code>Electron</code>的<code>ia32(i686)</code>和<code>x64(amd64)</code>二进制文件都是在<code>Ubuntu12.04</code>上编译的。<br>一下的linux系统证实了可以运行预编译版本的<code>Electron</code></p>
<ul>
<li>Ubuntu 12.04 and later</li>
<li>Fedora 21</li>
<li>Debian 8</li>
</ul>
</blockquote>
</li>
</ul>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/03/Electron/supported_platfroms/" data-id="ciw22kih0000cnoo0aolficj2" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-Electron/what_is_electron" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/03/Electron/what_is_electron/" class="article-date">
  <time datetime="2016-07-03T12:11:01.376Z" itemprop="datePublished">2016-07-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Electron/">Electron</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/03/Electron/what_is_electron/">Electron-常见问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Electron框架让你通过CSS、JS、HTML写跨平台的桌面应用，它基于Node.js以及Chrom内核，Atom<br>编辑器就是通过它完成的。</p>
</blockquote>
<p><strong>FAQ(Frequently Asked Questions)常见问题</strong></p>
<blockquote>
<p><strong>什么时候=会升级到最新版本的Chrome</strong><br>通常会在稳定版本的Chrom发布1-2周内，更新Electron内的Chrome版本，Electron只会使用稳定<br>版本的Chrome,但如果在beta或dev有重要的更新的话，会使用补丁的方式应用到现版本的Chrome上<br><strong>什么时候会升级到最新版本的nodejs</strong><br>当一个新版本的nodejs发布之后，通常会在1月之后更新Electron，这样可以避免引入新版本的nodejs<br>所带来的bug，这太常见了.<br>Nodejs的新特性通常是在V8带来的，由于Electron使用的是Chrome装配的V8,所以Electron内已经<br>有了新版本Nodejs的新特性.<br><strong>如何在不同的页面共享数据</strong><br>在不同的网页之间共享数据最简单的方法就是使用浏览器中以实现的HTML5Api，比较好的方案就是<br><code>Storage API</code>, <code>localStorage</code>, <code>sessionStorage</code>, 还有<code>IndexDB</code>。或者使用Electron的<br>IPC系统，将对象储存在主进程中的一个全局变量中，然后在所有的渲染进程中通过<code>Electron</code>的<br><code>remote</code>属性访问它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// In the main process.</span><br><span class="line">global.sharedObject = &#123;</span><br><span class="line">  someProperty: &apos;default value&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// In page 1.</span><br><span class="line">require(&apos;electron&apos;).remote.getGlobal(&apos;sharedObject&apos;).someProperty = &apos;new value&apos;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// In page 2.</span><br><span class="line">console.log(require(&apos;electron&apos;).remote.getGlobal(&apos;sharedObject&apos;).someProperty);</span><br></pre></td></tr></table></figure>
<p><strong>应用的窗口/托盘在一段时间之后不见了</strong><br>这通常是因为储存窗口/托盘的变量被垃圾收集器收集了。<br>如果遇到这个问题，下面的文章会有所帮助</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" target="_blank" rel="external">Memory Management(内存管理)</a></li>
<li><a href="https://msdn.microsoft.com/library/bzt2dkta" target="_blank" rel="external">Variable Scope(变量作用域)</a><br>如果想要一个快速的解决方案，让这些变量变成全局的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.on(&apos;ready&apos;, () =&gt; &#123;</span><br><span class="line">  const tray = new Tray(&apos;/path/to/icon.png&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>改变为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let tray = null;</span><br><span class="line">app.on(&apos;ready&apos;, () =&gt; &#123;</span><br><span class="line">  tray = new Tray(&apos;/path/to/icon.png&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>为什么不能在Electron中使用jQuery、RequireJs、Meteor、AngularJs</strong><br>由于nodejs集成了Electron，一些特殊的符号（标识）比如<code>require</code>,<code>exports</code>,’module’会被<br>插入到DOM中，这会导致一些类库插入相同命名的标识失败。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// In the main process.</span><br><span class="line">let win = new BrowserWindow(&#123;</span><br><span class="line">  webPreferences: &#123;</span><br><span class="line">    nodeIntegration: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果想继续使用Nodejs和Electron提供的API，你需要在页面中重命名这些符号（标识）在引入其<br>它类库时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">window.nodeRequire = require;</span><br><span class="line">delete window.require;</span><br><span class="line">delete window.exports;</span><br><span class="line">delete window.module;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>require(<code>electron</code>).xxx未定义</strong><br>在使用electron的内置模块时，可能会遇到这样的问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;electron&apos;).webFrame.setZoomFactor(1.0);</span><br><span class="line">Uncaught TypeError: Cannot read property &apos;setZoomLevel&apos; of undefined</span><br></pre></td></tr></table></figure></p>
<p>这是因为你通过<code>npm</code>安装了全局的或本地的<code>electron</code>模块,它覆写了<code>Electron</code>的内置模块<br>你可以打印出<code>electron</code>的路径来核实你是否使用了正确的内置模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(require.resolve(&apos;electron&apos;));</span><br></pre></td></tr></table></figure></p>
<p>检查一下是否符合下面的形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;/path/to/Electron.app/Contents/Resources/atom.asar/renderer/api/lib/exports/electron.js&quot;</span><br></pre></td></tr></table></figure></p>
<p>如果是<code>node_modules/electron/index.js</code>这种格式的话，你需要删除或者重命名npm安装的electron模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall electron</span><br><span class="line">npm uninstall -g electron</span><br></pre></td></tr></table></figure></p>
<p>如果依然遇到同样的问题，很可能是因为你在错误的进程中使用了此模块，比如<code>electron.app</code>只能<br>在主进程中使用，而<code>electron.webFrame</code>只能在渲染进程中使用.</p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/03/Electron/what_is_electron/" data-id="ciw22kih4000enoo08bi8ujcd" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-Webpack/codesplitting" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/01/Webpack/codesplitting/" class="article-date">
  <time datetime="2016-07-01T14:07:09.821Z" itemprop="datePublished">2016-07-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Webpack/">Webpack</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/01/Webpack/codesplitting/">代码拆分</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>对于大型项目，将所有的代码放在一个文件中不是很好，特别是一些代码只会在响应的情况下才会<br>用到,webpack的其中一个特性就是将你的原代码拆分成块按需加载，一些其余的打包工具将它称之<br>为”层”,”片段”,webpack将其称为”代码拆分”.<br>这是一个可被选择的特性，你可以在你的原代码中定义拆分点，webpack会维持好依赖性，输出文件<br>以及运行时文件。<br>为了澄清一个常见的误解，代码拆分并不仅仅是将公共代码提取出来到一个公共的模块，更重要的特性<br>是可以将拆出来的代码块按需加载，这可以保证首次加载的代码更少，请求会按需加载所需要的代码。</p>
</blockquote>
<p><strong>定义分离点</strong></p>
<blockquote>
<p>AMD和CommonJs指定不同的方法实现按需加载，webpack都支持并且并且都是定义为分离点的形式。<br><strong>CommonJs: require.ensure</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require.ensure(dependencies, callback)</span><br></pre></td></tr></table></figure></p>
<p><code>require.ensure</code>方法保证 每个依赖都会在回调函数被同步的请求进来，回调函数被执行时，<br><code>require</code>是回调函数的参数.例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require.ensure([&quot;module-a&quot;, &quot;module-b&quot;], function(require) &#123;</span><br><span class="line">    var a = require(&quot;module-a&quot;);</span><br><span class="line">    // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>注意：<code>require.ensure</code>仅仅是加载模块，但是并不会去执行他们</p>
</blockquote>
<p><strong>AMD:<code>require</code></strong></p>
<blockquote>
<p>AMD规范以下面的方式定义了一个异步的<code>require</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(dependencies, callback)</span><br></pre></td></tr></table></figure></p>
<p>当调用时，所有的依赖都会被加载，并且将他们作为参数给回调函数,例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&quot;module-a&quot;, &quot;module-b&quot;], function(a, b) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>注意：AMD<code>require</code>加载并执行响应的模块，在webpack中模块是从左向右执行的，并且可以省略<br>回调函数。</p>
</blockquote>
<p><strong>ES6模块</strong></p>
<blockquote>
<p>Webpack不支持ES6模块，直接使用<code>require.ensure</code>或者<code>require</code>取决于设计哪个模块组成你的<br>编译.<br>Webpack1.x.x(2.0即将来临)原生的不支持ES6模块，但是你可以通过转换器解决他，比如使用Babel<br>转换ES6的<code>import</code>语法为CommonJs或者AMD模块，这种途径是有效的，但是当动态加载时会有警告。<br>这种模块添加方式<code>import x from &#39;foo&#39;</code>是故意设计为静态分析的，意味着你不能用于动态导入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// INVALID!!!!!!!!!</span><br><span class="line">[&apos;lodash&apos;, &apos;backbone&apos;].forEach(name =&gt; import name )</span><br></pre></td></tr></table></figure></p>
<p>幸运的是，JavaScript有<code>loader</code>规范去处理动态导入:<code>System.load</code>或者<code>System.import</code>)<br>原生的API和<code>require</code>的定义是等价的，但是大多数编译器不支持转化<code>System.load</code>为’require.ensure’<br>所以如果想使用动态代码拆分的话直接使用<code>require.ensure</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//static imports</span><br><span class="line">import _ from &apos;lodash&apos;</span><br><span class="line"></span><br><span class="line">// dynamic imports</span><br><span class="line">require.ensure([], function(require) &#123;</span><br><span class="line">  let contacts = require(&apos;./contacts&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>分块内容</strong></p>
<blockquote>
<p>分离点处的所有依赖都会被独立成一个块，依赖会递归的被添加。<br>如果在分离点处的回调函数是一个函数，webpack 会把该函数里的依赖都提取到按需加载的代码块中。</p>
</blockquote>
<p><strong>分块优化</strong></p>
<blockquote>
<p>如果两个分块包含相同的模块，它们会被合并成一个，这会造成分块有多个父模块，如果一个模块<br>在一个分块中的所有父模块都可用,那么它将会从该分块中移除。<br>如果一个分块包含了另一个分块中的所有模块，它会被储存起来，满足多个分块.</p>
</blockquote>
<p><strong>分块加载</strong></p>
<blockquote>
<p>根据配置文件的<code>target</code>选项的值，打包时执行不同的逻辑去加载分块，比如<code>web</code>target,分块通<br>过jsonp被加载，一个分块只会被加载一次，并发的请求将会被合并成一个，运行时检查加载的分块是<br>否满足多个分块</p>
</blockquote>
<p><strong>分块类型</strong></p>
<blockquote>
<p><strong>入口块</strong></p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/01/Webpack/codesplitting/" data-id="ciw22kihd000inoo09o30hhuc" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  
</section>
        
          
            <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Canvas/">Canvas</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Electron/">Electron</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Http/">Http</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Redux/">React Redux</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Webpack/">Webpack</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/development-tools/">development tools</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget recents">
      <ul>
        
          <li>
            <a href="/2016/11/28/vue/get_started/">Vue纵览</a>
          </li>
        
          <li>
            <a href="/2016/11/24/phabricator/what_is_docker/">docker</a>
          </li>
        
          <li>
            <a href="/2016/11/21/phabricator/eslint/">eslint</a>
          </li>
        
          <li>
            <a href="/2016/11/17/vue/movitation_design/">了解Vue</a>
          </li>
        
          <li>
            <a href="/2016/11/16/phabricator/install_phabricator/">phbricator的安装</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">我的文章</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
</aside>
          
        
      </div>
      <!--<div id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a></br>
      &copy; 2016 zhuxin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</div>-->
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">我的文章</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>