<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>zhuxin_blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="zhuxin_blog">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="zhuxin_blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zhuxin_blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="zhuxin_blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  
  <link href="//fonts.googleapis.com/css?family=Inconsolata:400,700|Open+Sans:700,400" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <div id="header-title">
        <h1 id="logo-wrap">
          <a href="/" id="logo">
          
              <span id="subtitle">每天进步一点点</span>
          
          </a>
        </h1>
      </div>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">我的文章</a>
        
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</div>
      <div class="outer">
        <section id="main">
  
    <article id="post-Webpack/how-to-write-plugin" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/10/Webpack/how-to-write-plugin/" class="article-date">
  <time datetime="2016-07-10T12:08:41.801Z" itemprop="datePublished">2016-07-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Webpack/">Webpack</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/10/Webpack/how-to-write-plugin/">如何写插件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>TODO</strong></p>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/10/Webpack/how-to-write-plugin/" data-id="ciw3cie06000uqso0ygzwsu9q" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-Webpack/how_to_write_loader" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/07/Webpack/how_to_write_loader/" class="article-date">
  <time datetime="2016-07-07T14:36:40.166Z" itemprop="datePublished">2016-07-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Webpack/">Webpack</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/07/Webpack/how_to_write_loader/">如何写加载器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>加载器是一个返回函数的node模块。<br>当加载器转换资源时，这个函数将被调用。<br>一个很简单的实例是，当只有一个加载器应用于原资源文件时，传递一个参数调用加载器:资源文件<br>内容是字符串.<br>加载器通过这个函数的<code>this</code>上下文访问<a href="http://webpack.github.io/docs/loaders.html" target="_blank" rel="external">loader API</a><br>同步加载器可以通过<code>return</code>仅返回一个值，在其他情况下，可以通过<code>this.callback(err, values...)</code><br>返回任意数量的值,错误将传给回调函数，或者抛给一个同步加载器。<br>加载器被期望返回两个值，第一个值是返回JavaScript的字符串代码，第二个值是返回一个资源图的<br>JavaScript对象。<br>在复杂的情况下，当有多个加载器链式调用，只有最后一个加载器获得资源文件，仅第一个加载器会<br>输出两个值(JavaScript和SourceMap)，其余的加载器传递值给前一个加载器。</p>
</blockquote>
<p><strong>Examples</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Identity loader</span><br><span class="line">module.exports = function(source) &#123;</span><br><span class="line">  return source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Identity loader with SourceMap support</span><br><span class="line">module.exports = function(source, map) &#123;</span><br><span class="line">  this.callback(null, source, map);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>指导方针（参考）</strong></p>
<blockquote>
<p>优先级顺序，第一个应该给最高的优先级，加载器应该：<br><strong>只做一个简单的任务</strong><br>加载器可以链式化，为每一步创建加载器，替代一个加载器立刻做任何事。同样的意思就是，如果<br>没有必要的话不必转换为JavaScript.<br>例如：通过应用查询参数从模板文件渲染HTML。<br>写一个加载器从源文件里编译模板，执行然后返回一个组件，它是一个返回了包含HTML代码的字符串<br>这太糟糕了。<br>替代方案是，为每一个任务写一个加载器然后全部调用（管道的形式）。</p>
<ul>
<li>jade-loader: 转换模板为一个模块输出一个函数</li>
<li>apply-loader: 拿到输出函数并且返回通过应用查询参数返回行结果</li>
<li>html-loader: 拿到HTML并输出一个字符串形式的模块<br><strong>生产标准的模块</strong><br>加载器生成的模块需要像标准的模块遵守同样的管道设计方式。<br>例如：这是一个糟糕的设计方式（非标准，通用场景）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require(&quot;any-template-language-loader!./xyz.atl&quot;);</span><br><span class="line"></span><br><span class="line">var html = anyTemplateLanguage.render(&quot;xyz&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p><strong>尽可能的标记自己为可缓存</strong></p>
<blockquote>
<p>大多数加载器可缓存，所以他们得标记自己为可缓存。<br>只需在加载器中调用<code>cacheable</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Cacheable identity loader</span><br><span class="line">module.exports = function(source) &#123;</span><br><span class="line">    this.cacheable();</span><br><span class="line">    return source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>不要在模块和流之间保持状态</strong><br>一个加载器需要在其它加载器编译时保持独立。<br>一个模块先前的编译结果，和当前加载器应该保持独立.<br><strong>标记依赖</strong><br>如果一个加载器使用了外部资源（从文件系统读），他们<strong>必须</strong>被告知，被用来使缓存加载器无效<br>并且在监听方法中重新编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Loader adding a header</span><br><span class="line">var path = require(&quot;path&quot;);</span><br><span class="line">module.exports = function(source) &#123;</span><br><span class="line">    this.cacheable();</span><br><span class="line">    var callback = this.async();</span><br><span class="line">    var headerPath = path.resolve(&quot;header.js&quot;);</span><br><span class="line">    this.addDependency(headerPath);</span><br><span class="line">    fs.readFile(headerPath, &quot;utf-8&quot;, function(err, header) &#123;</span><br><span class="line">        if(err) return callback(err);</span><br><span class="line">        callback(null, header + &quot;\n&quot; + source);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>解析依赖</strong><br>在很多种语言中，有多重模式去指定依赖，比如在css中的<code>@import</code>和url(…),这些依赖关系需<br>要模块系统去解析。有两种方式去处理:</p>
<ul>
<li>转换他们为<code>require</code>s</li>
<li>使用<code>this.resolve</code>函数去解析路径<br>实例一 css-loader: css-loader在样式表中替换<code>@import</code>、<code>url(...)</code>为require的方式去编译<br>依赖关系。<br>实例二 less-loader: less-loader不能将<code>@import</code>转换为<code>require</code>因为所有的less文件都会<br>被编译到一个临时变量中，因此，less-loader继承了less编译器的通过定义路径解析的逻辑，这个<br>定义逻辑使用<code>this.resolve</code>通过模块系统的配置去解析文件（或者定义的模块目录等等）<br>如果语言之允许相对路径（比如css中:<code>url(file)</code>意思就是<code>./file</code>）,这儿用<code>~</code>的惯例去引用模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url(file) -&gt; require(&quot;./file&quot;)</span><br><span class="line">url(~module) -&gt; require(&quot;module&quot;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>提取公共代码</strong><br>不要在加载器中去处理每个模块中相同的代码，不要生成这些公共代码，在加载器中创建一个运行时<br>文件,通过<code>require</code>来使用这些公共代码<br><strong>不要嵌入绝对路劲</strong><br>不要在模块代码中使用绝对路径，当项目被移动时会破坏hash,在<code>loader-utils</code>中有一个<br><code>stringifyRequest</code>的方法将绝对路径转换为相对路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var loaderUtils = require(&quot;loader-utils&quot;);</span><br><span class="line">return &quot;var runtime = require(&quot; +</span><br><span class="line">  loaderUtils.stringifyRequest(this, &quot;!&quot; + require.resolve(&quot;module/runtime&quot;)) +</span><br><span class="line">  &quot;);&quot;;</span><br></pre></td></tr></table></figure></p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/07/Webpack/how_to_write_loader/" data-id="ciw3cie0l000wqso0v78gcddw" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-Electron/progress_object" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/Electron/progress_object/" class="article-date">
  <time datetime="2016-07-06T15:12:15.481Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Electron/">Electron</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/Electron/progress_object/">进程对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>progress(进程)</strong></p>
<blockquote>
<p>进程对象的扩展<br><code>progress</code>对象扩展了以下的API</p>
</blockquote>
<p><strong>事件</strong></p>
<blockquote>
<p><strong>‘loaded’事件</strong><br>当Electron已经加载完它内部的初始化脚本并准备加载web页面或者main脚本时触发.<br>当node集成被关闭时，它可以用来预加载移除的node全局变量给全局作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// preload.js</span><br><span class="line">const _setImmediate = setImmediate;</span><br><span class="line">const _clearImmediate = clearImmediate;</span><br><span class="line">process.once(&apos;loaded&apos;, () =&gt; &#123;</span><br><span class="line">  global.setImmediate = _setImmediate;</span><br><span class="line">  global.clearImmediate = _clearImmediate;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>属性</strong></p>
<blockquote>
<p><strong><code>process.noAsar</code></strong><br>设置为<code>true</code>可以使nodejs的<code>asar</code>内置文件无效。<br><strong><code>process.type</code></strong><br>当前的进程类型，可以是<code>&quot;browser&quot;</code>(主进程)或者<code>&quot;render&quot;</code><br><strong><code>process.versions.electron</code></strong><br>Electron的字符串版本号<br><strong><code>process.versions.chrome</code></strong><br>Chrome的字符串版本号<br><strong><code>process.resourcesPath</code></strong><br>资源目录的路劲<br><strong><code>process.mas</code></strong><br>对于Mac App Store，这个属性是<code>true</code>,其余的构建是<code>undefined</code><br><strong><code>process.windowsStore</code></strong><br>对于Windows的app这个属性是<code>true</code>,其他的则是<code>undefined</code><br><strong><code>process.defaultApp</code></strong><br>应用启动时，这个值作为参数默认传入，在主进程中这个属性是<code>true</code>，其他方面是<code>undefined</code></p>
</blockquote>
<p><strong>方法</strong></p>
<blockquote>
<p>进程有以下的方法:<br><strong><code>process.crash()</code></strong><br>销毁当前进程的主线程<br><strong><code>process.hang()</code></strong><br>挂起当前进程的主线程<br><strong><code>process.setFdLimit(maxDescriptors) macOS Linux</code></strong></p>
<ul>
<li><code>maxDescriptors</code> 整数<br>设置文件描述符软限制于 maxDescriptors 或硬限制与os, 无论它是否低于当前进程.<br><strong><code>process.getProcessMemoryInfo()</code></strong><br>返回当前进程的内存使用总计计的一个对象，注意所有的统计以千字节报告:</li>
<li><code>workingSetSize</code>- 被压入到真实RAM物理机的内存总计</li>
<li><code>peakWorkingSetSize</code>- 被压入到真实RAM物理机的的最大内存</li>
<li><code>privateBytes</code>- 不被其他进程共享的内存总计，比如JS堆，HTML内容</li>
<li><code>sharedBytes</code>- 进程间共享的内存总计，通常情况下是Electron自己的代码消耗的内存</li>
</ul>
<p><strong><code>process.getSystemMemoryInfo()</code></strong><br>返回系统内存使用总计的对象，注意所有的统计以千字节报告:</p>
<ul>
<li><code>total</code>- 系统可用物理内存的总计</li>
<li><code>free</code>- 还有多少空闲内存可用</li>
</ul>
<p>在Windows或Linux</p>
<ul>
<li>swapTotal</li>
<li>swapFree</li>
</ul>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/06/Electron/progress_object/" data-id="ciw3cidy10005qso0ywrr7x65" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-Electron/api_references_synopsis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/Electron/api_references_synopsis/" class="article-date">
  <time datetime="2016-07-06T14:45:21.826Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Electron/">Electron</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/Electron/api_references_synopsis/">API概要</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>如何使用Nodejs和Electron的API</strong></p>
<blockquote>
<p>nodejs所有的内置模块在Electron都是可用的并且第三方模块也支持。<br>Electron也提供了一些额外的内置模块用来开发传统的桌面应用，一些模块只能在主进程中使用，<br>一些只能在渲染进程中使用，也有一些可以同时在主进程和渲染进程中使用。<br>基本规则就是: GUI或者系统底层的模块只能在主进程中使用，要使用这些模块，你应当很熟悉主进<br>程vs渲染进程脚本的概念。<br>主进程中的脚本就像普通的nodejs脚本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const &#123;app, BrowserWindow&#125; = require(&apos;electron&apos;);</span><br><span class="line"></span><br><span class="line">let win = null;</span><br><span class="line"></span><br><span class="line">app.on(&apos;ready&apos;, () =&gt; &#123;</span><br><span class="line">  win = new BrowserWindow(&#123;width: 800, height: 600&#125;);</span><br><span class="line">  win.loadURL(&apos;https://github.com&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>渲染进程和web页面没有什么不同，除了它有使用node模块的能力:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const &#123;app&#125; = require(&apos;electron&apos;).remote;</span><br><span class="line">  console.log(app.getVersion());</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果想运行应用，阅读<code>quik start</code>的<code>run your app</code></p>
</blockquote>
<p><strong>解构赋值</strong></p>
<blockquote>
<p>自0.37起，你可以使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="external">destructuring assignment </a><br>更便捷的使用内置模块.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123;app, BrowserWindow&#125; = require(&apos;electron&apos;);</span><br></pre></td></tr></table></figure></p>
<p>如果你需要Electron全部的模块，你可以引用<code>electron</code>并且使用解构来访问个别的模块:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const electron = require(&apos;electron&apos;);</span><br><span class="line">const &#123;app, BrowserWindow&#125; = electron;</span><br></pre></td></tr></table></figure></p>
<p>这和下面的语法是一样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const electron = require(&apos;electron&apos;);</span><br><span class="line">const app = electron.app;</span><br><span class="line">const BrowserWindow = electron.BrowserWindow;</span><br></pre></td></tr></table></figure></p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/06/Electron/api_references_synopsis/" data-id="ciw3cidxb0001qso0y7ys24fy" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-Electron/online_offline_event_detection" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/Electron/online_offline_event_detection/" class="article-date">
  <time datetime="2016-07-06T14:28:51.541Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Electron/">Electron</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/Electron/online_offline_event_detection/">在线离线事件探测</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>使用标准的HTML5API可以在渲染进程中实现在线和离线事件的探测，如下所示</p>
<p><em>main.js</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const electron = require(&apos;electron&apos;);</span><br><span class="line">const app = electron.app;</span><br><span class="line">const BrowserWindow = electron.BrowserWindow;</span><br><span class="line"></span><br><span class="line">let onlineStatusWindow;</span><br><span class="line"></span><br><span class="line">app.on(&apos;ready&apos;, () =&gt; &#123;</span><br><span class="line">  onlineStatusWindow = new BrowserWindow(&#123; width: 0, height: 0, show: false &#125;);</span><br><span class="line">  onlineStatusWindow.loadURL(`file://$&#123;__dirname&#125;/online-status.html`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><em>online-status.html</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const alertOnlineStatus = () =&gt; &#123;</span><br><span class="line">    window.alert(navigator.onLine ? &apos;online&apos; : &apos;offline&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  window.addEventListener(&apos;online&apos;,  alertOnlineStatus);</span><br><span class="line">  window.addEventListener(&apos;offline&apos;,  alertOnlineStatus);</span><br><span class="line"></span><br><span class="line">  alertOnlineStatus();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>主进程是没有<code>navigator</code>这个对象的，所以不能直接的探测这些事件，使用Electron的进程间通信<br>的工具，这些事件将会被传递到主进程，并且根据需要去处理，下面的就是个例子:</p>
<p><em>main.js</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const electron = require(&apos;electron&apos;);</span><br><span class="line">const app = electron.app;</span><br><span class="line">const ipcMain = electron.ipcMain;</span><br><span class="line">const BrowserWindow = electron.BrowserWindow;</span><br><span class="line"></span><br><span class="line">let onlineStatusWindow;</span><br><span class="line"></span><br><span class="line">app.on(&apos;ready&apos;, () =&gt; &#123;</span><br><span class="line">  onlineStatusWindow = new BrowserWindow(&#123; width: 0, height: 0, show: false &#125;);</span><br><span class="line">  onlineStatusWindow.loadURL(`file://$&#123;__dirname&#125;/online-status.html`);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ipcMain.on(&apos;online-status-changed&apos;, (event, status) =&gt; &#123;</span><br><span class="line">  console.log(status);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><em>online-status.html</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const &#123;ipcRenderer&#125; = require(&apos;electron&apos;);</span><br><span class="line">  const updateOnlineStatus = () =&gt; &#123;</span><br><span class="line">    ipcRenderer.send(&apos;online-status-changed&apos;, navigator.onLine ? &apos;online&apos; : &apos;offline&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  window.addEventListener(&apos;online&apos;,  updateOnlineStatus);</span><br><span class="line">  window.addEventListener(&apos;offline&apos;,  updateOnlineStatus);</span><br><span class="line"></span><br><span class="line">  updateOnlineStatus();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/06/Electron/online_offline_event_detection/" data-id="ciw3cidxu0004qso0b4tg6k4e" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-Webpack/long_term_caching" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/05/Webpack/long_term_caching/" class="article-date">
  <time datetime="2016-07-05T14:59:23.538Z" itemprop="datePublished">2016-07-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Webpack/">Webpack</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/05/Webpack/long_term_caching/">长期缓存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>为了有效的缓存文件，URL需要有一个hash或版本号，你可以手动的将输出文件移到一个叫v1.3的文件夹<br>但是这有几个缺点：额外的开发工作并且没有任何改变的文件不能存缓存中获取.<br>Webpack可以在文件名之后添加hash串，加载器（worker-loader, file-loader）输出的文件已经<br>做了这项工作，需要你允许块文件使用它，这里有两个级别</p>
<ul>
<li>计算所有块文件的hash并且添加它</li>
<li>计算每个块文件的hash并且添加它</li>
</ul>
</blockquote>
<p><strong>方式一：对打包文件增加一个hash串</strong></p>
<blockquote>
<p>命令行方式<code>webpack ./entry output.[hash].bundle.js</code>，配置文件方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, &quot;assets&quot;, &quot;[hash]&quot;),</span><br><span class="line">        publicPath: &quot;assets/[hash]/&quot;,</span><br><span class="line">        filename: &quot;output.[hash].bundle.js&quot;,</span><br><span class="line">        chunkFilename: &quot;[id].[hash].bundle.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>方式二：每一个块文件一个hash串</strong><br>可以通过添加[<code>chunkhash</code>]到配置文件的filename属性中<br><code>--output-chunk-file [chunkhash].js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output: &#123; chunkFilename: &quot;[chunkhash].bundle.js&quot; &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：你需要在HTML中引入带有hash串的入口块，你需要从stats中提取出hash串。<br>为了兼容代码热部署，你需要使用方式一，但是不要在<code>publicPath</code>中使用hash串。</p>
</blockquote>
<p><strong>从stats中获取文件名</strong></p>
<blockquote>
<p>你可能需要访问最终的文件以便在HTML中嵌入，这段资料可获得webpack的stats，如果你使用命令<br>行,可通过<code>--with</code>获得json的标准输出。<br>可以在配置文件中添加插件比如<code>assets-webpack-plugin</code>来访问stats对象，这是一个将stats<br>写入文件的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  function() &#123;</span><br><span class="line">    this.plugin(&quot;done&quot;, function(stats) &#123;</span><br><span class="line">      require(&quot;fs&quot;).writeFileSync(</span><br><span class="line">        path.join(__dirname, &quot;..&quot;, &quot;stats.json&quot;),</span><br><span class="line">        JSON.stringify(stats.toJson()));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>stats的JSON格式包含了一个有用的属性<code>assetsByChunkNam</code>,它是一个对象，以块名字为键，对应<br>的文件名为值。<br>注意：如果一个块文件输出了多个资源文件，那么stats是数组，数组的第一个元素是你的<br>javascript资源。</p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/05/Webpack/long_term_caching/" data-id="ciw3cie0x0013qso05yokqvyt" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-Electron/desktop_environment_integration" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/05/Electron/desktop_environment_integration/" class="article-date">
  <time datetime="2016-07-05T13:40:08.537Z" itemprop="datePublished">2016-07-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Electron/">Electron</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/05/Electron/desktop_environment_integration/">桌面环境集成</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>对于桌面应用，不同的操作系统在左面环境中提供了不同的特性。比如在windows下应用程序可以将<br>应用程序的图标放在任务栏中的跳转列表上，在Mac上，应用可以将自定义菜单放在dock菜单上。<br>这篇指南将会说明如何利用Electron APIS集成你的应用到桌面环境上。</p>
</blockquote>
<p><strong>Notifications（通知）(Windows, Linux, Mac)</strong></p>
<blockquote>
<p>这三个操作系统都为用户提供了应用发送通知的方法。Electron允许开发者通过<br><a href="https://notifications.spec.whatwg.org/" target="_blank" rel="external">HTML5 Notification API</a>很方便的发送通知.<br>用操作系统原生的通知APIs去显示.<br><strong>注意：</strong>由于这是HTML5的API所以只能在渲染进程中使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let myNotification = new Notification(&apos;Title&apos;, &#123;</span><br><span class="line">  body: &apos;Lorem Ipsum Dolor Sit Amet&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myNotification.onclick = () =&gt; &#123;</span><br><span class="line">  console.log(&apos;Notification clicked&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>尽管代码和用户体验在不同的平台上基本相同，但还是有区别的.</p>
</blockquote>
<p><strong>Windows</strong></p>
<blockquote>
<ul>
<li>在windows10, 通知可以工作。</li>
<li>在windows8.1,8上,需要安装<br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd378459(v=vs.85" target="_blank" rel="external">Application User Model ID</a>.aspx)<br>到开始屏幕上,这不是将你的应用固定到开始屏幕。<br>Windows7及以下，不支持通知，可以通过<br><a href="https://github.com/zhuxindaba/electron/blob/master/docs/api/tray.md#traydisplayballoonoptions-windows" target="_blank" rel="external">Tray API</a><br>发送一个气泡通知。<br>此外，通知的最大长度为250个字符，Windows团队建议通知的长度保持在200个字符。</li>
</ul>
</blockquote>
<p><strong>Linux ToDo</strong></p>
<p><strong>macOS</strong></p>
<blockquote>
<p>通知在macOS上是直接转发的，你应该需要了解<code>Apple&#39;s Human Interface guidelines regarding notifications.</code><br>注意，通知被限制在256bytes，如果超出将会被截断。</p>
</blockquote>
<p><strong>最近文档（Windows和macOS）</strong></p>
<blockquote>
<p>Windows 和 macOS 提供获取最近文档列表的便捷方式，那就是打开跳转列表或者鱼眼菜单。<br>增加一个文件到最近的访问文档，使用<code>app.addRecentDocument</code>API.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.addRecentDocument(&apos;/Users/USERNAME/Desktop/work.type&apos;);</span><br></pre></td></tr></table></figure></p>
<p>使用<code>app.clearRecentDocuments</code>清空最近访问列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.clearRecentDocuments();</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>Windows注意点</strong></p>
<blockquote>
<p>为了可以在windows上使用这个特性，你的应用需要被注册成为一种文件类型的句柄，否则，在你<br>注册之前，文件不会出现在跳转列表,你可以在<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ee872121(v=vs.85" target="_blank" rel="external">ApplicationRegistration</a>.aspx)<br>注册你的应用,并了解相关事宜.</p>
</blockquote>
<p><strong>macOS注意点</strong></p>
<blockquote>
<p>当在最近打开文档中访问该文件时，<code>app</code>模块的’open-file’事件将会被发出。</p>
</blockquote>
<p><strong>自定义菜单(macOS)</strong></p>
<blockquote>
<p>macOS 可以让开发者定制自己的菜单，通常会包含一些常用特性的快捷方式。<br>使用<code>app.dock.setMenu</code>API来设置你自定义的菜单，仅在macOS上可行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const electron = require(&apos;electron&apos;);</span><br><span class="line">const app = electron.app;</span><br><span class="line">const Menu = electron.Menu;</span><br><span class="line"></span><br><span class="line">const dockMenu = Menu.buildFromTemplate([</span><br><span class="line">  &#123; label: &apos;New Window&apos;, click() &#123; console.log(&apos;New Window&apos;); &#125; &#125;,</span><br><span class="line">  &#123; label: &apos;New Window with Settings&apos;, submenu: [</span><br><span class="line">    &#123; label: &apos;Basic&apos; &#125;,</span><br><span class="line">    &#123; label: &apos;Pro&apos;&#125;</span><br><span class="line">  ]&#125;,</span><br><span class="line">  &#123; label: &apos;New Command...&apos;&#125;</span><br><span class="line">]);</span><br><span class="line">app.dock.setMenu(dockMenu);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>用户任务（Windows）</strong></p>
<blockquote>
<p>在 Windows，你可以特别定义跳转列表的 Tasks 目录的行为，引用 MSDN 的文档：<br>Applications define tasks based on both the program’s features and the key things a user is expected to do with them. Tasks should be context-free, in that the application does not need to be running for them to work. They should also be the statistically most common actions that a normal user would perform in an application, such as compose an email message or open the calendar in a mail program, create a new document in a word processor, launch an application in a certain mode, or launch one of its subcommands. An application should not clutter the menu with advanced features that standard users won’t need or one-time actions such as registration. Do not use tasks for promotional items such as upgrades or special offers.<br>It is strongly recommended that the task list be static. It should remain the same regardless of the state or status of the application. While it is possible to vary the list dynamically, you should consider that this could confuse the user who does not expect that portion of the destination list to change.</p>
<p>不同于macOS的菜单，windows上的用户任务的工作方式就像快捷方式一样，当用户点击了一个任务，<br>一个程序将会被传入特定的参数并且运行.<br>在你的应用中使用<code>app.setUserTasks</code>API设置用户任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.setUserTasks([</span><br><span class="line">  &#123;</span><br><span class="line">    program: process.execPath,</span><br><span class="line">    arguments: &apos;--new-window&apos;,</span><br><span class="line">    iconPath: process.execPath,</span><br><span class="line">    iconIndex: 0,</span><br><span class="line">    title: &apos;New Window&apos;,</span><br><span class="line">    description: &apos;Create a new window&apos;</span><br><span class="line">  &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p>
<p>调用<code>app.setUserTasks</code>并传入空数组来清空任务列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.setUserTasks([]);</span><br></pre></td></tr></table></figure></p>
<p>当你的应用关闭时，用户任务会仍然会出现，在你的应用被卸载前，任务指定的图标和程序的路径<br>必须是存在的。</p>
</blockquote>
<p><strong>缩略图工具栏</strong></p>
<blockquote>
<p>在 Windows，你可以在任务栏上添加一个按钮来当作应用的缩略图工具栏。它将提供用户一种用户<br>访问常用窗口的方式，并且不需要恢复或者激活窗口。<br>使用<code>BrowserWindow.setThumbarButtons</code>设置应用程序的缩略工具栏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const &#123;BrowserWindow&#125; = require(&apos;electron&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">let win = new BrowserWindow(&#123;</span><br><span class="line">  width: 800,</span><br><span class="line">  height: 600</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">win.setThumbarButtons([</span><br><span class="line">  &#123;</span><br><span class="line">    tooltip: &apos;button1&apos;,</span><br><span class="line">    icon: path.join(__dirname, &apos;button1.png&apos;),</span><br><span class="line">    click() &#123; console.log(&apos;button1 clicked&apos;); &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    tooltip: &apos;button2&apos;,</span><br><span class="line">    icon: path.join(__dirname, &apos;button2.png&apos;),</span><br><span class="line">    flags: [&apos;enabled&apos;, &apos;dismissonclick&apos;],</span><br><span class="line">    click() &#123; console.log(&apos;button2 clicked.&apos;); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p>
<p>调用<code>BrowserWindow.setThumbarButtons</code>并传入空数组即可清空缩略图工具栏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win.setThumbarButtons([]);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>Unity Launcher Shortcuts (Linux) TODO</strong><br><strong>Progress Bar in Taskbar (Windows, macOS, Unity) TODO</strong></p>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/05/Electron/desktop_environment_integration/" data-id="ciw3cidxr0003qso0iu5lh8s9" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-Webpack/optimization" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/04/Webpack/optimization/" class="article-date">
  <time datetime="2016-07-04T15:17:18.642Z" itemprop="datePublished">2016-07-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Webpack/">Webpack</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/04/Webpack/optimization/">优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>压缩</strong></p>
<blockquote>
<p>通过简单的配置可以让webpack压缩你的javascript代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--optimize-minimize 或new webpack.optimize.UglifyJsPlugin()</span><br></pre></td></tr></table></figure></p>
<p>这是一个简单并有效优化你应用的方式<br>如果你已经知道webpack给每个模块和分块提供了id去标识他们，webpack可以通过一个简单的配置<br>改变id的分配，通过给常用模块最短的id进行优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--optimize-dedupe 或new webpack.optimize.DedupePlugin()</span><br></pre></td></tr></table></figure></p>
<p>入口块有更高的文件大小优先级</p>
</blockquote>
<p><strong>去重</strong></p>
<blockquote>
<p>如果使用一些库时，会发现一些文件是相同的，webpack可以找到这些文件并且去重，这可以阻止<br>在打包文件中包含重复的代码，并且在运行时提供一个复制函数，这不会影响语法问题，可以这样<br>嵌入它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--optimize-dedupe 或 new webpack.optimize.DedupePlugin()</span><br></pre></td></tr></table></figure></p>
<p>这个功能会在入口快之前添加。</p>
</blockquote>
<p><strong>分块</strong></p>
<blockquote>
<p>当在写代码时，可能你已经添加了一下代码分离点来按需加载，在编译之后你可能会发现有太多特别<br>小的分块，Http请求负担加重，幸运的是，你可以后置的去处理这些块文件，可以有两种配置。</p>
<ul>
<li><p>限制块文件的最大个数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--optimize-max-chunks 15或者new webpack.optimize.LimitChunkCountPlugin(&#123;maxChunks: 15&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>限制最小块文件的大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--optimize-min-chunk-size 10000或new webpack.optimize.MinChunkSizePlugin(&#123;minChunkSize: 10000&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>webpack会小心的处理分块合并（优先合并有重复的分块），任何东西都不会合并到入口块中，所以<br>不会影响首页加载时间</p>
</blockquote>
<p><strong>单页面应用</strong></p>
<blockquote>
<p>webpack就是用来处理单页面应用而设计和优化的。<br>你或许已经分离应用到多个分块，根据不同的路由加载不同的块，入口块只包含了路由和一些库，但<br>没有实质内容，这种做法对于应用中的浏览切换时很好的，但是首页加载需要两次请求：一次是路由<br>一次是页面内容。<br>如果你使用了 HTML5 的 history api 来做页面内容和 url 的一一对应，那么服务端就能根据<br>url来知道请求的具体单页应用中的哪一个页面.这样，可以通过服务端直接同时输出请求页面的处理分块，<br>利用浏览器的并行加载来节省网络请求时间.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;entry-chunk.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;3.chunk.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>你可以从stats中提取出分块的名字(<code>stats-webpack-plugin</code>导出构建的stats)</p>
</blockquote>
<p><strong>多页面应用</strong></p>
<blockquote>
<p>当你编译多页面应用时，你想在页面之间共享公共的代码，这对于webpack很简单，只需要使用多个<br>入口点``<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: &quot;./page1&quot;,</span><br><span class="line">        p2: &quot;./page2&quot;,</span><br><span class="line">        p3: &quot;./page3&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;[name].entry.chunk.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这会生成多个入口文件，<code>p1.entry.chunk.js</code>,<code>p2.entry.chunk.js</code>,<code>p3.entry.chunk.js</code>，<br>但是他们可以共享额外的块文件。<br>如果入口块有使用相同的模块，<code>CommonsChunkPlugin</code>可以找出相同的模块然后把他们提取出来<br>放到一个公共分块中,这样，页面中只需要引入两个 script，一个是公共分块另一个则是该页面的入口块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: &quot;./page1&quot;,</span><br><span class="line">        p2: &quot;./page2&quot;,</span><br><span class="line">        p3: &quot;./page3&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;[name].entry.chunk.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new CommonsChunkPlugin(&quot;commons.chunk.js&quot;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样会生成<code>p1.entry.chunk.js</code>、<code>p2.entry.chunk.js</code> 和 <code>p3.entry.chunk.js</code> 以及<br><code>commons.chunk.js</code>。首先加载 commons.chunk.js，然后加载对应的入口块。<br>你可以通过选择入口块生成多个公共块，公共块也可以嵌套使用.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: &quot;./page1&quot;,</span><br><span class="line">        p2: &quot;./page2&quot;,</span><br><span class="line">        p3: &quot;./page3&quot;,</span><br><span class="line">        ap1: &quot;./admin/page1&quot;,</span><br><span class="line">        ap2: &quot;./admin/page2&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;[name].js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new CommonsChunkPlugin(&quot;admin-commons.js&quot;, [&quot;ap1&quot;, &quot;ap2&quot;]),</span><br><span class="line">        new CommonsChunkPlugin(&quot;commons.js&quot;, [&quot;p1&quot;, &quot;p2&quot;, &quot;admin-commons.js&quot;])</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line">// &lt;script&gt;s required:</span><br><span class="line">// page1.html: commons.js, p1.js</span><br><span class="line">// page2.html: commons.js, p2.js</span><br><span class="line">// page3.html: p3.js</span><br><span class="line">// admin-page1.html: commons.js, admin-commons.js, ap1.js</span><br><span class="line">// admin-page2.html: commons.js, admin-commons.js, ap2.js</span><br></pre></td></tr></table></figure></p>
<p>高级用法，公共块的代码也可以直接运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: &quot;./page1&quot;,</span><br><span class="line">        p2: &quot;./page2&quot;,</span><br><span class="line">        commons: &quot;./entry-for-the-commons-chunk&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new CommonsChunkPlugin(&quot;commons&quot;, &quot;commons.js&quot;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>查看<a href="https://github.com/webpack/webpack/tree/master/examples/multiple-entry-points" target="_blank" rel="external"><code>multiple-entry-points example</code></a><br><a href="https://github.com/webpack/webpack/tree/master/examples/multiple-commons-chunks" target="_blank" rel="external"><code>advanced multiple-commons-chunks example.</code></a></p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/04/Webpack/optimization/" data-id="ciw3cie1d0018qso0ep1j51d3" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-Electron/quik_start" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/04/Electron/quik_start/" class="article-date">
  <time datetime="2016-07-04T14:11:04.268Z" itemprop="datePublished">2016-07-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Electron/">Electron</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/04/Electron/quik_start/">快速开始</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>快速开始</strong></p>
<blockquote>
<p>Electron可以使用纯粹的javaScript通过调用原生的API创建桌面应用，可以把它当做是nodejs<br>运行时多变多样的专注于桌面应用而不是web服务器。<br>这并不意味着Electron是绑定了GUI库的javaScript，Electron使用Web页面作为它的UI，你可以<br>把它当作是简易版的Chrom浏览器，由javascript控制。</p>
</blockquote>
<p><strong>主线程</strong></p>
<blockquote>
<p>在Electron中，运行<code>package.json</code>中<code>main</code>脚本的进程是主进程，在主进程运行的脚本通过创<br>建Web页面来展示GUI.</p>
</blockquote>
<p><strong>渲染进程</strong></p>
<blockquote>
<p>由于Electron使用Chromium来展示web页面，所以Chromium的多进程架构也被利用上了，每一个<br>在Electron的web页面都运行着自己的进程，这样的进程称之为渲染进程。<br>在一般的浏览器中，web页面通常运行在沙河环境下，这样是不能访问原生资源的，然而，Electron<br>用户，有权利在web页面中调用nodejs API，可以与底层操作系统交互.</p>
</blockquote>
<p><strong>主进程与渲染进程的不同</strong></p>
<blockquote>
<p>主进程通过创建<code>BrowserWindow</code>实例来创建web页面，每个<code>BrowserWindow</code>实例在它自己的渲染<br>进程中运行web页面，当一个<code>BrowserWindow</code>实例被销毁后，相应的渲染进程也终止了。<br>主进程管理所有的web页面以及他们相应的渲染进程，每个渲染进程是相互隔离的并且只关心运行在<br>自己上的web页面。<br>在web页面中，调用原生GUI相关的API是不允许的，因为在页面中管理原生的GUI资源是非常危险的<br>并且容易泄露资源，如果你想在web页面中执行GUI的的操作，页面的渲染进程必须与主进程通讯去<br>请求主进程执行这些操作.<br>在Electron中，渲染进程与主进程的通讯有多种方式，比如<code>ipcRender</code>和<code>ipcMain</code>模块去发送<br>消息，并且<code>remote</code>模块用于RPC方式通讯，这是一个常见的问题，<a href="https://github.com/zhuxindaba/electron/blob/master/docs/faq/electron-faq.md#how-to-share-data-between-web-pages" target="_blank" rel="external">如何在web页面中共享数据</a></p>
</blockquote>
<p><strong>完成第一个Electron应用</strong></p>
<blockquote>
<p>通常，一个Electron应用的结构类似下面的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">your-app/</span><br><span class="line">├── package.json</span><br><span class="line">├── main.js</span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure></p>
<p><code>package.json</code>的格式和node的模式是一样的，通过<code>main</code>字段指定的脚本文件就是你的应用<br>程序的启动脚本，它将会运行在主进程中，<code>package.json</code>通常是下面的格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;    : &quot;your-app&quot;,</span><br><span class="line">  &quot;version&quot; : &quot;0.1.0&quot;,</span><br><span class="line">  &quot;main&quot;    : &quot;main.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>如果在<code>package.json</code>中没有声明<code>main</code>字段，Electron会尝试加载<code>index.js</code><br><code>main.js</code>应该用于创建窗口并且处理系统事件，典型的例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">const electron = require(&apos;electron&apos;);</span><br><span class="line">// Module to control application life.</span><br><span class="line">const &#123;app&#125; = electron;</span><br><span class="line">// Module to create native browser window.</span><br><span class="line">const &#123;BrowserWindow&#125; = electron;</span><br><span class="line"></span><br><span class="line">// Keep a global reference of the window object, if you don&apos;t, the window will</span><br><span class="line">// be closed automatically when the JavaScript object is garbage collected.</span><br><span class="line">let win;</span><br><span class="line"></span><br><span class="line">function createWindow() &#123;</span><br><span class="line">  // Create the browser window.</span><br><span class="line">  win = new BrowserWindow(&#123;width: 800, height: 600&#125;);</span><br><span class="line"></span><br><span class="line">  // and load the index.html of the app.</span><br><span class="line">  win.loadURL(`file://$&#123;__dirname&#125;/index.html`);</span><br><span class="line"></span><br><span class="line">  // Open the DevTools.</span><br><span class="line">  win.webContents.openDevTools();</span><br><span class="line"></span><br><span class="line">  // Emitted when the window is closed.</span><br><span class="line">  win.on(&apos;closed&apos;, () =&gt; &#123;</span><br><span class="line">    // Dereference the window object, usually you would store windows</span><br><span class="line">    // in an array if your app supports multi windows, this is the time</span><br><span class="line">    // when you should delete the corresponding element.</span><br><span class="line">    win = null;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This method will be called when Electron has finished</span><br><span class="line">// initialization and is ready to create browser windows.</span><br><span class="line">// Some APIs can only be used after this event occurs.</span><br><span class="line">app.on(&apos;ready&apos;, createWindow);</span><br><span class="line"></span><br><span class="line">// Quit when all windows are closed.</span><br><span class="line">app.on(&apos;window-all-closed&apos;, () =&gt; &#123;</span><br><span class="line">  // On macOS it is common for applications and their menu bar</span><br><span class="line">  // to stay active until the user quits explicitly with Cmd + Q</span><br><span class="line">  if (process.platform !== &apos;darwin&apos;) &#123;</span><br><span class="line">    app.quit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(&apos;activate&apos;, () =&gt; &#123;</span><br><span class="line">  // On macOS it&apos;s common to re-create a window in the app when the</span><br><span class="line">  // dock icon is clicked and there are no other windows open.</span><br><span class="line">  if (win === null) &#123;</span><br><span class="line">    createWindow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// In this file you can include the rest of your app&apos;s specific main process</span><br><span class="line">// code. You can also put them in separate files and require them here.</span><br></pre></td></tr></table></figure></p>
<p>最后，你想展示的<code>index.html</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Hello World!&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello World!&lt;/h1&gt;</span><br><span class="line">    We are using node &lt;script&gt;document.write(process.versions.node)&lt;/script&gt;,</span><br><span class="line">    Chrome &lt;script&gt;document.write(process.versions.chrome)&lt;/script&gt;,</span><br><span class="line">    and Electron &lt;script&gt;document.write(process.versions.electron)&lt;/script&gt;.</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>运行你的应用</strong></p>
<blockquote>
<p>一旦你已经创建了最初的<code>main.js</code>，<code>index.html</code>,<code>package.json</code>，你可能会想尝试在本地<br>运行并测试，看看是不是和期望的那样正常运行。<br><strong>electron-prebuilt</strong><br><code>electron-prebuilt</code>是一个<code>npm</code>模块它包含了所使用的Electron预编译版本，如果你已经全局<br>安装了它，你只需要在你的应用程序目录下执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">electron .</span><br></pre></td></tr></table></figure></p>
<p>如果你是局部安装的，运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/electron .</span><br></pre></td></tr></table></figure></p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/04/Electron/quik_start/" data-id="ciw3cidy90009qso00rbuyuyu" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-Webpack/style_sheets" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/03/Webpack/style_sheets/" class="article-date">
  <time datetime="2016-07-03T14:54:44.422Z" itemprop="datePublished">2016-07-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Webpack/">Webpack</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/03/Webpack/style_sheets/">样式脚本</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>嵌入的样式脚本</strong></p>
<blockquote>
<p>通过使用<code>style-loader</code>和<code>css-loader</code>，可以webpack打包的javascript文件中嵌入样式脚本.<br>通过这种方式可以是css模块化，这种方式使用很简单<code>require(&quot;./stylesheet.css&quot;)</code>。</p>
</blockquote>
<p><strong>通过npm安装</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install style-loader css-loader --save-dev</span><br></pre></td></tr></table></figure></p>
<p><strong>配置</strong></p>
<blockquote>
<p>通过一下的方式支持<code>require(xxx.css)</code>这种方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    module: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            &#123; test: /\.css$/, loader: &quot;style-loader!css-loader&quot; &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于css预处理语言，可以参照加载器的配置示例，你可以链式的使用它。<br>记住，掌握加载器的执行顺序很难，所以设计好样式让其与顺序无关（但是css文件内的样式顺序<br>还是得依靠的）。<br><strong>使用css</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// in your modules just require the stylesheet</span><br><span class="line">// This has the side effect that a &lt;style&gt;-tag is added to the DOM.</span><br><span class="line">require(&quot;./stylesheet.css&quot;);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>分离css打包文件</strong></p>
<blockquote>
<p>与<code>extract-text-webpack-plugin</code>结合使用，可以生成一个原生的css文件。<br>使用两种方式实现代码分离</p>
<ul>
<li>每个初始块创建一个css文件，然后在其余块中引入（推荐）</li>
<li>每个初始块创建一个 css 文件，其中同时包含了依赖块中的样式<br>推荐第一种方式是因为可以减少页面初始化时间，在小型多入口项目中第二种方式可以利用缓存来减少<br>http消耗</li>
</ul>
</blockquote>
<p><strong>安装<code>extract-text-webpack-plugin</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install extract-text-webpack-plugin --save</span><br></pre></td></tr></table></figure></p>
<p><strong>通用</strong></p>
<blockquote>
<p>使用这个插件需要标记加载器<br><strong>把css从初始化块中分离到css文件中</strong><br>这个例子适用于多入口以及单页面应用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    // The standard entry point and output config</span><br><span class="line">    entry: &#123;</span><br><span class="line">        posts: &quot;./posts&quot;,</span><br><span class="line">        post: &quot;./post&quot;,</span><br><span class="line">        about: &quot;./about&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;[name].js&quot;,</span><br><span class="line">        chunkFilename: &quot;[id].js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            // Extract css files</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader&quot;)</span><br><span class="line">            &#125;,</span><br><span class="line">            // Optionally extract less files</span><br><span class="line">            // or any other compile-to-css language</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.less$/,</span><br><span class="line">                loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader!less-loader&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            // You could also use other loaders the same way. I. e. the autoprefixer-loader</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    // Use the plugin to specify the resulting filename (and add needed behavior to the compiler)</span><br><span class="line">    plugins: [</span><br><span class="line">        new ExtractTextPlugin(&quot;[name].css&quot;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你将获得以下文件</p>
<ul>
<li>posts.js posts.css</li>
<li>post.js post.css</li>
<li>about.js about.css</li>
</ul>
</blockquote>
<p><strong>把所有的样式分离到css文件中</strong></p>
<blockquote>
<p>使用第二种方式只需要设置<code>allChunks</code>为<code>true</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    // ...</span><br><span class="line">    plugins: [</span><br><span class="line">        new ExtractTextPlugin(&quot;style.css&quot;, &#123;</span><br><span class="line">            allChunks: true</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你将会得到以下输出文件</p>
<ul>
<li>posts.js</li>
<li>post.js</li>
<li>about.js</li>
<li>style.css</li>
</ul>
</blockquote>
<p><strong>公共块的样式</strong></p>
<blockquote>
<p>你可以与<code>CommonsChunkPlugin</code>结合使用分离出一个css文件，在这个示例中公共快也会生成一个<br>css文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    // ...</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.optimize.CommonsChunkPlugin(&quot;commons&quot;, &quot;commons.js&quot;),</span><br><span class="line">        new ExtractTextPlugin(&quot;[name].css&quot;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你会获得以下输出文件</p>
<ul>
<li>commons.js commons.css</li>
<li>posts.js posts.css</li>
<li>post.js post.css</li>
<li>about.js about.css</li>
</ul>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/03/Webpack/style_sheets/" data-id="ciw3cie1h001aqso0upo91gdl" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  
</section>
        
          
            <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Canvas/">Canvas</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Electron/">Electron</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Http/">Http</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Redux/">React Redux</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Webpack/">Webpack</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/development-tools/">development tools</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget recents">
      <ul>
        
          <li>
            <a href="/2016/11/29/vue/style_class_binding/">样式绑定</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/computed_properties/">Vue属性的计算及监听器</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/template_syntax/">Vue模板语法</a>
          </li>
        
          <li>
            <a href="/2016/11/28/vue/get_started/">Vue纵览</a>
          </li>
        
          <li>
            <a href="/2016/11/24/phabricator/what_is_docker/">docker</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">我的文章</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
</aside>
          
        
      </div>
      <!--<div id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a></br>
      &copy; 2016 zhuxin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</div>-->
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">我的文章</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>