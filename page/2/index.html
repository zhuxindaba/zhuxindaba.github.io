<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>zhuxin_blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="zhuxin_blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="zhuxin_blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zhuxin_blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="zhuxin_blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  
  <link href="//fonts.googleapis.com/css?family=Inconsolata:400,700|Open+Sans:700,400" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <div id="header-title">
        <h1 id="logo-wrap">
          <a href="/" id="logo">
          
              <span id="subtitle">每天进步一点点</span>
          
          </a>
        </h1>
      </div>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">我的文章</a>
        
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</div>
      <div class="outer">
        <section id="main">
  
    <article id="post-phabricator/eslint" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/21/phabricator/eslint/" class="article-date">
  <time datetime="2016-11-21T15:42:13.212Z" itemprop="datePublished">2016-11-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/development-tools/">development tools</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/21/phabricator/eslint/">eslint</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Why-We-Need-Eslint"><a href="#Why-We-Need-Eslint" class="headerlink" title="Why We Need Eslint?"></a>Why We Need Eslint?</h3><blockquote>
<p>在团队配合中，有的人是Mac开发，有的人是Windows来发，使用Eslint来强制开发人员统一代码<br>格式，比如常见的<code>tab</code>以及空格,以及windows和Mac的回车标识，也可强制开发人员删除无用的<br>垃圾代码，比如<code>alert(1212), console.log(111)</code>等等，或者条件语句中使用<code>if(true){}</code>,<br>总之它就是用来检测开发人员代码书写规范的一个集成工具。so beautiful!</p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/21/phabricator/eslint/" data-id="ciw58i9xk002muko0ffx914m0" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/movitation_design" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/17/vue/movitation_design/" class="article-date">
  <time datetime="2016-11-17T11:43:37.495Z" itemprop="datePublished">2016-11-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/17/vue/movitation_design/">了解Vue</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>vue是一个用来构建交互式web界面的库。它的核心集中于视图层，它很容易与其他库或现有的项目集成。<br>另一方面，Vue完全有能力服务员复杂的单页面应用。但是Vue和其它的框架有什么不同呢？</p>
</blockquote>
<h3 id="和React的比较"><a href="#和React的比较" class="headerlink" title="和React的比较"></a>和React的比较</h3><blockquote>
<p>React和Vue有很多相似之处:</p>
<ul>
<li>利用虚拟DOM</li>
<li>提供了reactive(反应性)和可组合的视图组件<br>在代码核心库中，保持对相关库管理的routing，全局state的关注。作用域也很相似。我们想保证的不仅<br>有技术上的准确也要确保技术的平衡，我们找出React哪里优于Vue，比如，React庞大的生态圈以及<br>自定义渲染器的丰富性。</li>
</ul>
</blockquote>
<h5 id="性能（渲染性能）"><a href="#性能（渲染性能）" class="headerlink" title="性能（渲染性能）"></a>性能（渲染性能）</h5><blockquote>
<p>Vue胜过React，当渲染UI时，DOM的操作通常是非常昂贵的，没有库可以使那些原生的操作更快，我们能做的<br>最好的就是:</p>
<ol>
<li>尽量减少必要的DOM变化的数量，React和Vue都使用了虚拟DOM来解决这个问题。</li>
<li>尽可能在顶层的DOM操作上添加较小的开销(纯js计算)，这里是React和Vue的区别。<br>javascript开销和计算必要的DOM操作机制有直接关系，Vue和React都利用虚拟DOM来达到它，但是Vue的实现更<br>轻量级，因此比React的开销更少。<br>React和Vue都提供了功能组件，他们是stateless，instanceless的因此需要的开销很少。当它们用于性能关键<br>的场景中，Vue更快，为了证明这个，我们渲染1万个item100次，强烈建议自己实践，因为它和软件、浏览器相关。<br>相关比较如下:</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                  Vue       React</span><br><span class="line">Fatest            23ms      63ms</span><br><span class="line">Mediam            42ms      81ms</span><br><span class="line">Average           51ms      94ms</span><br><span class="line">95thPerc.         73ms      164ms</span><br><span class="line">Slowest           343ms     453ms</span><br></pre></td></tr></table></figure>
<h5 id="更新性能"><a href="#更新性能" class="headerlink" title="更新性能"></a>更新性能</h5><blockquote>
<p>在React中，当一个组件的state改变了，它会触发整个组件的sub-tree的重新渲染，为了避免child组件不必要<br>的渲染，你需要在该组件中使用<code>shouldComponentUpdate</code>并定义不变的结构，而在Vue中，在渲染过程中，会自<br>动的追踪组件的依赖项，所以系统会精确的知道哪个组件需要正真的重新渲染。这就意味着未优化的Vue比未优化的<br>React要快。由于Vue的加强了渲染性能，即使React进行了全部的优化操作，通常也比Vue慢。</p>
</blockquote>
<h5 id="在开发过程中"><a href="#在开发过程中" class="headerlink" title="在开发过程中"></a>在开发过程中</h5><blockquote>
<p>虽然在生产环境中的性能指标是非常重要的，因为这和用户体验相关联。但是在开发时的性能仍然重要，因为这与<br>我们开发者相关联.<br>Vue和React在大多数程序中开发可以保持足够快速。但是，在高帧速率的可视化或动画时，Vue每秒处理10帧，而<br>React每秒只有1帧。这是因为在开发环境中React需要检查大量的不变量，这是用来提示一些重要的错误或警告用的。<br>当然在Vue中也是同意这是很重要的，但是当执行这些检查时，我们对性能保持密切关注。</p>
</blockquote>
<h5 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML &amp; CSS"></a>HTML &amp; CSS</h5><blockquote>
<p>在React中，所有的东西是javascript，虽然听起来很简单且高雅但是当你向下挖掘时，在javascript中写HTML和CSS，<br>当解决问题时，会很痛苦。而在Vue中，我们信奉web的技术并将它们，将css写在html顶部。</p>
<p>####### JSX vs Templates<br>在React中，所有的组件在JSX中来表示他们的UI，下面是个例子:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  let &#123; items &#125; = this.props</span><br><span class="line">  let children</span><br><span class="line">  if (items.length &gt; 0) &#123;</span><br><span class="line">    children = (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;items.map(item =&gt;</span><br><span class="line">          &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    children = &lt;p&gt;No items found.&lt;/p&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&apos;list-container&apos;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JSX有以下优点：</p>
<ul>
<li>使用编程语言（js）构建你的视图。</li>
<li>在某些方式下，对JSX的工具支持比vue的模板更先进。<br>在Vue中，我们有<code>render functions</code>甚至还有支持<code>jsx</code>。</li>
</ul>
</blockquote>
<h3 id="HTML-amp-CSS-1"><a href="#HTML-amp-CSS-1" class="headerlink" title="HTML &amp; CSS"></a>HTML &amp; CSS</h3><blockquote>
<p>在Vue中，有渲染器函数并且支持<code>jsx</code>,默认情况下，我们提供模板作为选择方案:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;list-container&quot;&gt;</span><br><span class="line">    &lt;ul v-if=&quot;items.length&quot;&gt;</span><br><span class="line">      &lt;li v-for=&quot;item in items&quot;&gt;</span><br><span class="line">        &#123;&#123; item.name &#125;&#125;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;p v-else&gt;No items found.&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它的优势：</p>
<ul>
<li>模板中有少量的实现并且代码风格优雅</li>
<li>模板一直是称述性质的</li>
<li>任何有效的HTML在模板中也是有效的</li>
<li>读起来很像英语</li>
<li>不需要再高版本的javascript中增加可读性。<br>另外一个好处就是你可以使用预处理器处理<code>HTML-compliant</code>模板，比如Pug书写你的Vue模板:</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.list-container</span><br><span class="line">  ul(v-if=&quot;items.length&quot;)</span><br><span class="line">    li(v-for=&quot;item in items&quot;) &#123;&#123; item.name &#125;&#125;</span><br><span class="line">  p(v-else) No items found.</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Component-Scoped CSS（组件范围的CSS）</strong><br>除非你的组件分布在多个文件中（比如CSS Modules），范围性的CSS在React中通常是在js中。而在<br>Vue中，你完全可以在单个文件中访问到CSS：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">  @media (min-width: 250px) &#123;</span><br><span class="line">    .list-container:hover &#123;</span><br><span class="line">      background: orange;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>scoped</code>属性自动的对组件范围内的元素通过添加一个唯一的属性来编译。</p>
</blockquote>
<h3 id="规模"><a href="#规模" class="headerlink" title="规模"></a>规模</h3><blockquote>
<p>React社区在状态管理上引入了<code>flux/redux</code>,状态管理方式可以在Vue很容易的集成进来。但是尽管<br>如此，React的生态圈还是要比Vue丰富。Vue提供了一个十分简单生成Vue项目的<a href="https://github.com/vuejs/vue-cli" target="_blank" rel="external">命令行工具</a>。</p>
</blockquote>
<h3 id="Scaling-Down"><a href="#Scaling-Down" class="headerlink" title="Scaling Down"></a>Scaling Down</h3><blockquote>
<p>React的学习曲线比较陡峭，在你学习之前你需要了解JSX以及ES2015.Vue中可以简单的通过在html引入vue库<br>来使用vue，React也行啊！！！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Native-Rendering"><a href="#Native-Rendering" class="headerlink" title="Native Rendering"></a>Native Rendering</h3><blockquote>
<p>React Native可以已React组件的形式写原生的IOS、Android程序，在这方面，Vue已经与<a href="https://alibaba.github.io/weex/" target="_blank" rel="external">Weex</a>合作了。<br>Weex是由阿里巴巴开发的一个跨平台UI框架，这意味着使用Weex，你可以以Vue的组件语法规则开发出的程序可以在浏览器，IOS，Android运行。<br>额，这点我承认确实比react-native强悍啊。。。。，当然Weex正在活跃的开发，和react-native一样不成熟。但是Vue和Weex合作开发啊，选择<br>React社区还是选择Vue社区呢？如果Weex和Vue成熟稳定的话选择Vue生态圈我觉得还是不错的。</p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/17/vue/movitation_design/" data-id="ciw58i9z4003vuko0eszy016r" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-phabricator/install_phabricator" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/16/phabricator/install_phabricator/" class="article-date">
  <time datetime="2016-11-16T14:15:53.637Z" itemprop="datePublished">2016-11-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/development-tools/">development tools</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/16/phabricator/install_phabricator/">phbricator的安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Phabricator"><a href="#Phabricator" class="headerlink" title="Phabricator"></a>Phabricator</h3><blockquote>
<p>Phabricator是一个开发软件工具的集成，包含任务管理，代码review，管理git,svn等等,持续集成的构建，<br>内部通道的讨论等等。</p>
</blockquote>
<h3 id="在我们局域网内安装phabricator"><a href="#在我们局域网内安装phabricator" class="headerlink" title="在我们局域网内安装phabricator"></a>在我们局域网内安装phabricator</h3><blockquote>
<p>Phabricator是一个LAMP应用程序，所以:</p>
<ul>
<li>一台linux或Mac OS电脑。(ps: windows不行奥，因为一些命令行在windows无法执行。。。)</li>
<li>一个域名(可有可无，在内网上访问就行了，除非你需要家里办公也访问)(格式:phabricator.xxxxx.com).</li>
<li>一些基本的系统管理员的技能(linux命令得熟悉啊！)</li>
<li>一个web容器，Apache或Nginx（常用的两种方式）</li>
<li>PHP(version: &gt;= 5.2, 版本7不支持), MySql(version: &gt;= 5.5), git.<br>系统管理员应该会的一些技能（也就是linux的一些指令）,比如：在操作系统安装软件，文件系统的操作，进程<br>的管理，权限的处理，修改配置文件，设置环境变量等等。</li>
</ul>
</blockquote>
<h3 id="安装需要的组件"><a href="#安装需要的组件" class="headerlink" title="安装需要的组件"></a>安装需要的组件</h3><blockquote>
<ul>
<li>git(在包管理系统中一般称为’git’)</li>
<li>Apache(一般称为”httpd”或”apache2”)或者nginx</li>
<li>MySQL Server(一般是”mysqlId”或”mysql-server”)</li>
<li>PHP(一般是”php”)</li>
<li>需要的PHP扩展，比如”php-mysql”, “php5-mysql”<br>如果已经安装好了这些，那么获取Phrbricator以及它的依赖:</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//选择你要安装的文件夹，并在该文件夹下执行以下命令</span><br><span class="line">git clone https://github.com/phacility/libphutil.git</span><br><span class="line">git clone https://github.com/phacility/arcanist.git</span><br><span class="line">git clone https://github.com/phacility/phabricator.git</span><br></pre></td></tr></table></figure>
<blockquote>
<p>APC是建议安装的，所以没有深究。</p>
</blockquote>
<h3 id="Apache容器的配置"><a href="#Apache容器的配置" class="headerlink" title="Apache容器的配置"></a>Apache容器的配置</h3><blockquote>
<ul>
<li>配置web容器(Apache, nginx)</li>
<li>在浏览器访问phabricator<br>Apache的httpd.conf</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *&gt;</span><br><span class="line">  # Change this to the domain which points to your host.</span><br><span class="line">  ServerName phabricator.example.com</span><br><span class="line"></span><br><span class="line">  # Change this to the path where you put &apos;phabricator&apos; when you checked it</span><br><span class="line">  # out from GitHub when following the Installation Guide.</span><br><span class="line">  #</span><br><span class="line">  # Make sure you include &quot;/webroot&quot; at the end!</span><br><span class="line">  DocumentRoot /path/to/phabricator/webroot</span><br><span class="line">  RewriteEngine on</span><br><span class="line">  RewriteRule ^(.*)$          /index.php?__path__=$1  [B,L,QSA]</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果Apache的配置文件目录不是Phabricator的目录，那么你需要添加<code>&lt;Directory /&gt;</code>块，这个块<br>标示依赖于你的Apache的版本，通过运行<code>httpd -v</code>得到当前运行Apache的版本，如果版本号小于2.4,</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot;/path/to/phabricator/webroot&quot;&gt;</span><br><span class="line">  Order allow,deny</span><br><span class="line">  Allow from all</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果大于2.4:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot;/path/to/phabricator/webroot&quot;&gt;</span><br><span class="line">  Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置完成之后，请重启Apache，并继续接下来的配置.</p>
</blockquote>
<h3 id="Nginx的配置"><a href="#Nginx的配置" class="headerlink" title="Nginx的配置"></a>Nginx的配置</h3><blockquote>
<p>nginx.conf:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  server_name phabricator.example.com;</span><br><span class="line">  #你的phabricator安装目录</span><br><span class="line">  root        /path/to/phabricator/webroot;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    index index.php;</span><br><span class="line">    rewrite ^/(.*)$ /index.php?__path__=/$1 last;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location /index.php &#123;</span><br><span class="line">    fastcgi_pass   localhost:9000;</span><br><span class="line">    fastcgi_index   index.php;</span><br><span class="line"></span><br><span class="line">    #required if PHP was built with --enable-force-cgi-redirect</span><br><span class="line">    fastcgi_param  REDIRECT_STATUS    200;</span><br><span class="line"></span><br><span class="line">    #variables to make the $_SERVER populate in PHP</span><br><span class="line">    fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;</span><br><span class="line">    fastcgi_param  QUERY_STRING       $query_string;</span><br><span class="line">    fastcgi_param  REQUEST_METHOD     $request_method;</span><br><span class="line">    fastcgi_param  CONTENT_TYPE       $content_type;</span><br><span class="line">    fastcgi_param  CONTENT_LENGTH     $content_length;</span><br><span class="line"></span><br><span class="line">    fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;</span><br><span class="line"></span><br><span class="line">    fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;</span><br><span class="line">    fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;</span><br><span class="line"></span><br><span class="line">    fastcgi_param  REMOTE_ADDR        $remote_addr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置完成之后重启nginx，并继续接下来的配置</p>
</blockquote>
<h3 id="配置Mysql"><a href="#配置Mysql" class="headerlink" title="配置Mysql"></a>配置Mysql</h3><blockquote>
<p>当MySQL运行时，需要加载Phabricator的schemata，所以要在phabricator目录下执行:<code>./bin/storage upgrade</code><br>如果你配置的用户不是连接数据库的特权用户，所以需要覆盖默认的用户，所以更改schema，通过一下命令更改<br><code>./bin/storage upgrade --user &lt;user&gt; --password &lt;password&gt;</code>并且<code>./bin/storage upgrade --force</code><br><strong>注意：</strong>当修改了phabricator后，运行<code>storage upgrade</code>来应用新的修改。</p>
</blockquote>
<h3 id="配置账号及注册"><a href="#配置账号及注册" class="headerlink" title="配置账号及注册"></a>配置账号及注册</h3><blockquote>
<p>phabricator提供了很多的登录体系，你可以配置谁可以访问或者注册你安装的phabricator以及用户用存在的账号登录phabricator。<br>登录方式称之为授权给予，比如可用的”用户名/密码”授权，允许你通过传统的用户名密码登录，其余的支持用证书登录。比如:</p>
<ul>
<li><strong>用户名密码：</strong>使用用户名密码登录注册</li>
<li><strong>LDAP：</strong>使用LDAP证书登录注册</li>
<li><strong>OAuth：</strong>用户使用支持OAuth2的协议登录，比如(Facebook,Google,GitHub)</li>
<li><strong>其余的提供程序：</strong>有许多可用的支持，Phabricator可以扩展，相关知识请自行了解。<br>默认情况下，没有可用的提供程序，你必须在安装完成之后使用”Auth”程序添加一种或多种提供程序。在你添加供应程序之后，<br>你可以使用存在的账号连接phabricator（比如你可以使用GitHub的OAuth账号登录Phabricator）或者用户使用它注册新的账<br>号（假设你启用这些选项）<br><strong>恢复管理员账号</strong>如果你意外的在phabrication中锁住了，你可以使用<code>bin/auth</code>脚本恢复管理员账号的访问，恢复访问，请使用:<br><code>./bin/auth recover &lt;username&gt;</code>,username是你想恢复的管理员的账号。<br><strong>通过web页面管理账号</strong>使用管理员账号登录phabricator并路由到<code>/people</code>,点击”People”,如果你是管理员，你可以看见创建<br>及修改账号的选项。<br><strong>手动的创建新账号</strong>，有两种手工创建账号的方式，一种是通过web网页另一种是通过命令行，<code>./bin/accountadamin</code>,一些选项<br>(如设置密码，更改账号标记)只能在命令行中可见。你可以使用此命令来使一个用户成为管理员（比如你意外的移除了你管理员的标记）<br>或者创建一个管理员账号。</li>
</ul>
</blockquote>
<h3 id="TODO-配置文件存储"><a href="#TODO-配置文件存储" class="headerlink" title="TODO(配置文件存储)"></a>TODO(配置文件存储)</h3><h3 id="TODO-配置邮件发送"><a href="#TODO-配置邮件发送" class="headerlink" title="TODO(配置邮件发送)"></a>TODO(配置邮件发送)</h3>
      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/16/phabricator/install_phabricator/" data-id="ciw58i9xt002ruko0dz164v5h" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-react/internal_instance" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/16/react/internal_instance/" class="article-date">
  <time datetime="2016-11-15T16:59:33.447Z" itemprop="datePublished">2016-11-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React/">React</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/16/react/internal_instance/">内部实例的伪实现（思考）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>为什么需要内部实例呢?<br>React的主要特性是你可以重新渲染任何东西，并且你不会重复创建DOM以及重置state.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;App /&gt;, rootEl);</span><br><span class="line">//下面这一行会重新使用已存在的DOM</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, rootEl);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当组件需要更新时，如何存储必要的信息呢？比如说<code>publicInstances</code>,DOM元素与组件之间的关系。<br>堆栈协调器代码库通过在类中加了一个<code>mount()</code>函数解决这个问题，这种方式有点缺点，正在改进。<br>把<code>mountHost()</code>和<code>mountComposite()</code>分离出来的替代方案是创建了两个类<code>DOMComponent</code>和<code>CompositeComponent</code><br>这两个类都有一个接收<code>element</code>的构造函数，当然还有一个<code>mount()</code>方法返回已镶嵌的节点，用一个工厂方法实例化正确的<br>class来替代顶级<code>mount()</code>方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function instantiateComponent(element) &#123;</span><br><span class="line">  var type = element.type;</span><br><span class="line">  if(typeof type === &apos;function&apos;) &#123;</span><br><span class="line">    return new CompositeComponent(type);</span><br><span class="line">  &#125;else if(typeof type === &apos;string&apos;) &#123;</span><br><span class="line">    return new DOMComponent(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CompositeComponent(复杂组件)的实现:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class CompositeComponent &#123;</span><br><span class="line">  constructor(element) &#123;</span><br><span class="line">    this.currentElement = element;</span><br><span class="line">    this.renderedComponent = null;</span><br><span class="line">    this.publicInstance = null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getPublicInstance() &#123;</span><br><span class="line">    // For composite components, expose the class instance.</span><br><span class="line">    return this.publicInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mount() &#123;</span><br><span class="line">    var element = this.currentElement;</span><br><span class="line">    var type = element.type;</span><br><span class="line">    var props = element.props;</span><br><span class="line"></span><br><span class="line">    var publicInstance;</span><br><span class="line">    var renderedElement;</span><br><span class="line">    if (isClass(type)) &#123;</span><br><span class="line">      // Component class</span><br><span class="line">      publicInstance = new type(props);</span><br><span class="line">      // Set the props</span><br><span class="line">      publicInstance.props = props;</span><br><span class="line">      // Call the lifecycle if necessary</span><br><span class="line">      if (publicInstance.componentWillMount) &#123;</span><br><span class="line">        publicInstance.componentWillMount();</span><br><span class="line">      &#125;</span><br><span class="line">      renderedElement = publicInstance.render();</span><br><span class="line">    &#125; else if (typeof type === &apos;function&apos;) &#123;</span><br><span class="line">      // Component function</span><br><span class="line">      publicInstance = null;</span><br><span class="line">      renderedElement = type(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Save the public instance</span><br><span class="line">    this.publicInstance = publicInstance;</span><br><span class="line"></span><br><span class="line">    // Instantiate the child internal instance according to the element.</span><br><span class="line">    // It would be a DOMComponent for &lt;div /&gt; or &lt;p /&gt;,</span><br><span class="line">    // and a CompositeComponent for &lt;App /&gt; or &lt;Button /&gt;:</span><br><span class="line">    var renderedComponent = instantiateComponent(renderedElement);</span><br><span class="line">    this.renderedComponent = renderedComponent;</span><br><span class="line"></span><br><span class="line">    // Mount the rendered output</span><br><span class="line">    return renderedComponent.mount();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>DOMComponent</code>类的实现:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class DOMComponent &#123;</span><br><span class="line">  constructor(element) &#123;</span><br><span class="line">    this.currentElement = element;</span><br><span class="line">    this.renderedChildren = [];</span><br><span class="line">    this.node = null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getPublicInstance() &#123;</span><br><span class="line">    // For DOM components, only expose the DOM node.</span><br><span class="line">    return this.node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mount() &#123;</span><br><span class="line">    var element = this.currentElement;</span><br><span class="line">    var type = element.type;</span><br><span class="line">    var props = element.props;</span><br><span class="line">    var children = props.children || [];</span><br><span class="line">    if (!Array.isArray(children)) &#123;</span><br><span class="line">      children = [children];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Create and save the node</span><br><span class="line">    var node = document.createElement(type);</span><br><span class="line">    this.node = node;</span><br><span class="line"></span><br><span class="line">    // Set the attributes</span><br><span class="line">    Object.keys(props).forEach(propName =&gt; &#123;</span><br><span class="line">      if (propName !== &apos;children&apos;) &#123;</span><br><span class="line">        node.setAttribute(propName, props[propName]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Create and save the contained children.</span><br><span class="line">    // Each of them can be a DOMComponent or a CompositeComponent,</span><br><span class="line">    // depending on whether the element type is a string or a function.</span><br><span class="line">    var renderedChildren = children.map(instantiateComponent);</span><br><span class="line">    this.renderedChildren = renderedChildren;</span><br><span class="line"></span><br><span class="line">    // Collect DOM nodes they return on mount</span><br><span class="line">    var childNodes = renderedChildren.map(child =&gt; child.mount());</span><br><span class="line">    childNodes.forEach(childNode =&gt; node.appendChild(childNode));</span><br><span class="line"></span><br><span class="line">    // Return the DOM node as mount result</span><br><span class="line">    return node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果是，每一个内部实例都不论是复合型的还是平台特有的，都指向他的child的内部实例，比如:<br><code>&lt;App&gt;</code>组件渲染了一个<code>&lt;Button&gt;</code>,<code>&lt;Button&gt;</code>渲染了一个<code>&lt;div&gt;</code>,内部实例树将是下面的样子:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[object CompositeComponent] &#123;</span><br><span class="line">  currentElement: &lt;App /&gt;,</span><br><span class="line">  publicInstance: null,</span><br><span class="line">  renderedComponent: [object CompositeComponent] &#123;</span><br><span class="line">    currentElement: &lt;Button /&gt;,</span><br><span class="line">    publicInstance: [object Button],</span><br><span class="line">    renderedComponent: [object DOMComponent] &#123;</span><br><span class="line">      currentElement: &lt;div /&gt;,</span><br><span class="line">      node: [object HTMLDivElement],</span><br><span class="line">      renderedChildren: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在DOM中只看见<code>&lt;div&gt;</code>,但是内部实例可以包含混合型及平台特有的内部实例二者。混合型内部实例<br>需要存储:</p>
<ul>
<li>当前元素</li>
<li>如果元素类型是类，则包含公共实例</li>
<li>单独的渲染的内部实例，既可以是<code>DOMComponent</code>,也可以是<code>CompositeComponent</code>.<br>平台特有内部实例需要存储:</li>
<li>当前元素</li>
<li>DOM节点</li>
<li>所有的子内部实例，它们既可以是<code>DOMComponent</code>也可以是<code>CompositeComponent</code>.</li>
</ul>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/16/react/internal_instance/" data-id="ciw58i9xr002puko0e6334brd" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-react/design_principles" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/15/react/design_principles/" class="article-date">
  <time datetime="2016-11-14T16:00:36.545Z" itemprop="datePublished">2016-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React/">React</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/15/react/design_principles/">设计原则</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>我们写这篇文章的目的是为了让你对React有一个更好的认知，什么能做和什么不能做以及React的设计理念<br>虽然我们很乐意看到社区的贡献，但是我们也不希望悠然违反一些原则。<br>注意：这篇文章是假设你对React有一个很深的理解，它描述了React的设计原则，而不是React组件及程序<br>对React的简介请阅读<a href="https://facebook.github.io/react/docs/thinking-in-react.html" target="_blank" rel="external">Thinking in React</a></p>
</blockquote>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><blockquote>
<p>React的主要特性是组建的组成，不同人编写的组件可以一起更好的工作，你可以给一个组件添加功能而不会影响整个代码库的更改.<br>比如：在一个组件中引入一些本地state而不会对使用它的组件造成影响。同样，如果有必要可以添加初始化以及拆卸的代码到任何组件中。<br>在组建中使用state或生命周期挂钩也不是坏的，比如一些功能强大的特性，它们应该有节制的使用，但是我们没有移除它们的打算，相反的，<br>我们认为他们是使得的React更有用的组成部分。我们将来会使更多的<a href="https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State" target="_blank" rel="external">功能模式</a><br>但是，本地state和生命周期挂钩将为该模型的一部分。<br>组件经常被描述为’just functions’,但是在我们的视角中，他们需要变得更加有用，在React中，组件描述了任何组成的行为，包括rendering<br>生命周期，以及state，一些外部的库，像Relay增加组件了其他的责任，比如描述data依赖。</p>
</blockquote>
<h3 id="Common-Abstraction（通用的抽象）"><a href="#Common-Abstraction（通用的抽象）" class="headerlink" title="Common Abstraction（通用的抽象）"></a>Common Abstraction（通用的抽象）</h3><blockquote>
<p>通常情况下我们抵制在用户级就可以实现的行为，我们不想用无用的库膨胀你的应用，但是也有些例外，比如：如果React对本地state和生命周期<br>挂钩不提供支持，用户会创建通用抽象给他们，当有多个抽象竞争时React不能充分利用他们的属性执行，它不得不以最低的标准工作。这也是为什么<br>我们有时会给React添加一些特性，如果我们注意到许多组件不兼容或低效的执行某些功能，我们可能更愿意考到React。我们不会轻易的干这件事。<br>当我们做它时，因为我们有信心提高抽象层次使整个生态系统受益。state，生命周期挂钩跨浏览器事件正常化是个很好的例子。我们经常与社区讨论<br>改善建议，你可以在<a href="https://github.com/facebook/react/issues?q=is%3Aopen+is%3Aissue+label%3A%22big+picture%22" target="_blank" rel="external">big picture</a>中找到这些讨论</p>
</blockquote>
<h3 id="Escape-Hatches-逃生舱口"><a href="#Escape-Hatches-逃生舱口" class="headerlink" title="Escape Hatches(逃生舱口)"></a>Escape Hatches(逃生舱口)</h3><blockquote>
<p>React是实用主义的，它是由写Facebook的产品需求而驱动的，虽然它受一些范例的影响，但也不是完全主流。比如，函数式编程，对不同技能的开发<br>保持可访问是项目的一个明确的目标。如果我们想反对一个我们不喜欢的模式，在反对它之前我们考虑所有存在的场景。如果一些模式对于构建app和有用<br>但是很难表达，我们会为它提供必要的API。</p>
</blockquote>
<h3 id="Stability-稳定性"><a href="#Stability-稳定性" class="headerlink" title="Stability(稳定性)"></a>Stability(稳定性)</h3><blockquote>
<p>我们重视API的稳定性，Facebook有两万个组件在使用React，这也是我们为什么通常不愿意改变公共API或行为。但是”nothing changes”稳定性的意义有点被<br>高估了,它迅速停滞了。相反，我们更喜欢”在生产环境大量使用并且一些东西变化时有一个明确的迁移路径”的稳定意义。当我们反对一种形式时，我们在Facebook研究<br>它的内部使用并添加反对警告。这让我们评估改变的重大影响。有时，我们发现它太简单的话我们会退出，并且我们需要战略性的思考关于这次改动代码库的要点是否准备好。<br>如果我们自行这次的更改不是太具有破坏性并且此次战略性转移对用户场景是可实施的，我们会在社区中释放反对警告。我们会和外部使用React的用户密切联系并且我们会<br>监视流行的开源项目并指引他们修理这些警告。由于React代码库规模庞大，内部迁移成功是一个很好的指标并且其余公司也不会有问题。</p>
</blockquote>
<h3 id="Scheduling-时间表-进度表"><a href="#Scheduling-时间表-进度表" class="headerlink" title="Scheduling(时间表 进度表)"></a>Scheduling(时间表 进度表)</h3><blockquote>
<p>在React中即使你的组件被描述为函数，你也不能直接调用它们。每一个组件返回一个<a href="https://facebook.github.io/react/contributing/design-principles.html" target="_blank" rel="external">需要渲染什么的描述</a><br>并且这个描述包括用户自定义组件及主机组件。通过组件的递归得到render结果去更改UI树。这是一个不明显但是很强大的区别，因为你不会调用组件函数但是让React自己调用.<br>这意味着如果有必要React有权延迟调用它。在当下的实现中，在单个刻度期间，React递归的走着树并调用所有的要修改的树的render函数。在反应的设计中这是一个共同的主题，<br>一些流行的库实现的是”push”方法，当新数据可用时再执行计算。然而React坚持”pull”方法，计算会被推迟，除非有必要。<br>React不是一个普通的数据处理库，它是用来构建用户界面的。我们认为在app中有独特的优势，因为它知道哪些计算是有意义的哪些没有。如果有些多东西在屏幕外，我们可以<br>延迟它的数据逻辑处理,如果数据到达的速度快于frame的速度，我们可以批量更新，我们可以优先考虑用户交互的工作（点击button的动画效果）来避免dropping frame，<br>不太重要的(从网络获取数据)后台工作</p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/15/react/design_principles/" data-id="ciw58i9xd002kuko0zjsnhev3" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-react/implemention_notes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/12/react/implemention_notes/" class="article-date">
  <time datetime="2016-11-12T03:01:19.631Z" itemprop="datePublished">2016-11-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React/">React</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/12/react/implemention_notes/">实现说明</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="实现说明"><a href="#实现说明" class="headerlink" title="实现说明"></a>实现说明</h3><blockquote>
<p>这一节主要是对堆栈协调器的实现说明,对React的API有一个技术性的理解，以及React是如何将<br>它分为core,renders,reconciler是很重要的，如果你对React的代码库不是很熟悉，请阅读React<br>代码库的概览。stack reconciler(堆栈协调器)供应所有React的生产代码。它位于<code>src/renders/shared/stack/reconciler</code>目录下<br>并且ReactDOM和ReactNative都使用它。</p>
</blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>协调器没有一个公共的API，ReactDOM和ReactNative的渲染器有效的使用它有效的更新用户接口，这些接口是用户编写的用户组件。<br><strong>以递归的过程镶嵌</strong><br>你第一次镶嵌一个组件时:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;App /&gt;, rootEl);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ReactDOM会顺着reconciler(协调器)传递<code>&lt;App /&gt;</code>,自助<code>&lt;App /&gt;</code>是一个React元素，下面的是一个渲染什么的描述，你可以认为它是<br>一个简单的对象：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&lt;App /&gt;);</span><br><span class="line">// &#123; type: App, props: &#123;&#125; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>协调器会检查<code>&lt;App/&gt;</code>是一个class还是一个函数，如果App是一个函数，协调器会调用<code>App(props)</code>来获取要渲染的元素。<br>如果App是一个类，协调器会用<code>new App(props)</code>实例化这个App，调用<code>componentWillMount()</code>生命周期方法，然后调用<code>render()</code>方法<br>来获取渲染的元素.<br>无论哪种方式，协调器会知道App要渲染的元素。这个过程是递归的，App有可能渲染到<code>&lt;Greeting /&gt;</code>, Greeting可能渲染到<code>&lt;Button / &gt;</code>等等,<br>协调器会递归的通过用户定义的组件向下挖去，知道它知道每一个组件会渲染成什么。你可以假设这个过程的伪代码：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">function isClass(type) &#123;</span><br><span class="line">  //React.Component的子类都有这个标记</span><br><span class="line">  return (Boolean(type.prototype) &amp;&amp; Boolean(type.prototype.isReactComponet));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个函数接受一个React元素，比如(&lt;App/&gt;)</span><br><span class="line">//返回一个表示为镶嵌的树的DOM或原生节点</span><br><span class="line">function mount(element) &#123;</span><br><span class="line">  var type = element.type;</span><br><span class="line">  var props = element.props;</span><br><span class="line">  //我们需要查明/确定渲染的元素，将type作为函数运行或者创建一个实例并调用render</span><br><span class="line">  var renderedElement;</span><br><span class="line">  if(isClass(type)) &#123;</span><br><span class="line">    //组件类</span><br><span class="line">    var publicInstance = new type(props);</span><br><span class="line">    //设置属性</span><br><span class="line">    publicInstance.props = props;</span><br><span class="line">    //如果有必要则调用生命周期</span><br><span class="line">    if(publicInstance.componentWillMount) &#123;</span><br><span class="line">      publicInstance.componentWillMount();</span><br><span class="line">    &#125;</span><br><span class="line">    //通过调用render()得到渲染的元素</span><br><span class="line">    renderedElement = publicInstance.render();</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    //组件函数</span><br><span class="line">    renderedElement = type(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //这个过程是递归的因为一个组件返回的元素有可能是一个别的类型的组件</span><br><span class="line">  return mount(renderedElement);</span><br><span class="line">  //注意：这个实现是没有完成的而且会无限循环，它只会处理类似&lt;App /&gt;,&lt;Button&gt;的元素</span><br><span class="line">  //它还没有支持处理像&lt;div /&gt;或&lt;p/&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var rootEl = document.getElementById(&apos;root&apos;);</span><br><span class="line">var node = mount(&lt;App /&gt;);</span><br><span class="line">rootEl.appendChild(node);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这仅仅是一段伪代码，它不是真正的实现，它会导致栈溢出，因为我们没有讨论终止递归的条件。<br>我们回顾一下上面例子的几个关键概念：</p>
<ul>
<li>React元素是一些简单的对象来代表组件类型和属性(比如<code>&lt;App/&gt;</code>)。</li>
<li>用户自定义的组件（比如<code>&lt;App /&gt;</code>）可以是一个类也可以是一个函数但是他们最终都会被渲染为元素。</li>
<li>“mounting”是一个递归的过程它用来创建DOM以及Native树，给React的顶级元素（比如<code>&lt;App&gt;</code>）.</li>
</ul>
</blockquote>
<h3 id="Mounting-Host-Elements-镶嵌主机元素"><a href="#Mounting-Host-Elements-镶嵌主机元素" class="headerlink" title="Mounting Host Elements(镶嵌主机元素)"></a>Mounting Host Elements(镶嵌主机元素)</h3><blockquote>
<p>如果我们最终不向屏幕渲染任何东西这个过程将毫无作用，除了用户自定义的组件，React元素也可以表示特定<br>平台的组件.比如，<code>Button</code>可能在render方法中会返回一个<code>&lt;div /&gt;</code>。如果一个元素的类型是字符串，这样处理<br>主机元素：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&lt;div /&gt;);</span><br><span class="line">// &#123; type: &apos;div&apos;, props: &#123;&#125; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没有用户定义与主机元素相联系的代码。<br>当协调器遇到一个主机元素时，协调器会让render小心的镶嵌它，比如，ReactDOM会创建一个DOM节点，如果这个主机元素<br>有子节点，协调器会按照上面的算法递归的镶嵌，子元素是否是主机元素都没有关系（<code>&lt;div&gt;&lt;hr&gt;&lt;/div&gt;</code>），复杂的组件（<code>&lt;div&gt;&lt;Button/&gt;&lt;/div&gt;</code>）<br>子组件生产出来的DOM节点将会追加到父DOM节点，递归的方式，组装为完整的DOM结构。<br>注意：协调器本身不依赖于DOM，完整的镶嵌过程依赖于render（有时候，在源码中称之为镶嵌快照），最终结果可以是DOM node（React DOM）<br>一个字符串(ReactDOM Server)或者是原声的视图(React Native).<br>如果我们想扩展去处理主机元素的话，可以这样：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">function isClass(type) &#123;</span><br><span class="line">  // React.Component子类都有这个标记</span><br><span class="line">  return (</span><br><span class="line">    Boolean(type.prototype) &amp;&amp;</span><br><span class="line">    Boolean(type.prototype.isReactComponent)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个函数只处理复杂类型的元素</span><br><span class="line">//它只处理类似于&lt;App/&gt;和&lt;Button /&gt;这样的，而不是&lt;div/&gt;</span><br><span class="line">function mountComposite(element) &#123;</span><br><span class="line">  var type = element.type;</span><br><span class="line">  var props = element.props;</span><br><span class="line"></span><br><span class="line">  var renderedElement;</span><br><span class="line">  if (isClass(type)) &#123;</span><br><span class="line">    //组件类</span><br><span class="line">    var publicInstance = new type(props);</span><br><span class="line">    // 设置属性</span><br><span class="line">    publicInstance.props = props;</span><br><span class="line">    //如果有必要，调用生命周期</span><br><span class="line">    if (publicInstance.componentWillMount) &#123;</span><br><span class="line">      publicInstance.componentWillMount();</span><br><span class="line">    &#125;</span><br><span class="line">    renderedElement = publicInstance.render();</span><br><span class="line">  &#125; else if (typeof type === &apos;function&apos;) &#123;</span><br><span class="line">    //组件函数</span><br><span class="line">    renderedElement = type(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // This is recursive but we&apos;ll eventually reach the bottom of recursion when</span><br><span class="line">  //这是个递归的过程，但是当元素是主机元素时（比如&lt;div/&gt;而不是复杂的组件）我们最终会到达递归的底部</span><br><span class="line">  return mount(renderedElement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个函数只处理主机类型元素</span><br><span class="line">//比如，它处理&lt;div/&gt;,&lt;p/&gt;不会出来&lt;App/&gt;</span><br><span class="line">function mountHost(element) &#123;</span><br><span class="line">  var type = element.type;</span><br><span class="line">  var props = element.props;</span><br><span class="line">  var children = props.children || [];</span><br><span class="line">  if (!Array.isArray(children)) &#123;</span><br><span class="line">    children = [children];</span><br><span class="line">  &#125;</span><br><span class="line">  children = children.filter(Boolean);</span><br><span class="line"></span><br><span class="line">  //这一块的代码不会再协调器中</span><br><span class="line">  //不同的渲染器可能会初始化不同的节点</span><br><span class="line">  //比如，React Native可能会创建IOS或者Android的视图</span><br><span class="line">  var node = document.createElement(type);</span><br><span class="line">  Object.keys(props).forEach(propName =&gt; &#123;</span><br><span class="line">    if (propName !== &apos;children&apos;) &#123;</span><br><span class="line">      node.setAttribute(propName, props[propName]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  //镶嵌子元素</span><br><span class="line">  children.forEach(childElement =&gt; &#123;</span><br><span class="line">    // Children may be host (e.g. &lt;div /&gt;) or composite (e.g. &lt;Button /&gt;).</span><br><span class="line">    //子元素们可能是主机元素（比如&lt;div/&gt;）或复杂性元素(&lt;Button/&gt;)</span><br><span class="line">    //我们会递归的装载他们</span><br><span class="line">    var childNode = mount(childElement);</span><br><span class="line"></span><br><span class="line">    //这行代码也是渲染器特有的</span><br><span class="line">    //不同的渲染器有不同的结果</span><br><span class="line">    node.appendChild(childNode);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  //将DOM节点的装载结果返回</span><br><span class="line">  //这儿递归结束</span><br><span class="line">  return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mount(element) &#123;</span><br><span class="line">  var type = element.type;</span><br><span class="line">  if (typeof type === &apos;function&apos;) &#123;</span><br><span class="line">    // User-defined components</span><br><span class="line">    return mountComposite(element);</span><br><span class="line">  &#125; else if (typeof type === &apos;string&apos;) &#123;</span><br><span class="line">    // Platform-specific components</span><br><span class="line">    return mountHost(element);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var rootEl = document.getElementById(&apos;root&apos;);</span><br><span class="line">var node = mount(&lt;App /&gt;);</span><br><span class="line">rootEl.appendChild(node);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然这也能工作但里协调器的真正实现还有很远的距离，主要是漏掉了对更新的支持。</p>
</blockquote>
<h3 id="介绍（引入）内部实例"><a href="#介绍（引入）内部实例" class="headerlink" title="介绍（引入）内部实例"></a>介绍（引入）内部实例</h3><blockquote>
<p>React的关键特性是你可以重复渲染任何东西，并且他不会创新创建DOM或重置state：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;App /&gt;, rootEl);</span><br><span class="line">//会重新使用存在的DOM</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, rootEl);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然而，我们上面的实现知识装载初始状态的树，不能对他执行更新操作，因为没有存储一些必要的信息，<br>如publicInstance，或DOM节点对应于哪些组件。stack reconciler代码库通过将<code>mount()</code>函数和一个方法<br>放在一个类上。这种方式有一些缺陷，我们现在正在一相反的方向解决这个问题，重写reconciler正在进行中<br>不管怎样，现在它的工作方式就是这样的。<br>将<code>mountHost</code>和<code>mountComposite</code>函数拆分出来的替代方案就是，我们将创建两个类：<code>DOMComponent</code>和<code>CompositeComponent</code><br>两个类都有一个接收elements的<code>constructor</code>，还有一个返回镶嵌了dom节点的<code>mount()</code>方法，我们将会使用工厂模式代替类中<br>顶级的mount()函数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function instantiateComponent(element) &#123;</span><br><span class="line">  var type = element.type;</span><br><span class="line">  if(typeof type === &apos;function&apos;) &#123;</span><br><span class="line">    //用户定义的组件</span><br><span class="line">    return new CompositeComponent(element);</span><br><span class="line">  &#125;else if(typeof === &apos;string&apos;) &#123;</span><br><span class="line">    //平台组件</span><br><span class="line">    return new DOMComponent(element);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先，让我们思考<code>CompositeComponent</code>的实现方式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class CompositeComponent &#123;</span><br><span class="line">  constructor(element) &#123;</span><br><span class="line">    this.currentElement = element;</span><br><span class="line">    this.renderedElement = null;</span><br><span class="line">    this.publicInstance = null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getPublicInstance() &#123;</span><br><span class="line">    //对应复杂的组件，暴露出这个类实例</span><br><span class="line">    return this.publicInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mount() &#123;</span><br><span class="line">    var element = this.currentElement;</span><br><span class="line">    var type = element.type;</span><br><span class="line">    var props = element.props;</span><br><span class="line">    var publicInstance;</span><br><span class="line">    var renderedElement;</span><br><span class="line">    if(isClass(type)) &#123;</span><br><span class="line">      //组件类</span><br><span class="line">      publicInstance = new type(props);</span><br><span class="line">      //设置属性</span><br><span class="line">      publicInstance.props = props;</span><br><span class="line">      //如果有必要，调用生命周期</span><br><span class="line">      if(publicInstance.componentWillMount) &#123;</span><br><span class="line">        publicInstance.componentWillMount();</span><br><span class="line">      &#125;</span><br><span class="line">      renderedElement = publicInstance.render();</span><br><span class="line">    &#125;else if(typeof type === &apos;function&apos;) &#123;</span><br><span class="line">      publicInstance = null;</span><br><span class="line">      renderedElement = type(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //保存公共实例</span><br><span class="line">    this.publicInstance = publicInstance;</span><br><span class="line">    //根据元素实例化子组件的内部实例</span><br><span class="line">    //&lt;div&gt;,&lt;p&gt;将为一个DOM节点</span><br><span class="line">    //&lt;App /&gt; &lt;Button&gt;将为一个复杂组件</span><br><span class="line">    var renderedComponent = instantiateComponent(renderedElement);</span><br><span class="line">    this.renderedComponent = renderedComponent;</span><br><span class="line"></span><br><span class="line">    //装载renderd的输出</span><br><span class="line">    return renderedComponent.mount();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重构<code>mountHost()</code>之后的主要区别是，我们可以保持<code>this.node</code>以及<code>this.renderedChildren</code>于内部的组件实例相关联。<br>我们也可以在未来将它们用于非破坏性的更新。因此，每一个内部实例，复杂的以及主机的，现在指向其孩子内部实例。<br>为了帮助构思它，如果一个<code>&lt;App&gt;</code>组件函数渲染了一个<code>&lt;Button&gt;</code>类组件，并且<code>Button</code>类渲染了一个<code>&lt;div&gt;</code>，内部实例树<br>长得是这个样子的：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[object CompositeComponent] &#123;</span><br><span class="line">  currentElement: &lt;App /&gt;,</span><br><span class="line">  publicInstance: null,</span><br><span class="line">  rendererComponent: [object CompositeComponent] &#123;</span><br><span class="line">    currentElement: &lt;Button /&gt;,</span><br><span class="line">    publicInstance: [object Button],</span><br><span class="line">    renderedComponent: [object DOMComponent] &#123;</span><br><span class="line">      currentElement: &lt;div /&gt;,</span><br><span class="line">      node: [object HTMLDivElement],</span><br><span class="line">      renderedChildren: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在DOM中你仅仅能看见<code>div</code>,但是内部实例树既包含复杂的内部实例也包含主机的内部实例。<br>复杂的内部实例需要被存储：</p>
<ul>
<li>当前的元素</li>
<li>如果元素类型是个类，public实例</li>
<li>单个的内部实例的渲染结果，它既可以是<code>DOMComponent</code>也可以是<code>CompositeComponent</code><br>主机内部实例也需要被存储:</li>
<li>当前的元素</li>
<li>DOM节点</li>
<li>所有的子内部实例，它们既可以是<code>DOMComponent</code>也可以是<code>CompositeComponent</code>.<br>如果你努力设想在复杂的程序中一个内部实例是什么样的结构，(React DevTools)[<a href="https://github.com/facebook/react-devtools" target="_blank" rel="external">https://github.com/facebook/react-devtools</a>]<br>可以给你一个近似的结果，主机实例是灰色的，复杂实例是紫色的。<br>要完成这个重构，我们要引入一个函数镶嵌完整的树到节点容器。比如<code>ReactDOM.render()</code>,它返回一个公共实例：</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function mountTree(element, containerNode) &#123;</span><br><span class="line">  //创建顶层的内部实例</span><br><span class="line">  var rootComponent = instantiateComponent(element);</span><br><span class="line"></span><br><span class="line">  //装载顶层组件到containetr</span><br><span class="line">  var node = rootComponent.mount();</span><br><span class="line">  containerNode.appendChild(node);</span><br><span class="line">  //返回它提供的公共实例</span><br><span class="line">  var publicInstance = rootComponent.getPublicInstance();</span><br><span class="line">  return publicInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var rootEl = document.getElementById(&apos;root&apos;);</span><br><span class="line">mountTree(&lt;App /&gt;, rootEl);</span><br></pre></td></tr></table></figure>
<h3 id="Unmounting-正在解除挂载"><a href="#Unmounting-正在解除挂载" class="headerlink" title="Unmounting(正在解除挂载)"></a>Unmounting(正在解除挂载)</h3><blockquote>
<p>现在我们有内部实例维持他们的字元素与DOM节点，我们可以实现unmounting，d对于一个复杂的组件，unmounting调用生命周期的钩子<br>然后递归：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class CompositeComponent &#123;</span><br><span class="line"></span><br><span class="line">  //....</span><br><span class="line">  unmount() &#123;</span><br><span class="line">    //如果有必要调用生命周期的钩子</span><br><span class="line">    var publicInstance = this.publicInstance;</span><br><span class="line">    if(publicInstance) &#123;</span><br><span class="line">      if(publicInstance.componentWillUnMount) &#123;</span><br><span class="line">        publicInstance.componentWillUnMount();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //卸载单个渲染的组件</span><br><span class="line">    var renderedComponent = this.renderedComponent;</span><br><span class="line">    renderedComponent.unmount();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于<code>DOMComponent</code>,unmounting告诉每一个子元素卸载:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class DOMComponent &#123;</span><br><span class="line">  //...</span><br><span class="line"></span><br><span class="line">  unmount() &#123;</span><br><span class="line">    //卸载所有children</span><br><span class="line">    var renderedChildren = this.renderedChildren;</span><br><span class="line">    renderedChildren.forEach( child =&gt; child.unmount());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在实践中，卸载DOM组件也会移除事件监听器并且清楚缓存，在这里跳过这些细节。<br>现在我们添加一个新的顶级函数调用<code>unmountTree(containerNode)</code>，这和<code>ReactDOM.unmountComponentAtNode()</code>很相似：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function unmountTree(containerNode) &#123;</span><br><span class="line">  //从DOM节点中读取内部实例</span><br><span class="line">  //(这个还不能工作，我们需要改变mountTree来来储存它)</span><br><span class="line">  var node = containerNode.firstChild;</span><br><span class="line">  var rootComponent = node._internalInstance;</span><br><span class="line"></span><br><span class="line">  //卸载这个树并且情况这个container</span><br><span class="line">  rootComponent.unmount();</span><br><span class="line">  containerNode.innerHTML = &apos;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了使它工作，我们需要从DOM节点中获取内部根实例，我们将会修改<code>mountTree()</code>添加<code>_internalInstance</code>属性到根DOM节点。<br>我们也会告诉<code>mountTree()</code>销毁任何存在的树，所以它可以被调用多次：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function mountTree(element, containerNode) &#123;</span><br><span class="line">  //销毁任何存在的树</span><br><span class="line">  if(containerNode.firstChild) &#123;</span><br><span class="line">    unmountTree(containerNode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //创建顶层内部实例</span><br><span class="line">  var rootComponent = instantiateComponent(element);</span><br><span class="line"></span><br><span class="line">  //装载顶层内部实例到container</span><br><span class="line">  var mode = rootComponent.mount();</span><br><span class="line">  containerNode.appendChild(node);</span><br><span class="line"></span><br><span class="line">  //保存一个到内部实例的引用</span><br><span class="line">  node._internalInstance = rootComponent;</span><br><span class="line"></span><br><span class="line">  //返回它所提供的公共实例</span><br><span class="line">  var publicInstance = rootComponent.getPublicInstance();</span><br><span class="line">  return publicInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，运行<code>unmountTree()</code>或者运行<code>mountTree()</code>多次，移除旧的树然后运行组件的生命周期方法<code>componentWillUnmount</code>.</p>
</blockquote>
<h3 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h3><blockquote>
<p>在上一节，我们实现了<code>unmounting</code>,但是如果每一个属性的变化都会改变unmounted和mounted整个树，这对于React来说没有用，<br>协调器的目的是尽可能的保持和重用现有实例：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var rootEl = document.getElementById(&apos;root&apos;);</span><br><span class="line">mountTree(&lt;App /&gt;, rootEl);</span><br><span class="line">//这里应返回已存在的DOM</span><br><span class="line">mountTree(&lt;App /&gt;, rootEl);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们将会扩展我们的内部实例建立一个或多个方法，除了<code>mount()</code>和<code>unmount()</code>，<code>DOMComponent</code>和<code>CompositeComponent</code>将会<br>实现一个新的<code>receive(nextElement)</code>方法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CompositeComponent &#123;</span><br><span class="line">  //...</span><br><span class="line"></span><br><span class="line">  receive(nextElement) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DOMComponent &#123;</span><br><span class="line">  //...</span><br><span class="line"></span><br><span class="line">  receive(nextElement) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它的职责是根据下一个元素提供的说明做任何有必要的组建更新，这部分通常称之为’虚拟dom差异比较’，尽管真正发生的是内部树的递归然后<br>让每个内部实例接收到更新。</p>
</blockquote>
<h3 id="更新复杂组件-Updating-Composite-Component"><a href="#更新复杂组件-Updating-Composite-Component" class="headerlink" title="更新复杂组件(Updating Composite Component)"></a>更新复杂组件(Updating Composite Component)</h3><blockquote>
<p>当一个复杂组件接收到一个新的元素时，我们运行<code>componentWillUpdate()</code>生命周期钩子。然后我们根据新的属性重新渲染组件，然后得到<br>下一个渲染的元素：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class CompositeComponent &#123;</span><br><span class="line"></span><br><span class="line">  //...</span><br><span class="line"></span><br><span class="line">  receive(nextElement) &#123;</span><br><span class="line">    var prevProps = this.currentElement.props;</span><br><span class="line">    var publicInstance = this.publicInstance;</span><br><span class="line">    var prevRenderedComponent = this.renderedComponent;</span><br><span class="line">    var prevRenderedElement = this.renderedElement;</span><br><span class="line"></span><br><span class="line">    //修改*自己的*元素</span><br><span class="line">    this.currentElement = nextElement;</span><br><span class="line">    var type = nextElement.type;</span><br><span class="line">    var nextProps = nextElement.props;</span><br><span class="line"></span><br><span class="line">    //解决下一次的render()输出的是什么</span><br><span class="line">    var nextRenderedElement;</span><br><span class="line">    if(isClass(type)) &#123;</span><br><span class="line">      //组件类</span><br><span class="line">      //如果有必要调用生命周期</span><br><span class="line">      if(publicInstance.componentWillUpdate) &#123;</span><br><span class="line">        publicInstance.componentWillUpdate(prevProps);</span><br><span class="line">      &#125;</span><br><span class="line">      //修改属性</span><br><span class="line">      publicInstance.props = nextProps;</span><br><span class="line">      //重新渲染</span><br><span class="line">      nextRenderedElement = publicInstance.render();</span><br><span class="line">    &#125;else if(typeof type === &apos;function&apos;) &#123;</span><br><span class="line">      //组件函数</span><br><span class="line">      nextRenderedElement = type(nextProps);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接下来，我们可以看一下渲染的元素的类型，如果在最后一次的渲染中<code>type</code>没有发生变化，下面的<br>组件可以就地更新。例如：如果第一次返回<code>&lt;Button color=&#39;red&#39; /&gt;</code>，第二次返回<code>&lt;Button color=&#39;blue&#39;&gt;</code><br>我们只需要告诉相关联的内部实例接收下一个元素：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//如果渲染的元素的类型没有变化</span><br><span class="line">//复用已存在的组建实例并退出</span><br><span class="line">if(prevRenderedElement.type === nextRenderedElement.type) &#123;</span><br><span class="line">  prevRenderedComponent.receive(nextRenderedElement);</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是，如果下一次渲染的组件类型和上一次渲染的组件类型不同，我们不会修改内部实例，一个<code>&lt;button&gt;</code>不会变为<br>一个<code>&lt;input&gt;</code>：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line"></span><br><span class="line">  //如果我们达到这一点，我们需要卸载先前的</span><br><span class="line">  //装载组件，装载新的，交换他们的节点</span><br><span class="line"></span><br><span class="line">  //找到老节点因为它将被替换</span><br><span class="line">  var prevNode = prevRenderedComponent.getHostNode();</span><br><span class="line"></span><br><span class="line">  //卸载老child并装载新的child</span><br><span class="line">  prevRenderedComponent.unmount();</span><br><span class="line">  var nextRenderedComponent = instantiateComponent(nextRenderedElement);</span><br><span class="line">  var nextNode = nextRenderedComponent.mount();</span><br><span class="line"></span><br><span class="line">  //替换child的引用</span><br><span class="line">  this.renderedComponent = nextRenderedComponent;</span><br><span class="line"></span><br><span class="line">  //用新的替换老节点</span><br><span class="line">  //注意：这是渲染器特定的代码并且在理想情况下，因位于CompositeComponent的外面</span><br><span class="line">  prevNode.parentNode.replaceChild(nextNode, prevNode);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>综上所述，当一个复杂的组件接收到一个新的元素时，要么委托去修改内部实例，要么卸载它并在原来<br>的位置新建一个。<br>这里有另外一种情况，一个组件将会重新装载而不是接收一个元素，当元素的<code>key</code>改变时，我们不讨论<br><code>key</code>的处理，因为它会增加教程的复杂性。注意：我们需要在内部实例添加一个叫<code>getHostNode</code>的方法，<br>它可能位于特定平台的节点并取代它的更新过程。它的实现简单明了：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class CompositeComponent &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  getHostNode() &#123;</span><br><span class="line">    // Ask the rendered component to provide it.</span><br><span class="line">    // This will recursively drill down any composites.</span><br><span class="line">    return this.renderedComponent.getHostNode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DOMComponent &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  getHostNode() &#123;</span><br><span class="line">    return this.node;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新主机组件"><a href="#更新主机组件" class="headerlink" title="更新主机组件"></a>更新主机组件</h3><blockquote>
<p>主机组件实现，比如<code>DOMComponent</code>已不同的方式更新，当它们接收到新的元素时，他们需要更新基于平台特有的视图,<br>在React DOM的情景中，这意味着要更新DOM属性：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class DOMComponent &#123;</span><br><span class="line">  //...</span><br><span class="line">  receive(nextElement) &#123;</span><br><span class="line">    var node = this.node;</span><br><span class="line">    var prevElement = this.currentElement;</span><br><span class="line">    var prevProps = prevElement.props;</span><br><span class="line">    var nextProps = nextElement.props;    </span><br><span class="line">    this.currentElement = nextElement;</span><br><span class="line"></span><br><span class="line">    // Remove old attributes.</span><br><span class="line">    Object.keys(prevProps).forEach(propName =&gt; &#123;</span><br><span class="line">      if (propName !== &apos;children&apos; &amp;&amp; !nextProps.hasOwnProperty(propName)) &#123;</span><br><span class="line">        node.removeAttribute(propName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // Set next attributes.</span><br><span class="line">    Object.keys(nextProps).forEach(propName =&gt; &#123;</span><br><span class="line">      if (propName !== &apos;children&apos;) &#123;</span><br><span class="line">        node.setAttribute(propName, nextProps[propName]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接着，主机组件需要更新它们的children，和复杂组件不同的是，他们可能包含不止一个child，在下面这个简单的例子中，<br>我们使用内部实例数组并遍历它，是更新还是替换内部实例依赖于接收到的<code>type</code>是否与他们先前的<code>type</code>一致，真正的reconciler<br>也会也需要元素的<code>key</code>来进行插入还是删除，但是我们省略相关的实现。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line"></span><br><span class="line">    //这是React元素的数组</span><br><span class="line">    var prevChildren = prevProps.children || [];</span><br><span class="line">    if (!Array.isArray(prevChildren)) &#123;</span><br><span class="line">      prevChildren = [prevChildren];</span><br><span class="line">    &#125;</span><br><span class="line">    var nextChildren = nextProps.children || [];</span><br><span class="line">    if (!Array.isArray(nextChildren)) &#123;</span><br><span class="line">      nextChildren = [nextChildren];</span><br><span class="line">    &#125;</span><br><span class="line">    //这是内部实例的数组</span><br><span class="line">    var prevRenderedChildren = this.renderedChildren;</span><br><span class="line">    var nextRenderedChildren = [];</span><br><span class="line"></span><br><span class="line">    //当我们遍历children时，我们要添加对这个数组的一些操作</span><br><span class="line">    var operationQueue = [];</span><br><span class="line"></span><br><span class="line">    //注意：下面的部分非常简单，他不会处理重新排序，它的存在只是为了说明整体流程，但不具体</span><br><span class="line">    for (var i = 0; i &lt; nextChildren.length; i++) &#123;</span><br><span class="line">      // Try to get an existing internal instance for this child</span><br><span class="line">      var prevChild = prevRenderedChildren[i];</span><br><span class="line"></span><br><span class="line">      // If there is no internal instance under this index,</span><br><span class="line">      // a child has been appended to the end. Create a new</span><br><span class="line">      // internal instance, mount it, and use its node.</span><br><span class="line">      if (!prevChild) &#123;</span><br><span class="line">        var nextChild = instantiateComponent(nextChildren[i]);</span><br><span class="line">        var node = nextChild.mount();</span><br><span class="line"></span><br><span class="line">        // Record that we need to append a node</span><br><span class="line">        operationQueue.push(&#123;type: &apos;ADD&apos;, node&#125;);</span><br><span class="line">        nextRenderedChildren.push(nextChild);</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // We can only update the instance if its element&apos;s type matches.</span><br><span class="line">      // For example, &lt;Button size=&quot;small&quot; /&gt; can be updated to</span><br><span class="line">      // &lt;Button size=&quot;large&quot; /&gt; but not to an &lt;App /&gt;.</span><br><span class="line">      var canUpdate = prevChildren[i].type === nextChildren[i].type;</span><br><span class="line"></span><br><span class="line">      // If we can&apos;t update an existing instance, we have to unmount it</span><br><span class="line">      // and mount a new one instead of it.</span><br><span class="line">      if (!canUpdate) &#123;</span><br><span class="line">        var prevNode = prevChild.node;</span><br><span class="line">        prevChild.unmount();</span><br><span class="line"></span><br><span class="line">        var nextChild = instantiateComponent(nextChildren[i]);</span><br><span class="line">        var nextNode = nextChild.mount();</span><br><span class="line"></span><br><span class="line">        // Record that we need to swap the nodes</span><br><span class="line">        operationQueue.push(&#123;type: &apos;REPLACE&apos;, prevNode, nextNode&#125;);</span><br><span class="line">        nextRenderedChildren.push(nextChild);</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // If we can update an existing internal instance,</span><br><span class="line">      // just let it receive the next element and handle its own update.</span><br><span class="line">      prevChild.receive(nextChildren[i]);</span><br><span class="line">      nextRenderedChildren.push(prevChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Finally, unmount any children that don&apos;t exist:</span><br><span class="line">    for (var j = nextChildren.length; j &lt; prevChildren.length; j++) &#123;</span><br><span class="line">     var prevChild = prevRenderedChildren[j];</span><br><span class="line">     var node = prevChild.node;</span><br><span class="line">     prevChild.unmount();</span><br><span class="line"></span><br><span class="line">     // Record that we need to remove the node</span><br><span class="line">     operationQueue.push(&#123;type: &apos;REMOVE&apos;, node&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Point the list of rendered children to the updated version.</span><br><span class="line">    this.renderedChildren = nextRenderedChildren;</span><br><span class="line"></span><br><span class="line">    // ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后一步，我们执行DOM操作，真实的reconciler是很复杂的因为它还得处理移动:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Process the operation queue.</span><br><span class="line">  while (operationQueue.length &gt; 0) &#123;</span><br><span class="line">    var operation = operationQueue.shift();</span><br><span class="line">    switch (operation.type) &#123;</span><br><span class="line">    case &apos;ADD&apos;:</span><br><span class="line">      this.node.appendChild(operation.node);</span><br><span class="line">      break;</span><br><span class="line">    case &apos;REPLACE&apos;:</span><br><span class="line">      this.node.replaceChild(operation.nextNode, operation.prevNode);</span><br><span class="line">      break;</span><br><span class="line">    case &apos;REMOVE&apos;:</span><br><span class="line">      this.node.removeChild(operation.node);</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主机组件更新也是这样。</p>
</blockquote>
<h3 id="顶级更新"><a href="#顶级更新" class="headerlink" title="顶级更新"></a>顶级更新</h3><blockquote>
<p>现在<code>CompositeComponent</code>和<code>DOMComponent</code>实现了<code>receive(nextElement)</code>方法，当元素类型同最后一次相同时，<br>我们可以改变顶层<code>mountTree()</code>来使用它:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function mountTree(element, containerNode) &#123;</span><br><span class="line">  // Check for an existing tree</span><br><span class="line">  if (containerNode.firstChild) &#123;</span><br><span class="line">    var prevNode = containerNode.firstChild;</span><br><span class="line">    var prevRootComponent = prevNode._internalInstance;</span><br><span class="line">    var prevElement = prevRootComponent.currentElement;</span><br><span class="line"></span><br><span class="line">    // If we can, reuse the existing root component</span><br><span class="line">    if (prevElement.type === element.type) &#123;</span><br><span class="line">      prevRootComponent.receive(element);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Otherwise, unmount the existing tree</span><br><span class="line">    unmountTree(containerNode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在调用<code>mountTree()</code>两次非破坏性的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var rootEl = document.getElementById(&apos;root&apos;);</span><br><span class="line"></span><br><span class="line">mountTree(&lt;App /&gt;, rootEl);</span><br><span class="line">// Reuses the existing DOM:</span><br><span class="line">mountTree(&lt;App /&gt;, rootEl);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是React内部工作的基本原理。</p>
</blockquote>
<h3 id="What-We-Left-Out"><a href="#What-We-Left-Out" class="headerlink" title="What We Left Out"></a>What We Left Out</h3><blockquote>
<p>这篇文章和真实的代码库进行了一个简单的比较，这儿有几个我们没有解决的问题：</p>
<ul>
<li>组件可以返回null，reconciler(协调器)可以处理数组中的”空插槽(empty slots)”并渲染出去。</li>
<li>协调器会从元素中读取<code>key</code>,并且用它建立内部实例和数组中元素之间的关系，在真实的React实现中，大量的复杂性和它有关。</li>
<li>除了复杂的以及主机的内部实例，还有一些类对应空元素和文本组件。可以通过null代表文本节点和数组的空插槽。</li>
<li>renders(渲染器)使用注入来传递主机内部类给reconciler(协调器)，比如，React DOM告诉协调器使用ReactDOMComponent作为主机内部实例来实现.</li>
<li>更新子机列表的逻辑被提取到一个叫ReactMultiChild 的一个mixin,它被用与ReactDOM和React Native的内部实例类的实现。</li>
<li>协调器也实现了在复杂组件中对<code>setState()</code>的支持，在事件处理中，大量的更新会成批的放入单个更新。</li>
<li>协调器会小心处理附加及分离到复杂组件和主机节点的refs</li>
<li>生命周期的钩子，会在DOM准备好之后调用，像<code>componentDidMount()</code>,<code>componentDidUpdate()</code>,获取’回调队列’并批处理执行。</li>
<li>React将当前的更新的信息放到一个叫<code>transaction</code>的内部对象中，<code>transactions</code>用于追踪挂起的生命周期钩子队列。当前DOM的<br>内部警告以及其余”global”会给到一个特定的更新，<code>transactions</code>用来确保React更新后清空一切，例如，<code>transactions</code>提供<br>React DOM恢复输入选择后的更新。</li>
</ul>
</blockquote>
<h3 id="Jumping-into-the-Code"><a href="#Jumping-into-the-Code" class="headerlink" title="Jumping into the Code"></a>Jumping into the Code</h3><blockquote>
<ul>
<li><code>ReactMount</code>is where the code like mountTree() and unmountTree() from this tutorial lives,它负责装载和卸载顶级组件<br><code>ReactNativeMount</code>是ReactNative的模拟。</li>
<li>本教程中<code>ReactDOMComponent</code>和<code>DOMComponent</code>是同等的，它实现了ReactDOM渲染器的主机组件类。<code>ReactNativeBaseComponent</code>是<br>React Native的模拟。</li>
<li><code>ReactCompositeComponent</code>和<code>CompositeComponent</code>是同等的，它处理调用用户自定义组建以及维持state。</li>
<li><code>instantiateReactComponent</code>包含了一个开关用来选择一个正确的内部实例类用来构造一个元素。在此教程中和<code>instantiateComponent()</code>是同等的。</li>
<li><code>ReactReconciler</code>是<code>mountComponent</code>和<code>receiveComponent</code>以及<code>unmountComponent</code>方法的包装。它在内部实例上调用底层的实现。当然它也<br>包含所有内部实例实现的共享代码。</li>
<li><code>ReactChildReconciler</code>实现了通过元素的<code>key</code>,<code>mounting</code>，<code>updating</code>,<code>unmounting</code>children的逻辑。</li>
<li><code>ReactMultiChild</code>实现了渲染器对操作队列的处理。child的插入，移动，删除。</li>
<li><code>mount()</code>,<code>receive()</code>,<code>unmount</code>因为一些遗留原因在React代码库中，实际上被称为<code>mountComponent()</code>,<code>receiveComponent</code>,<br><code>unmountComponent()</code></li>
<li>内部实例的属性以下划线开头，比如,_currentElement,在代码库中自始至终它们被认为是只读的。</li>
</ul>
</blockquote>
<h3 id="Future-Directions-未来方向"><a href="#Future-Directions-未来方向" class="headerlink" title="Future Directions(未来方向)"></a>Future Directions(未来方向)</h3><blockquote>
<p>stack reconciler具有的局限性，如同步，不能中断工作或chunks的拆分。在新的<code>Fiber reconciler</code>中有一个完全不同的结构，在未来我们打算使用<br>它代替现有的reconciler，但是目前还很遥远。</p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/12/react/implemention_notes/" data-id="ciw58i9wz002auko0cjc95lkj" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-react/reconciler_algorithm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/10/react/reconciler_algorithm/" class="article-date">
  <time datetime="2016-11-10T12:33:34.111Z" itemprop="datePublished">2016-11-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React/">React</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/10/react/reconciler_algorithm/">React Reconciler Algorithm</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Reconciliation-协调器"><a href="#Reconciliation-协调器" class="headerlink" title="Reconciliation(协调器)"></a>Reconciliation(协调器)</h3><blockquote>
<p>React提供了一个声明式的API，所以你不用担心在每次更新时到底发生了什么变化，这使得写代码变得简单了许多<br>但是React是如何实现的对我们来说是透明的不明显的。这篇文章阐述了React的’diffing’算法所做的选择，因此<br>组件的更新是可预见的并且是高性能的。</p>
</blockquote>
<h3 id="Motivation-动机"><a href="#Motivation-动机" class="headerlink" title="Motivation(动机)"></a>Motivation(动机)</h3><blockquote>
<p>当你使用React时，你可以认为在一个单一的时间点render()函数创建了一个React元素的树，当下一个props或state<br>更新时，render()函数将会得到一个新的不同的React元素的树，React需要解决如何高效的更新UI以匹配最新的树。<br>一些通用方案有性能问题，时间复杂度会为(O(n3))如果在React使用这些通用方案的话，100个元素将会进行一百万次<br>的比较,话费太昂贵了，替代方案是，React实现了一种基于以下两种假设的时间复杂度为O(n)的算法:</p>
<ol>
<li>两种不同类型的元素将会产出不同的树。</li>
<li>开发人员可以暗示在render时维持一个稳定的key属性。<br>在实践中，这些假设在实际使用的情况下都有效。</li>
</ol>
</blockquote>
<h3 id="The-Diffing-Algorithm-Diff算法"><a href="#The-Diffing-Algorithm-Diff算法" class="headerlink" title="The Diffing Algorithm(Diff算法)"></a>The Diffing Algorithm(Diff算法)</h3><blockquote>
<p>当比较两个树时，React首先会比较两者的根元素，该行为取决于根元素的类型。<br><strong>不同类型的元素</strong><br>每当根元素有不同类型时，React将会销毁该树并且重新构建新的树，从<code>&lt;a&gt;</code>到<code>&lt;img&gt;</code>,<code>&lt;Article&gt;</code>到<code>Coment</code>,<br>从<code>&lt;Button&gt;</code>到<code>&lt;div&gt;</code>都会进行全新的重新构建过程。当拆卸一个树时，旧的DOM节点会被销毁，组件实例收到<code>componentWillUnmount()</code><br>当构建新树的时候，新的DOM节点将会被插入到DOM中，组件实例会收到<code>componentWillMount()</code>接着会<code>componentDidMount()</code><br>任何和旧树相关的状态都会丢失.任何在root节点之下的组件以及他们的state都会被销毁，比如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Counter /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;span&gt;</span><br><span class="line">  &lt;Counter /&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这将会销毁<code>&lt;Counter&gt;</code>并重新镶嵌一个新的<code>&lt;Counter&gt;</code>.</p>
</blockquote>
<h3 id="相同类型的DOM元素"><a href="#相同类型的DOM元素" class="headerlink" title="相同类型的DOM元素"></a>相同类型的DOM元素</h3><blockquote>
<p>当比较两个相同类型的DOM元素时，React会查看两个组件的属性，保持相同的DOM节点，只会更新改变的属性，例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;before&quot; title=&quot;stuff&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;div className=&quot;after&quot; title=&quot;stuff&quot; /&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当比较这两个DOM元素时，React知道只修改基础DOM节点的类名。当更新<code>style</code>时，React同样知道只改变的变化了的属性<br>例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&#123;&#123;color: &apos;red&apos;, fontWeight: &apos;bold&apos;&#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;div style=&#123;&#123;color: &apos;green&apos;, fontWeight: &apos;bold&apos;&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当在两个元素之间转换时，React知道仅修改<code>color</code>样式。不会去修改<code>fontWeight</code>样式。处理完DOM节点之后，React会递归操作<br>子节点。</p>
</blockquote>
<h3 id="相同类型的组件节点"><a href="#相同类型的组件节点" class="headerlink" title="相同类型的组件节点"></a>相同类型的组件节点</h3><blockquote>
<p>当一个组件更新时，该实例保持不变，所以在render时state是被维护的，React修改基础组件实例的属性，以匹配新的元素，然后调用<br>基础组件实例的<code>componentWillReceiveProps()</code>和<code>componentWillUpdate()</code>。<br>接下来，<code>render()</code>方法被调用，然后diff算法(diff algorithm)递归上次的结果和最新的结果.</p>
</blockquote>
<h3 id="子组件的递归"><a href="#子组件的递归" class="headerlink" title="子组件的递归"></a>子组件的递归</h3><blockquote>
<p>默认情况下，当递归一个DOM节点的子节点时，React在同一时间仅仅是迭代子组件们的列表并且每当有差异的时候会生成一个突变。<br>例如:当在子组件的最后添加一个新的元素时，这两个树的之间的转变，工作的很好。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;third&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>React将匹配两个<code>&lt;li&gt;first&lt;/li&gt;</code>树，匹配<code>&lt;li&gt;second&lt;/li&gt;</code>树，然后去插入<code>&lt;li&gt;third&lt;/li&gt;</code>树。<br>如果你天真的实现，当插入在最开始的位置，那么会有很糟糕的性能问题。比如，以下的这两课树之间的转换很差：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;Connecticut&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>React将会改变每一个子节点而不是实现它，它可以保持<code>&lt;li&gt;Duke&lt;/li&gt;</code>和<code>&lt;li&gt;Villanova&lt;/li&gt;</code>的子节点的完整性，<br>这种低效性是一个问题.</p>
</blockquote>
<h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><blockquote>
<p>为了解决这一个问题，React支持了一个key的属性，当子组件有key属性时，React使用这个key，来匹配原始树的子节点与<br>随后的树中的子节点，通过添加key使树的转换更加高效。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li key=&quot;2014&quot;&gt;Connecticut&lt;/li&gt;</span><br><span class="line">  &lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在React知道持有’2014’的key是新的节点，而持有<code>2015</code>和<code>2016</code>的节点仅仅移动就可以了，在实践中，发现一个key并不是<br>很难，你将要陈列的元素也许已经有一个唯一的id了，所以这个key值来源于你的data：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当不是这种场景时，你可以添加一个key或生成一个key，这个key只需要和他相邻的节点不同就可以了，不需要全局唯一。<br>作为最后的手段，你可以传递数组的下标作为key，如果列表不需要排序这工作的很好，但是重新排序会很慢。</p>
</blockquote>
<h3 id="Tradeoffs-权衡"><a href="#Tradeoffs-权衡" class="headerlink" title="Tradeoffs(权衡)"></a>Tradeoffs(权衡)</h3><blockquote>
<p>记住reconciliation算法的实现细节很重要，React可以在每一个动作下重新render整个App，最终结果相同，我们会定期的改善<br>使常见的场景更加快速。<br>在最近的实现中，你可以表达一个事实，一个子组件已经从它的兄弟节点中移除了，但是你不能告诉它被移到哪里了。算法会重新<br>render整个子组件们。<br>因为React依赖于启发式算法，如果不能满足它背后的假设，性能会受影响。</p>
<ol>
<li>该算法不会视图去匹配不同类型节点的子树，如果你发现两个类型的组件的输出很相似，你可以让他们变为相同的类型，在实践中<br>我们还没发现这会成为一个问题。</li>
<li>keys应该是稳定的，可预测的，以及唯一的，不稳定的key（比如:Math.random()）将会引起，组件实例和DOM节点不必要的重新创建，<br>从而导致性能退化和状态丢失.</li>
</ol>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/10/react/reconciler_algorithm/" data-id="ciw58i9y70034uko0a38tjg6w" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-react/codebase_overview" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/09/react/codebase_overview/" class="article-date">
  <time datetime="2016-11-09T12:15:59.585Z" itemprop="datePublished">2016-11-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React/">React</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/09/react/codebase_overview/">React代码库概述</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="代码库概述"><a href="#代码库概述" class="headerlink" title="代码库概述"></a>代码库概述</h2><blockquote>
<p>这一节主要是给我们一个React代码库的概述，他的一些规范以及实现，如果你想对React有所贡献的话<br>这个指南将会使你更加舒服的更改。我们不一定推荐在React应用程序的任何这些惯例，有些惯例由于一些<br>历时原因而存在但是后期也许会更改.</p>
</blockquote>
<h3 id="自定义模块系统-Custom-Module-System"><a href="#自定义模块系统-Custom-Module-System" class="headerlink" title="自定义模块系统(Custom Module System)"></a>自定义模块系统(Custom Module System)</h3><blockquote>
<p>在Facebook，内部的我们使用的是一个名叫’Haste’的自定义模块，他和commonjs和类似并且也使用<code>require()</code><br>但是有一些重要的不同而正是这些使外部的贡献者很困惑。在Commonjs中，当你导入一个模块时，你需要明确指定<br>它的相对路径：   </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Importing from the same folder:</span><br><span class="line">var setInnerHTML = require(&apos;./setInnerHTML&apos;);</span><br><span class="line"></span><br><span class="line">// Importing from a different folder:</span><br><span class="line">var setInnerHTML = require(&apos;../utils/setInnerHTML&apos;);</span><br><span class="line"></span><br><span class="line">// Importing from a deeply nested folder:</span><br><span class="line">var setInnerHTML = require(&apos;../client/utils/setInnerHTML&apos;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然而，在Haste中所有的文件名都是全局唯一的，在React代码库中，你可以按照文件名导入其他的任何模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var setInnerHTML = require(&apos;setInnerHTML&apos;);</span><br></pre></td></tr></table></figure></p>
<p>Haste最初是用来开发大型app的比如像Facebook，很容易将文件移动到不同的目录并且无需担心他们的相对路径<br>在任何编辑器的模糊查询会让你得到正确的位置，而这归功于全局唯一的文件名.<br>React是从Facebook的代码库中提取出来的，所以使用Haste是历时原因，在将来，我们有可能会移植Commonjs或ES6<br>的模块化方式同社区更好的对齐，但是这需要Facebook内部基础架构做出很大改变，所以也不是一朝一夕就能完成的.<br><strong>如果你记得一下这些规则，Haste会对你更有意义：</strong></p>
<ol>
<li>在React原生代码库中的所有文件名都是全局唯一的，这也是为什么有些文件名繁长啰嗦的原因。</li>
<li>当你添加了一个新文件时，确认你包含了许可证的标头，你可以从别的地方复制一份，一个许可证标头的格式一般是：   </li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Copyright 2013-present, Facebook, Inc.</span><br><span class="line"> * All rights reserved.</span><br><span class="line"> *</span><br><span class="line"> * This source code is licensed under the BSD-style license found in the</span><br><span class="line"> * LICENSE file in the root directory of this source tree. An additional grant</span><br><span class="line"> * of patent rights can be found in the PATENTS file in the same directory.</span><br><span class="line"> *</span><br><span class="line"> * @providesModule setInnerHTML</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<blockquote>
<p>记得更改@providesModule后面的名字，匹配你新创建的文件.<br>当我们为npm编译React时，一个script脚本将会复制所有的模块到一个单一的没有子目录的目录，命名为lib<br>预制所有的<code>require()</code>路径为<code>./.</code>,在这种方式下，Node，Browserify，Webpack，等工具将会理解React的生成输出而无需<br>关心Haste。<br><strong>如果你正在github上读react源码，并且想跳到某一个文件，请按’t’</strong><br>这是Github用来在当前仓库模糊搜索文件的快捷方式，输入你要搜索的文件名，它将会显示匹配的文件。</p>
</blockquote>
<h3 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h3><blockquote>
<p>React几乎没有外部依赖，通常情况下，<code>require()</code>指向的是React自己代码库的文件，但是也有几个比较少见的例外：<br>如果你发现<code>require()</code>的文件在React仓库中没有所对应的文件，那么你可以在<a href="https://github.com/facebook/fbjs" target="_blank" rel="external">fbjs</a><br>这个仓库中找到,例如<code>require(&#39;warning&#39;)</code>将会从fbjs的<code>warning</code>模块中解析。<br>fbjs仓库存在是因为React共享了一些工具类比如<a href="https://github.com/facebook/relay" target="_blank" rel="external">Relay</a>,我们保持了他们之间的同步关系.<br>我们不依赖Node生态系统的等效小模块，因为我们希望Facebook的工程师在有需要的时候都可以做出改变,所有fbjs内部的实用程序不会被<br>作为开放的API，它们的意图仅仅是用来服务于Facebook的项目，比如React。</p>
</blockquote>
<h3 id="顶级文件夹"><a href="#顶级文件夹" class="headerlink" title="顶级文件夹"></a>顶级文件夹</h3><blockquote>
<p>在克隆React仓库之后，你会发现有几个顶级文件夹在里面:</p>
<ol>
<li><code>src</code>是React的源码，如果你要修改相关的代码，<code>src</code>文件夹将是你花费时间最长的.</li>
<li><code>docs</code>是React文档网站，当你修改了API时，请确认修改了相应的markdown文件</li>
<li><code>examples</code>包含了一些生成不同配置的React例子</li>
<li><code>packages</code>包含了元数据用来对应React仓库中的所有包（比如package.json），尽管如此，他们的源码还是位于<code>src</code>文件夹中。</li>
<li><code>build</code>是React的生成输出，他不会再React仓库中出现，但是他会出现在你运行生成命令之后.<br>还有一些顶级目录，但是他们仅仅是工具类，很有可能你在贡献代码时，根本不会碰到他们。</li>
</ol>
</blockquote>
<h3 id="协同定位测试"><a href="#协同定位测试" class="headerlink" title="协同定位测试"></a>协同定位测试</h3><blockquote>
<p>我们没有一个顶级的测试目录，我们将测试用例放在一个<code>__tests__</code>的目录下代替。<br>例如，<code>setInnerHTML.js</code>的测试用例放在<code>__tests__/setInnerHTML-test.js</code>.</p>
</blockquote>
<h3 id="共享的代码"><a href="#共享的代码" class="headerlink" title="共享的代码"></a>共享的代码</h3><blockquote>
<p>尽管Haste允许我们导入React仓库的任何模块，我们得遵循一个规范用来避免循环依赖以及其他的怪异现象，按照规范，一个文件仅能导入相同<br>目录以及子目录下的文件。<br>例如：在<code>src/renders/dom/client</code>下的文件可以导入相同目录以及该目录的所有子目录中的文件.但是他们不能导入<code>src/renders/dom/server</code><br>下的文件因为它不是<code>src/renders/dom/client</code>的子目录。<br>此规则的例外情况，有时候，我们需要在不同组的模块里共享一些公共的函数，在这种情况下，我们提升共享模块到这些目录最近的父目录里的一个叫<br>shared的模块里.<br>比如：<code>src/renders/dom/client</code>和<code>src/renders/dom/server</code>共享一段代码，那么这段代码应该位于<code>src/renders/shared</code>.<br>按照同样的逻辑，如果<code>src/renders/dom/client</code>和<code>src/renders/native</code>共享一个工具类，那么此工具类应该位于<code>src/renders/shared</code>.<br>这个规范虽然不是强制的，但是当我们遇到<code>pull request</code>时会检查.</p>
</blockquote>
<h3 id="警告及不变量"><a href="#警告及不变量" class="headerlink" title="警告及不变量"></a>警告及不变量</h3><blockquote>
<p>React代码库用<code>warning</code>模块来展示警告：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var warning = require(&apos;warning&apos;);</span><br><span class="line"></span><br><span class="line">warning(</span><br><span class="line">  2 + 2 === 4,</span><br><span class="line">  &apos;Math is not working today.&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>当<code>warning</code>条件为false时，警告将会显示</strong><br>这种思考方式是条件响应的是正常情况而不是异常情况。<br>这是一种避免垃圾邮件以及控制台重复输出的好主意。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var warning = require(&apos;warning&apos;);</span><br><span class="line">var didWarnAboutMath = false;</span><br><span class="line">if(!didWarnAboutMath) &#123;</span><br><span class="line">  warning(</span><br><span class="line">    2 + 2 === 4,</span><br><span class="line">    &apos;Math is not working today&apos;</span><br><span class="line">  );</span><br><span class="line">  didWarnAbout = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>警告仅会在开发环境下可用，在正是环境下，他们会被完全削去，如果你需要禁止一些代码路径的执行<br>使用<code>invariant</code>模块代替.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var invariant = require(&apos;invariant&apos;);</span><br><span class="line">invariant(</span><br><span class="line">  2 + 2 === 4,</span><br><span class="line">  &apos;You shall not pass!&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当<code>invariant</code>为false的时候，将引发<br>“invariant”是这种情况一直为true的一种说明方式，你可以把它当做断言。<br>保持开发和正是环境行为一直是很重要的，所以<code>invariant</code>可以在正式及开发环境引发，警告信息会自动<br>的被替换为错误码以避免字节数大小的影响。</p>
</blockquote>
<h3 id="开发和正式"><a href="#开发和正式" class="headerlink" title="开发和正式"></a>开发和正式</h3><blockquote>
<p>你可以在代码库使用<code>__DEV__</code>伪全局变量，守卫只针对开发环境的代码块。<br>在编译阶段中，在CommonJS构建时，它将会被转变为<code>process.env.NODE_ENV !== &#39;production&#39;</code>。<br>在独立构建时，在未压缩的构建时它变为true，在压缩构建的时候它将会被剔除。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (__DEV__) &#123;</span><br><span class="line">  // This code will only run in development.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JSDoc"><a href="#JSDoc" class="headerlink" title="JSDoc"></a>JSDoc</h3><blockquote>
<p>一些内部的以及公共的方法以<a href="http://usejsdoc.org/" target="_blank" rel="external">JSDoc形式的注释</a>注释：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Updates this component by updating the text content.</span><br><span class="line">  *</span><br><span class="line">  * @param &#123;ReactText&#125; nextText The next text content</span><br><span class="line">  * @param &#123;ReactReconcileTransaction&#125; transaction</span><br><span class="line">  * @internal</span><br><span class="line">  */</span><br><span class="line">receiveComponent: function(nextText, transaction) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们试图让存在的注释更新但我们不是强制的，我们没有在新写的代码中使用JSDoc,替代方案是<br>我们使用Flow强制类型.</p>
</blockquote>
<h3 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h3><blockquote>
<p>我们最近引入<a href="https://flowtype.org/" target="_blank" rel="external">Flow</a>来检查代码库，在许可证标头用<code>@flow</code>标记的文件<br>将会执行类型检查.<br>我们接受给已存在代码添加<code>@flow</code>的pull请求，Flow注释长这样:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReactRef.detachRefs = function(</span><br><span class="line">  instance: ReactInstance,</span><br><span class="line">  element: ReactElement | string | number | null | false,</span><br><span class="line">): void &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只要有可能，新提交的代码应该使用Flow注解，你可以在本地运行<code>npm run flow</code>来检查你的代码.</p>
</blockquote>
<h3 id="类和Mixins"><a href="#类和Mixins" class="headerlink" title="类和Mixins"></a>类和Mixins</h3><blockquote>
<p>React原来是用ES5编写的，我们已经用<a href="http://babeljs.io/" target="_blank" rel="external">babel</a>支持了ES6的特性。包含classes,<br>但是，许多React代码还是用ES5写的。<br>尤其是，你可能经常看到以下的形式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Constructor</span><br><span class="line">function ReactDOMComponent(element) &#123;</span><br><span class="line">  this._currentElement = element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Methods</span><br><span class="line">ReactDOMComponent.Mixin = &#123;</span><br><span class="line">  mountComponent: function() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Put methods on the prototype</span><br><span class="line">Object.assign(</span><br><span class="line">  ReactDOMComponent.prototype,</span><br><span class="line">  ReactDOMComponent.Mixin</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">module.exports = ReactDOMComponent;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码的<code>Mixin</code>和React的<code>mixins</code>特性并无关系，这只是一种分组在一个对象的方法的方式，这些方法有可能<br>在后期获取并附加到别的class上，我们使用了这种方式尽管我们尝试在新代码中避免使用。同等的ES6代码长得是<br>这个样子的：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class ReactDOMComponent &#123;</span><br><span class="line">  constructor(element) &#123;</span><br><span class="line">    this._currentElement = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mountComponent() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = ReactDOMComponent;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有时候我们会转换ES5代码为ES6代码，然而这对我们来说不是非常重要，因为有一个正在进行的努力，React协调器的实现带有<br>少量的面向对象的方法，我们完全不需要使用class。</p>
</blockquote>
<h3 id="动态注入"><a href="#动态注入" class="headerlink" title="动态注入"></a>动态注入</h3><blockquote>
<p>React在有些模块中使用了动态注入，虽然它易于理解，但是不幸的是，它阻碍了我对代码的理解，它存在的主要原因是React起初<br>只支持DOM作为target,React Native是已React的分支开始的，我们不得不添加动态注入让React Native覆盖一些行为.你有可能<br>会看见一些模块声明动态依赖是以下面的这种方式:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Dynamically injected</span><br><span class="line">var textComponentClass = null;</span><br><span class="line"></span><br><span class="line">// Relies on dynamically injected value</span><br><span class="line">function createInstanceForText(text) &#123;</span><br><span class="line">  return new textComponentClass(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ReactHostComponent = &#123;</span><br><span class="line">  createInstanceForText,</span><br><span class="line"></span><br><span class="line">  // Provides an opportunity for dynamic injection</span><br><span class="line">  injection: &#123;</span><br><span class="line">    injectTextComponentClass: function(componentClass) &#123;</span><br><span class="line">      textComponentClass = componentClass;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = ReactHostComponent;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>injection</code>区域无论如何不会被特殊的处理，但是按照惯例，它意味着此模块在运行的时候想注入一些模块，在React DOM中，<br><a href="https://github.com/facebook/react/blob/4f345e021a6bd9105f09f3aee6d8762eaa9db3ec/src/renderers/dom/shared/ReactDefaultInjection.js" target="_blank" rel="external">ReactDefaultInjection</a>注入了DOM细节的实现<code>ReactHostComponent.injection.injectTextComponentClass(ReactDOMTextComponent);</code>,<br>在React Native中<a href="https://github.com/facebook/react/blob/4f345e021a6bd9105f09f3aee6d8762eaa9db3ec/src/renderers/native/ReactNativeDefaultInjection.js" target="_blank" rel="external">ReactNativeDefaultInjection</a>注入了它自己的实现,在代码库中有多个注射点，在未来，我们打算拜托动态注入的这种机制，在静态构建时串起所有的碎片文件。</p>
</blockquote>
<h3 id="大量的包"><a href="#大量的包" class="headerlink" title="大量的包"></a>大量的包</h3><blockquote>
<p>React是一个<a href="http://danluu.com/monorepo/" target="_blank" rel="external">monorepo</a>,它的仓库包含了大量的独立的包，所以他们的改变可以协调在一起，并且文档以及问题是在一起的，<br><code>npm</code>元数据比如<code>package.json</code>文件在位于顶层目录<code>package</code>文件夹下的，但是，这里面几乎没有代码。<br>比如，<a href="https://github.com/facebook/react/blob/87724bd87506325fcaf2648c70fc1f43411a87be/packages/react/react.js" target="_blank" rel="external">packages/react/react.js</a>再导出<code>src/isomorphic/React.js</code>,真实的npm入口，其余的包大多数重复相同的规则，所有重要的代码都位于<code>src</code>文件夹下。<br>虽然在源码结构里代码都是独立的，确切的包的边界还是和npm的以及browser构建略有不同。</p>
</blockquote>
<h3 id="React-Core"><a href="#React-Core" class="headerlink" title="React Core"></a>React Core</h3><blockquote>
<p>React的核心包含了所有顶级的<a href="https://facebook.github.io/react/docs/react-api.html" target="_blank" rel="external">React API</a>,比如：</p>
<ul>
<li>React.createElement()</li>
<li>React.createClass()</li>
<li>React.Component</li>
<li>React.Children</li>
<li>React.PropTypes<br>React核心仅仅包含了定义模块的API，不包括reconciliation算法以及具体平台的代码，它被用于React DOM以及React Native，React的核心代码位于<code>src/isomorphic</code><br>它可以在npm的react包中获取，相应的browser中是react.js,它导出的全局变量是React。</li>
</ul>
</blockquote>
<h3 id="Renders"><a href="#Renders" class="headerlink" title="Renders"></a>Renders</h3><blockquote>
<p>React最初是唯DOM创建的但是后来改编用来适应原生平台React Native，在这里介绍React内部构建的概念。<br><strong>Renders管理一个React树如何变成底层平台的调用</strong>，Renders位于<code>src/renders</code>文件夹下:</p>
<ul>
<li>React DOM Render渲染React组建为DOM。它实现了顶层的ReactDOM API并且可以在npm的react-dom中获取到，它可以<br>被用来做单独的browser bundle(react-dom.js)它导出了ReactDOM全局变量。</li>
<li>React Native Render渲染React组建为原生视图，它是在React Native内部使用的，通过react-native-render npm包<br>将来可能会将它copy一份到React Native的仓库中，这样React Native可以在自己的工作空间中修改React了。</li>
<li>React Test Render渲染React组建为JSON树，它使用了Jest的快照测试功能，在npm的react-test-render包中获取。<br>剩下的官方支持的render是react-art,为了避免我们在修改react时意外的破坏它，我们要在<code>src/renders/art</code>目录中运行测试运例<br>虽然如此，它的github仓库still acts as the source of truth。<br>虽然在技术上，我们可能会自定义render，目前不会官方支持，自定义render没有一个公共的稳定的协议，这就是我们将它放在单独的<br>一个地方的原因。<br><strong>注意：</strong>在技术上,native render是很薄的一层用来让React和React Native相互作用，真正具体管理原生视图的代码是在React<br>Native仓库中</li>
</ul>
</blockquote>
<h3 id="Reconciler-协调器"><a href="#Reconciler-协调器" class="headerlink" title="Reconciler(协调器)"></a>Reconciler(协调器)</h3><blockquote>
<p>甚至完全不同的render比如React DOM和React Native需要共享相同的逻辑，尤其是<a href="https://facebook.github.io/react/docs/reconciliation.html" target="_blank" rel="external">reconciliation</a>算法应尽可能相似，声明的渲染，<br>自定义组建，状态，生命周期方法，以及refs始终跨平台工作。<br>为了解决这一问题，不同的renders共享一些代码。我们称这些代码为<code>reconciler</code>(协调器),当一个更新（setUpdate()）被安排时，<br>reconciler（协调器）调用了组建中的render(),mounts,updates,或者unmount.<br>reconciler（协调器）没有被单独的分离出来，因为它们目前没有公共的API，它们会被renders使用，比如React DOM，React Native。</p>
</blockquote>
<h3 id="Reconciler栈"><a href="#Reconciler栈" class="headerlink" title="Reconciler栈"></a>Reconciler栈</h3><blockquote>
<p>‘stack’reconciler供应于所有的线上React代码，它位于<code>src/renducers/shared/stack/reconciler</code>文件夹中，用于React和React Native<br>它是以面向对象的形式书写的(object-oriented)并且维护一个内部实例的树，（该树对应于所有React组件）。这个内部实例存在于自定义组件<br>及平台组件，这个内部实例对应用户来说不能直接访问，并且他们的树不会被暴露出来。当一个组件mounts，updates，unmounts，这个stack &gt;reconciler将会调用内部实例的一个方法，这些方法是<code>mountComponent(element)</code>,<code>receiveComponent(element)</code>,和<code>unmountElement(element)</code>.<br><strong>Host Components</strong><br>平台特定组件，比如<code>&lt;div&gt;</code>,’View’，例如，React Dom通知stack reconciler使用DOM组件的<code>ReactDOMComponent</code>去处理mounting,updates,<br>以及unmounting。不论什么平台，<code>&lt;div&gt;</code>,<code>&lt;View&gt;</code>处理管理多子组件的方式是类似的，为了方便，reconciler提供了一个叫<code>ReactMultiChild</code><br>来供DOM和Native render使用。<br><strong>复杂的组件</strong><br>用户定义的组件和所有的renders表现形式是一样的，这就是为什么reconciler提供了一个叫<code>ReactCompositeComponent</code>的公共实现，<br>它使用于各平台的renderer。复杂的组件也要实现<code>mounting</code>,<code>updating</code>,<code>unmounting</code>,但是不同于平台组件，<code>ReactCompositeComponent</code><br>需要依赖于不同的代码，这就是为什么在用户定义的类中有<code>render()</code>,<code>componentDidMount()</code>方法的原因。<br>在更新期间中，<code>ReactCompositeComponent</code>检查<code>render()</code>在最后一次输出的<code>type</code>,’key’是否不同，如果<code>type</code>和<code>key</code>有改变，他会委派<br>去更新已存在的内部实例，另外，它会卸载老的子组件，并镶嵌新的，这个会在<a href="https://facebook.github.io/react/docs/reconciliation.html" target="_blank" rel="external">Reconciliation algorithm(协调器算法)</a>中描述。<br><strong>Recursion（递归）</strong><br>在一次更新中，stack reconciler会一直深入复杂的组件，运行他们的render()方法，并决定是否更新以及替换他们的唯一的组件。通过平台组件<br>(div View)执行平台代码，Host组件可能会有很多子组件，通常会递归处理。stack reconciler经常处理同步的单个处理组件树，当个别的树处理完成了<br>stack reconciler不会停止，所以当更新很深以及CPU有限时它不是最优的。</p>
</blockquote>
<h3 id="Fiber-reconciler"><a href="#Fiber-reconciler" class="headerlink" title="Fiber reconciler"></a>Fiber reconciler</h3><blockquote>
<p>‘fiber’ reconciler是一个新的努力用来解决stack reconciler里的继承问题以及长期存在的一些问题。<br>它是完全重写的reconciler，<a href="https://github.com/facebook/react/pulls?utf8=%E2%9C%93&amp;q=is%3Apr%20is%3Aopen%20fiber" target="_blank" rel="external">目前正在被开发</a>。<br>它的主要目标是:</p>
<ul>
<li>在chunks中可拆分中断的能力。</li>
<li>在进程中确定优先次序、重订、复用的工作能力。</li>
<li>Ability to yield back and forth between parents and children to support layout in React。</li>
<li>render()返回多标签的能力</li>
<li>更好的支持错误边界<br>你可以阅读来更好的理解<a href="https://github.com/acdlite/react-fiber-architecture" target="_blank" rel="external">React Fiber Architecture</a>,此刻，它处于试验阶段。<br>它的代码位于<code>src/renders/shared/fiber</code></li>
</ul>
</blockquote>
<h3 id="Event-System"><a href="#Event-System" class="headerlink" title="Event System"></a>Event System</h3><blockquote>
<p>React实现了一个综合型的事件系统，在ReactDOM和React Native都可工作，它的代码位于<code>src/renders/shared/shared/event</code>.</p>
</blockquote>
<h3 id="Add-ons-附加组件"><a href="#Add-ons-附加组件" class="headerlink" title="Add-ons(附加组件)"></a>Add-ons(附加组件)</h3><blockquote>
<p>每个React的附件组件在npm都以react-addons-的前缀的包单独的分离出来。它们的代码位于<code>src/addons</code>.<br>另外，我们提供了一个单独的叫<code>react-with-addons.js</code>的输出文件，它包含了React代码以及所有的addons暴露出的对象。</p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/09/react/codebase_overview/" data-id="ciw58i9wp0023uko0b8fslkcb" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-react/react_redux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/01/react/react_redux/" class="article-date">
  <time datetime="2016-10-31T16:06:46.319Z" itemprop="datePublished">2016-11-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React-Redux/">React Redux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/01/react/react_redux/">redux</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="为什么要用react-redux"><a href="#为什么要用react-redux" class="headerlink" title="为什么要用react-redux?"></a>为什么要用react-redux?</h3><blockquote>
<p>在单页应用中,服务器的相应,UI状态,缓存数据,被选中的标签,是否加载动画效果等等这些都可以理解为state,当应用变得庞<br>大复杂时传统的javascript代码处理这些状态 ,只会让维护变得更加困难,而用redux的原因就是将应用程序中的state的变化变得<br>可预测</p>
</blockquote>
<h3 id="redux的三大原则"><a href="#redux的三大原则" class="headerlink" title="redux的三大原则"></a>redux的三大原则</h3><ol>
<li>单一的store,整个应用的state存放在一个object tree中,并且这个store是唯一的</li>
<li><p>state是只读的,唯一改变state的方法就是触发action,action就是一个描述你要干什么的js对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var actionName = &#123;</span><br><span class="line">	type: typeName,//必须为type表示你将要执行什么动作,</span><br><span class="line">	desc: &apos;&apos;	//自己定义，你将希望通过这个动作告知其余组建通过这个动作发生的事</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用reducer修改state,reducer是一个纯函数,它接收的参数为先前的state和将要执行的action,并返回新的state</p>
</li>
</ol>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Action是把数据从应用中传到store的有效载荷,它是store数据的唯一来源,一般通过<code>store.dispatch( {type: &#39;xx&#39;, desc: &#39;xx&#39;} )</code>将action传到store</p>
<h3 id="ActionCreator"><a href="#ActionCreator" class="headerlink" title="ActionCreator"></a>ActionCreator</h3><p>ActionCreator就是生成action对象的函数,返回一个action对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function addTodo(text) &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		type: &apos;ADD_TODO&apos;,</span><br><span class="line">		text</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>在store里调用action创建函数: <code>store.dispatch(addTodo(&#39;learn redux&#39;))</code><br>在React组建中如何调用呢？需要用到react-redux中提供的connect()(ComponentName)将dispatch函数注入到组建的props中然后通过<br><code>this.props.dispatch(addTodo(text))</code>调用<br>bindActionCreators()待定</p>
<hr>
<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>Action只是描述了事件发生了而已,但是并没有指明应用如何更新state,而更新state正是reducer做的事情。    </p>
<h6 id="设计state的结构"><a href="#设计state的结构" class="headerlink" title="设计state的结构"></a>设计state的结构</h6><p>在redux应用中,所有的state都被保存在一个单一对象中。reducer就是一个函数,接收旧的state和action,返回新的state.<br>不要在reducer里做以下操作:    </p>
<ol>
<li>修改传入参数</li>
<li>执行有副作用的操作,如API请求和路由跳转  </li>
<li>调用非纯函数,如Date.norw()或Math.random(),每个reducer只负责全局state中它负责的一部分。每个reducer的state<br>参数都不同，分别对应它管理的那部分的state数据,combineReducers()所做的只是生成一个函数,这个函数来调用你的一系列<br>reducer，每个reducer根据它们的key来筛选出state中的一部分数据并处理,然后这个生成函数将所有reducer的结果合并成一个大的对象。</li>
</ol>
<hr>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>action用来描述发生了什么，使用reducer根据action更新state，Store就是将它们联系到一起的对象,Store的职责:    </p>
<ol>
<li>维持应用程序的state    </li>
<li>提供getState()获取state    </li>
<li>提供dispatch(action)方法更新state    </li>
<li>提供subscribe(listener)注册监听器<br>Redux应用中只有唯一的一个store,通过redux的createStore(reducers, initialState)创建store<br>createStore()的第二个参数用来设置初始状态    </li>
</ol>
<hr>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>严格的单项数据流是redux架构的设计核心,Redux应用中数据的生命周期遵循下面4个步骤:   </p>
<ol>
<li>调用store.dispatch(action),你可以在任何地方调用store.dispatch(action),组件中，定时器中    </li>
<li>Redux store调用传入的reducer函数.Store会把连个参数传入reducer：当前的state树和action。<br>reducer是一个纯函数。它仅仅用于计算下一个state。它应该是完全可以预测的：多次传入相同的输入<br>必须产生相同的输出。它不应该做有副作用的操作，如API调用或路由跳转。这些应该在dispatch action前发生    </li>
<li>根reducer应该用combineReducers()把多个reducer输出合并成单一的一个state树<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function todos(state=[], action) &#123;</span><br><span class="line">	//...</span><br><span class="line">	return nextState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function visibleTodoFilter(state=&apos;SHOW_ALL&apos;, action) &#123;</span><br><span class="line">	//...</span><br><span class="line">	return nextState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const reducers = combineReducers(&#123;</span><br><span class="line">	todos,</span><br><span class="line">	visibleTodoFilter</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><br><br>当你触发action后，combineReducers返回的reducers会负责调用两个reducer,然后把两个结果集合并成一个state树:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return&#123;</span><br><span class="line">	todos: nextTodos,</span><br><span class="line">	visibleTodoFilter: nextVisibleTodoFilter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Redux Store保存了根reducer返回的完整的state树，这个新的树就是应用的下一个state!所有调用store.subscribe(listener)<br>的监听器都将被调用;监听器里可以调用<code>store.getState()</code>获取当前的state<br>现在，可以应用新的state来更新UI，在组建中的componentDidMount生命周期中调用<code>this.setState()</code>来更新        </li>
</ol>
<hr>
<h3 id="搭配React"><a href="#搭配React" class="headerlink" title="搭配React"></a>搭配React</h3><p>Redux和React之间没有关系。Redux支持React、Angular、jQuery甚至纯javascript    </p>
<ol>
<li>Redux的React绑定包含了容器组件和展示组件相分离的开发思想，明智的做法就是只在最顶层组件（路由操作）<br>里使用Redux。其余内部组件仅仅是展示性的，所有数据都通过props传入    </li>
<li>连接到Redux，<strong>通过react-redux提供的connect()方法将包装好的组件连接到redux</strong>。     <pre><code>**任何一个从connect()包装好的组件都可以得到一个dispatch方法作为组件的props，以及得到全局state中所需的内容**
connect()的唯一参数是selector。此方法可以从Redux store中接收到全局state，然后返回组件中需要的props
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		return(</span><br><span class="line">			//...</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//基于全局state，哪些是我们想要注入props的</span><br><span class="line">//https://github.com/reactjs/reselect这个待研究，用这个注入效果更好?</span><br><span class="line">function select(state) &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		xxx: state.xxx</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//包装component</span><br><span class="line">export default connect(select)(App);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="异步Action"><a href="#异步Action" class="headerlink" title="异步Action"></a>异步Action</h3><pre><code>前面所述的是同步action,每当dispatch action时,state会理解被更新。那么Redux如何操作异步数据流?
</code></pre><h6 id="Action-1"><a href="#Action-1" class="headerlink" title="Action"></a>Action</h6><p>当调用异步API时,有两个非常关键的时刻:发起请求的时刻,和接收响应的时刻（也可能是超时）。<br><br><br>这两个时刻都可以更改应用的state;为此，你需要dispatch普通的同步action。一般情况下，每个api请求都至少需要dispatch三个不同的action:    </p>
<ul>
<li><p><strong>一个通知reducer请求开始的action</strong><br>对于这种action,reducer可能会切换一下state中的isFeching标记.以此来告诉UI来显示进度条.    </p>
</li>
<li><p><strong>一个通知reducer请求成功结束的action</strong><br>对于这种action,reducer可能会把接收到的新数据合并到state中,并重置isFetching。UI则会隐藏进度条，并显示接收到的数据    </p>
</li>
<li><p><strong>一个通知reducer请求失败的action</strong><br>对于这种action，reducer可能会重置isFetching.或者，有些reducer会保存这些失败信息,并在UI显示出来.    </p>
</li>
</ul>
<hr>
<h3 id="异步Action-Creator"><a href="#异步Action-Creator" class="headerlink" title="异步Action Creator"></a>异步Action Creator</h3><blockquote>
<p>如何将不同的action creator和网络请求结合起来?使用Redux Thunk这个中间件,通过使用中间件，action creator除了返回action对象<br>外还乐意返回函数,当action creator返回函数时，这个函数会被Redux Thunk middleware执行。这个函数并不需要保持纯净；它可以带有<br>副作用，包括异步执行、API请求。这个函数还可以dispatch action    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//thunk action creator</span><br><span class="line">//使用方式和同步cation一样	dispatch(fetchPosts(&apos;xxx&apos;))</span><br><span class="line">export function fetchPosts(xxx) &#123;</span><br><span class="line">	//Thunk middleware知道如可处理函数</span><br><span class="line">	//这里把dispatch方法通过参数的形式传给函数，以此来让它自己也能dispatch action</span><br><span class="line"></span><br><span class="line">	return function(dispatch) &#123;</span><br><span class="line"></span><br><span class="line">		dispatch(action);</span><br><span class="line"></span><br><span class="line">		//执行api请求使用isomorphic-fetch库替代XMLHttpRequest</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br>        我们如何在dispatch机制中引入Redux Thunk middleware？使用appluMiddleware(),<strong>thunk的一个优点就是它的结果可以再次被dispatch</strong>    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//**index.js代码**</span><br><span class="line">import thunkMiddleware from &apos;react-thunk&apos;;</span><br><span class="line">import createLogger from &apos;redux-logger&apos;;</span><br><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;</span><br><span class="line"></span><br><span class="line">const createStoreWithMiddleware = applyMiddleware(</span><br><span class="line">	thunkMiddleware,	//允许我们dispatch()函数</span><br><span class="line">	createLogger</span><br><span class="line">)(createStore);</span><br><span class="line"></span><br><span class="line">const reducers = combineReducers(&#123;</span><br><span class="line">	//拆分的单个reducer函数</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const store = createStoreWithMiddleware(reducers);</span><br></pre></td></tr></table></figure>
<p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//**action.js代码**</span><br><span class="line">export function fetchPosts(xxx) &#123;</span><br><span class="line">	return (dispatch) =&gt; &#123;</span><br><span class="line">		//...</span><br><span class="line">		dispatch(action)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function fetchPostsIfNeeder(xxx) &#123;</span><br><span class="line">	//可接收getState()方法</span><br><span class="line">	return (fetch, getState) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<hr>
<h3 id="异步数据流"><a href="#异步数据流" class="headerlink" title="异步数据流"></a>异步数据流</h3><p>如果不使用middleware的话,Redux的store只支持同步数据流。而这也是createStore()所默认提供的创建方式，可以使用applyMiddleware()<br>来增强createStore(),使用redux-thunk这样支持异步的middleware都包装了store的dispatch()方法,以此让你dispatch一些除了action以外<br>的内容。<strong>当niddleware链中的最后一个middleware dispatch action 时，这个action必须是一个普通对象。</strong>    </p>
<h3 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h3><p><strong>middleware是指可以被嵌入在框架接收请求道产生相应过程之中的代码，它提供的是位于action被发起之后，到达reducer之前的扩展点</strong><br>可以利用Redux middleware来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。        </p>
<p><strong>使用Redux的一个益处就是它让state的变化过程变得可预知和透明。每当一个action发起后，新的state就会被计算保<br>存下来。state不能自身修改，只能由特定的action引起变化</strong>    </p>
<hr>
<h3 id="减少样板代码"><a href="#减少样板代码" class="headerlink" title="减少样板代码"></a>减少样板代码</h3><ul>
<li><p>Action的type用常量，可以将所有type放在一个文件中，然后引入    </p>
</li>
<li><p>Action Creators创建生成action的函数    </p>
</li>
<li><p>生产Action Creators写简单的action creator函数，尤其是数量巨大的时候，代码不易于维护，可以写一个用于生成action creator的函数：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function makeActionCreator(type, ...argNames) &#123;</span><br><span class="line">	return function(...args) &#123;</span><br><span class="line">		let action = &#123; type &#125;;</span><br><span class="line">		argNames.forEach(arg, index) &#123;</span><br><span class="line">			action[argNames[index]] = args[index];</span><br><span class="line">		&#125;</span><br><span class="line">		return action;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const ADD_TODO = &apos;ADD_TODO&apos;;</span><br><span class="line">const EDIT_TODO = &apos;EDIT_TODO&apos;</span><br><span class="line">const REMOVE_TODO = &apos;REMOVE_TODO&apos;;</span><br><span class="line"></span><br><span class="line">export const addTodo = makeActionCreator(ADD_TODO, &apos;todo&apos;);</span><br><span class="line">export const editTodo = makeActionCreator(EDIT_TODO, &apos;id&apos;, &apos;todo&apos;);</span><br><span class="line">export const removeTodo = makeActionCreator(REMOVE_TODO, &apos;id&apos;);</span><br></pre></td></tr></table></figure>
<p><strong>redux-actions可以帮助生成action creator，这个待研究</strong>    </p>
<ul>
<li>异步Action Creators<br>中间件让你在每个action对象分发出去之前，注入一个自定义的逻辑来解释你的action对象。异步action是中间件<br>最常见用例。如果没有中间件，dispatch只能接收一个普通对象。因此我们必须在components里面进行AJAX调用：    </li>
</ul>
<p><code>actions.js</code><br><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">export function loadPostsSuccess(userId, response) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;LOAD_POSTS_SUCCESS&apos;,</span><br><span class="line">    userId,</span><br><span class="line">    response</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function loadPostsFailure(userId, error) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;LOAD_POSTS_FAILURE&apos;,</span><br><span class="line">    userId,</span><br><span class="line">    error</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function loadPostsRequest(userId) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;LOAD_POSTS_REQUEST&apos;,</span><br><span class="line">    userId</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>component.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; loadPostsRequest, loadPostsSuccess, loadPostsFailure &#125; from &apos;./actionCreators&apos;;</span><br><span class="line"></span><br><span class="line">class Posts extends Component &#123;</span><br><span class="line">  loadData(userId) &#123;</span><br><span class="line">    // 调用 React Redux `connect()` 注入 props ：</span><br><span class="line">    let &#123; dispatch, posts &#125; = this.props;</span><br><span class="line"></span><br><span class="line">    if (posts[userId]) &#123;</span><br><span class="line">      // 这里是被缓存的数据！啥也不做。</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Reducer 可以通过设置 `isFetching` 反应这个 action</span><br><span class="line">    // 因此让我们显示一个 Spinner 控件。</span><br><span class="line">    dispatch(loadPostsRequest(userId));</span><br><span class="line"></span><br><span class="line">    // Reducer 可以通过填写 `users` 反应这些 actions</span><br><span class="line">    fetch(`http://myapi.com/users/$&#123;userId&#125;/posts`).then(</span><br><span class="line">      response =&gt; dispatch(loadPostsSuccess(userId, response)),</span><br><span class="line">      error =&gt; dispatch(loadPostsFailure(userId, error))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.loadData(this.props.userId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    if (nextProps.userId !== this.props.userId) &#123;</span><br><span class="line">      this.loadData(nextProps.userId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.props.isLoading) &#123;</span><br><span class="line">      return &lt;p&gt;Loading...&lt;/p&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let posts = this.props.posts.map(post =&gt;</span><br><span class="line">      &lt;Post post=&#123;post&#125; key=&#123;post.id&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return &lt;div&gt;&#123;posts&#125;&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default connect(state =&gt; (&#123;</span><br><span class="line">  posts: state.posts</span><br><span class="line">&#125;))(Posts);</span><br></pre></td></tr></table></figure></p>
<p><strong><code>redux-thunk</code>中间件可以把action creators写成<code>thunks</code>,也就是返回函数的函数</strong>    </p>
<p>使用react-redux修改上面的代码：   </p>
<p><code>actions.js</code><br><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">export function loadPosts(userId) &#123;</span><br><span class="line">  // 用 thunk 中间件解释：</span><br><span class="line">  return function (dispatch, getState) &#123;</span><br><span class="line">    let &#123; posts &#125; = getState();</span><br><span class="line">    if (posts[userId]) &#123;</span><br><span class="line">      // 这里是数据缓存！啥也不做。</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: &apos;LOAD_POSTS_REQUEST&apos;,</span><br><span class="line">      userId</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 异步分发原味 action</span><br><span class="line">    fetch(`http://myapi.com/users/$&#123;userId&#125;/posts`).then(</span><br><span class="line">      response =&gt; dispatch(&#123;</span><br><span class="line">        type: &apos;LOAD_POSTS_SUCCESS&apos;,</span><br><span class="line">        userId,</span><br><span class="line">        respone</span><br><span class="line">      &#125;),</span><br><span class="line">      error =&gt; dispatch(&#123;</span><br><span class="line">        type: &apos;LOAD_POSTS_FAILURE&apos;,</span><br><span class="line">        userId,</span><br><span class="line">        error</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><code>component.js</code><br><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; loadPosts &#125; from &apos;./actionCreators&apos;;</span><br><span class="line"></span><br><span class="line">class Posts extends Component &#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.props.dispatch(loadPosts(this.props.userId));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    if (nextProps.userId !== this.props.userId) &#123;</span><br><span class="line">      this.props.dispatch(loadPosts(nextProps.userId));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.props.isLoading) &#123;</span><br><span class="line">      return &lt;p&gt;Loading...&lt;/p&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let posts = this.props.posts.map(post =&gt;</span><br><span class="line">      &lt;Post post=&#123;post&#125; key=&#123;post.id&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return &lt;div&gt;&#123;posts&#125;&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default connect(state =&gt; (&#123;</span><br><span class="line">  posts: state.posts</span><br><span class="line">&#125;))(Posts);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<hr>
<h3 id="计算衍生数据"><a href="#计算衍生数据" class="headerlink" title="计算衍生数据"></a>计算衍生数据</h3><p><code>Reselect库</code>可以创建可记忆的可组合的selector函数，Reselect selectors可以高效的计算<br>Redux store里的衍生数据    </p>
<p>不使用<code>reselect</code>当state发生变化，组件更新时，会如果state tree非常大，会带来性能问题        </p>
<ul>
<li><strong>创建可记忆的Selector：</strong><br>只有在我们关注的state发生变化时才重新计算此state，而在其他非相关state的变化不会引起<br>此state重新计算。<br>Reselect提供的<code>creatSelector</code>函数创建可记忆的selector，<code>createSelector</code>接收一个input-selectors<br>数组和一个转换函数作为参数。如果state tree的改变会引起input-selectors值变化，那么selector会调用<br>转换函数，传入input-selectors作为参数，并返回结果，如果input-selectors的值和前一次一样，它将会直接<br>返回前一次计算的数据，而不重新调用转换函数    </li>
</ul>
<p><code>selectors/TodoSelectors.js</code><br><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createSelector &#125; from &apos;reselect&apos;;</span><br><span class="line">import &#123; VisibilityFilters &#125; from &apos;./actions&apos;;</span><br><span class="line"></span><br><span class="line">function selectTodos(todos, filter) &#123;</span><br><span class="line">  switch (filter) &#123;</span><br><span class="line">  case VisibilityFilters.SHOW_ALL:</span><br><span class="line">    return todos;</span><br><span class="line">  case VisibilityFilters.SHOW_COMPLETED:</span><br><span class="line">    return todos.filter(todo =&gt; todo.completed);</span><br><span class="line">  case VisibilityFilters.SHOW_ACTIVE:</span><br><span class="line">    return todos.filter(todo =&gt; !todo.completed);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const visibilityFilterSelector = (state) =&gt; state.visibilityFilter;</span><br><span class="line">const todosSelector = (state) =&gt; state.todos;</span><br><span class="line"></span><br><span class="line">export const visibleTodosSelector = createSelector(</span><br><span class="line">  [visibilityFilterSelector, todosSelector],</span><br><span class="line">  (visibilityFilter, todos) =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      visibleTodos: selectTodos(todos, visibilityFilter),</span><br><span class="line">      visibilityFilter</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p><br><br>        在上例中，visibilityFilterSelector 和 todosSelector 是 input-selector。因为他们并不转换数据，<br>        所以被创建成普通的非记忆的 selector 函数。但是，visibleTodosSelector 是一个可记忆的 selector。<br>        他接收 visibilityFilterSelector 和 todosSelector 为 input-selector，还有一个转换函数来计算过<br>        滤的 todos 列表。</p>
<ul>
<li><strong>组合 Selector</strong><pre><code>可记忆的 selector 自身可以作为其它可记忆的 selector 的 input-selector。下面
的 visibleTodosSelector 被当作另一个 selector 的 input-selector，来进一步通过关键字（keyword）过滤 todos。    
</code></pre></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const keywordSelector = (state) =&gt; state.keyword</span><br><span class="line"></span><br><span class="line">const keywordFilterSelector = createSelector(</span><br><span class="line">  [ visibleTodosSelector, keywordSelector ],</span><br><span class="line">  (visibleTodos, keyword) =&gt; visibleTodos.filter(</span><br><span class="line">    todo =&gt; todo.indexOf(keyword) &gt; -1</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><strong>连接 Selector 和 Redux Store</strong><br>在react-redux中，使用 connect 来连接可记忆的 selector 和 Redux store    </li>
</ul>
<p><code>containers/App.js</code><br><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;</span><br><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;</span><br><span class="line">import &#123; addTodo, completeTodo, setVisibilityFilter &#125; from &apos;../actions&apos;</span><br><span class="line">import AddTodo from &apos;../components/AddTodo&apos;</span><br><span class="line">import TodoList from &apos;../components/TodoList&apos;</span><br><span class="line">import Footer from &apos;../components/Footer&apos;</span><br><span class="line">import &#123; visibleTodosSelector &#125; from &apos;../selectors/todoSelectors&apos;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    // Injected by connect() call:</span><br><span class="line">    const &#123; dispatch, visibleTodos, visibilityFilter &#125; = this.props</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;AddTodo</span><br><span class="line">          onAddClick=&#123;text =&gt;</span><br><span class="line">            dispatch(addTodo(text))</span><br><span class="line">          &#125; /&gt;</span><br><span class="line">        &lt;TodoList</span><br><span class="line">          todos=&#123;this.props.visibleTodos&#125;</span><br><span class="line">          onTodoClick=&#123;index =&gt;</span><br><span class="line">            dispatch(completeTodo(index))</span><br><span class="line">          &#125; /&gt;</span><br><span class="line">        &lt;Footer</span><br><span class="line">          filter=&#123;visibilityFilter&#125;</span><br><span class="line">          onFilterChange=&#123;nextFilter =&gt;</span><br><span class="line">            dispatch(setVisibilityFilter(nextFilter))</span><br><span class="line">          &#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">App.propTypes = &#123;</span><br><span class="line">  visibleTodos: PropTypes.arrayOf(PropTypes.shape(&#123;</span><br><span class="line">    text: PropTypes.string.isRequired,</span><br><span class="line">    completed: PropTypes.bool.isRequired</span><br><span class="line">  &#125;)),</span><br><span class="line">  visibilityFilter: PropTypes.oneOf([</span><br><span class="line">    &apos;SHOW_ALL&apos;,</span><br><span class="line">    &apos;SHOW_COMPLETED&apos;,</span><br><span class="line">    &apos;SHOW_ACTIVE&apos;</span><br><span class="line">  ]).isRequired</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 把 selector 传递给连接的组件</span><br><span class="line">export default connect(visibleTodosSelector)(App)</span><br></pre></td></tr></table></figure></p>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/01/react/react_redux/" data-id="ciw58i9yb0039uko0vzzvnepw" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-react/explain_bindActionCreators" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/01/react/explain_bindActionCreators/" class="article-date">
  <time datetime="2016-10-31T16:06:46.315Z" itemprop="datePublished">2016-11-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React-Redux/">React Redux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/01/react/explain_bindActionCreators/">bindActionCreators</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="bindActionCreators-actionCreators-dispatch"><a href="#bindActionCreators-actionCreators-dispatch" class="headerlink" title="bindActionCreators(actionCreators, dispatch)"></a>bindActionCreators(actionCreators, dispatch)</h1><p><strong>使用场景</strong>   </p>
<p>需要把action creator往下传到一个组件上，却不想让这个组建觉察到Redux的存在，而且不希望把Redux store<br>或dispatch传给它</p>
<p><br><br><strong>参数</strong>    </p>
<ol>
<li><p><code>actionCreators</code>(Fuction Or Object):一个action creator，或者键值是action creators的对象    </p>
</li>
<li><p><code>dispatch</code>(Function):一个dispatch函数，由<code>store</code>实例提供      </p>
</li>
</ol>
<p><strong>返回值</strong>    </p>
<p><em>(Function or Object)</em>:一个与原对象类似的对象，只不过这个对象中的每个函数值都可以直接dispatch<br>action。如果传入的是一个函数，返回的也是一个函数。</p>
<p><br></p>
<p><strong>示例</strong>    </p>
<p><code>TodoActionCreationCreator.js</code>    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export function addTodo(text) &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		type: &apos;ADD_TODO&apos;,</span><br><span class="line">		text</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function removeTodo(id) &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		type: &apos;REMOVE_TODO&apos;,</span><br><span class="line">		id</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><code>SomeComponent.js</code>   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123; bindActionCreators &#125; from &apos;redux&apos;;</span><br><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line">import * as TodoActionCreators from &apos;./TodoActionCreators&apos;;</span><br><span class="line"></span><br><span class="line">class TodoListContainer extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">	componentDidMount() &#123;</span><br><span class="line">		//由react-redux注入</span><br><span class="line">		let &#123; dispatch &#125; = this.props;</span><br><span class="line"></span><br><span class="line">		let action = TodoActionCreators.addTodo(&apos;Use Redux&apos;);</span><br><span class="line">		dispatch(action);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	render() &#123;</span><br><span class="line"></span><br><span class="line">		let &#123; todos, dispatch &#125; = this.props;</span><br><span class="line"></span><br><span class="line">		//应用bindActionCreator</span><br><span class="line">		let boundActionCreators = bindActionCreators(TodoActionCreators, dispatch);</span><br><span class="line"></span><br><span class="line">		return (</span><br><span class="line">			&lt;TodoList todos=&#123;todos&#125;</span><br><span class="line">				&#123;...boundActionCreators&#125;</span><br><span class="line">			/&gt;</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">		//一种可以替换bindActionCreators的做法是直接把dispatch函数和action creators当作props传递给组件</span><br><span class="line">		//return &lt;TodoList todos=&#123;todos&#125; dispatch=&#123;dispatch&#125; /&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default connect(state =&gt; (&#123;todos: state.todos&#125;))(TodoListContainer);</span><br></pre></td></tr></table></figure>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/01/react/explain_bindActionCreators/" data-id="ciw58i9wx0028uko0rtkwygoo" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</section>
        
          
            <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Canvas/">Canvas</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Electron/">Electron</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Http/">Http</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Redux/">React Redux</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Webpack/">Webpack</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/development-tools/">development tools</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget recents">
      <ul>
        
          <li>
            <a href="/2016/11/30/vue/components/">组件</a>
          </li>
        
          <li>
            <a href="/2016/11/30/vue/form_input/">form input绑定</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/event_handle/">事件处理</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/list_render/">Vue的列表渲染</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/conditional_render/">条件渲染</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">我的文章</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">23</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
</aside>
          
        
      </div>
      <!--<div id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a></br>
      &copy; 2016 zhuxin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</div>-->
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">我的文章</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>