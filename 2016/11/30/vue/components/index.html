<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>组件 | zhuxin_blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="什么是组件
组件是Vue的最强大的特性之一，他们帮你扩展基于Html元素来封装可复用的代码，在较高的水平上组件是自定义元素，是Vue编译器的附加行为。在一些场景中，它们可能在一些原生的Html元素以is属性的扩展形式出现。

使用组件注册
通过以下方式创建vue实例：

1234new Vue(&amp;#123;  el: &amp;apos;#some-element&amp;apos;,  // options&amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="组件">
<meta property="og:url" content="http://yoursite.com/2016/11/30/vue/components/index.html">
<meta property="og:site_name" content="zhuxin_blog">
<meta property="og:description" content="什么是组件
组件是Vue的最强大的特性之一，他们帮你扩展基于Html元素来封装可复用的代码，在较高的水平上组件是自定义元素，是Vue编译器的附加行为。在一些场景中，它们可能在一些原生的Html元素以is属性的扩展形式出现。

使用组件注册
通过以下方式创建vue实例：

1234new Vue(&amp;#123;  el: &amp;apos;#some-element&amp;apos;,  // options&amp;#">
<meta property="og:updated_time" content="2016-11-30T13:00:55.677Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="组件">
<meta name="twitter:description" content="什么是组件
组件是Vue的最强大的特性之一，他们帮你扩展基于Html元素来封装可复用的代码，在较高的水平上组件是自定义元素，是Vue编译器的附加行为。在一些场景中，它们可能在一些原生的Html元素以is属性的扩展形式出现。

使用组件注册
通过以下方式创建vue实例：

1234new Vue(&amp;#123;  el: &amp;apos;#some-element&amp;apos;,  // options&amp;#">
  
    <link rel="alternative" href="/atom.xml" title="zhuxin_blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  
  <link href="//fonts.googleapis.com/css?family=Inconsolata:400,700|Open+Sans:700,400" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <div id="header-title">
        <h1 id="logo-wrap">
          <a href="/" id="logo">
          
              <span id="subtitle">每天进步一点点</span>
          
          </a>
        </h1>
      </div>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">我的文章</a>
        
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</div>
      <div class="outer">
        <section id="main"><article id="post-vue/components" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/30/vue/components/" class="article-date">
  <time datetime="2016-11-29T17:48:53.501Z" itemprop="datePublished">2016-11-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      组件
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h3><blockquote>
<p>组件是Vue的最强大的特性之一，他们帮你扩展基于Html元素来封装可复用的代码，在较高的水平上<br>组件是自定义元素，是Vue编译器的附加行为。在一些场景中，它们可能在一些原生的Html元素以<code>is</code><br>属性的扩展形式出现。</p>
</blockquote>
<h3 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h3><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><blockquote>
<p>通过以下方式创建vue实例：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#some-element&apos;,</span><br><span class="line">  // options</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以使用<code>Vue.component(tagName, options)</code>注册一个全局组件,例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  // options</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：Vue不强制用W3c的规则命名（都小写，使用-连字符），但是遵守这个规则是好的做法。<br>只要一注册，组件可以在一个vue实例中作为一个自定义元素使用，<code>&lt;my-component&gt;&lt;/my-component&gt;</code>.<br>在初始化vue实例时请确保组件已经注册了。比如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;my-component&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// register</span><br><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">// create a root instance</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将会渲染为：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;div&gt;A custom component!&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><blockquote>
<p>没有必要将每一个组件都注册为全局的，你可以在一个实例或组件内部通过<code>components</code>属性局部的<br>使用组件：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Child = &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  components: &#123;</span><br><span class="line">    // &lt;my-component&gt; will only be available in parent&apos;s template</span><br><span class="line">    &apos;my-component&apos;: Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="DOM模板解析警告"><a href="#DOM模板解析警告" class="headerlink" title="DOM模板解析警告"></a>DOM模板解析警告</h3><blockquote>
<p>当使用DOM作为你的模板时（比如：使用<code>el</code>选项来装载具有内容的元素），你会受到HTML固有的工作<br>限制，因为只有浏览器解析并初始化完成后Vue才会得到模板的内容，最值得注意的是，一些元素比如<br><code>&lt;ul&gt;</code>,<code>&lt;ol&gt;</code>,<code>&lt;table&gt;</code>,<code>&lt;select&gt;</code>对他们里面的元素有严格地限制，比如<code>&lt;option&gt;</code>只能出现<br>在特定元素的里面。当在这些具有严格限制的HTNL元素中使用模板时，该如何做呢：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;my-row&gt;...&lt;/my-row&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>自定义的组件<code>&lt;my-row&gt;</code>将会被提升作为合法的内容，但是最终的输出结果会引起错误，使用<code>is</code><br>这个属性作为变通方案：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你使用以下的来源是使用字符串模板，将不会受到以上限制：</p>
<ul>
<li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li>
<li>js行内字符串模板</li>
<li><code>.vue</code>组件<br>因此，尽可能使用字符串模板。</li>
</ul>
</blockquote>
<h3 id="data必须是一个函数"><a href="#data必须是一个函数" class="headerlink" title="data必须是一个函数"></a><code>data</code>必须是一个函数</h3><blockquote>
<p>模板的<code>data</code>必须是一个函数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;hello&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Vue将会暂停并在控制台打印错误，告诉你<code>data</code>必须是一个函数或者是组件实例，这个规则的存在<br>很容易理解：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example-2&quot;&gt;</span><br><span class="line">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</span><br><span class="line">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</span><br><span class="line">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var data = &#123; counter: 0 &#125;</span><br><span class="line">Vue.component(&apos;simple-counter&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;button v-on:click=&quot;counter += 1&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&apos;,</span><br><span class="line">  // data is technically a function, so Vue won&apos;t</span><br><span class="line">  // complain, but we return the same object</span><br><span class="line">  // reference for each component instance</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#example-2&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于这三个组件实例共享同一个<code>data</code>,当增加其中一个值时所有的值都会增加，通过返回一个全新<br>的对象来修复这个问题:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在每一个组件都有自己的内部状态。</p>
</blockquote>
<h3 id="组件的组合"><a href="#组件的组合" class="headerlink" title="组件的组合"></a>组件的组合</h3><blockquote>
<p>组件可以在一起使用，最常见的就是父子关系：组件A可能在自己的模板中使用组件B。他们必然会<br>互相通信：父组件会给子组件传递<code>props</code>,子组件会给父组件报告在子组件内发生了什么。然而通<br>过一个明确定义的接口来保持父子组件的解耦也是非常重要的。这可以确保每个组件在相对隔离的情<br>况下也可书写与推理，因此书写和维护变得更简单了。在Vue.js中，父子组件的通信可以概括为props<br>向下传递，事件向上传递。父组件通过<strong>props</strong>给子组件传递data，子组件通过事件给父组件传递<br>消息。</p>
</blockquote>
<h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><h4 id="通过props传递打他"><a href="#通过props传递打他" class="headerlink" title="通过props传递打他"></a>通过props传递打他</h4><blockquote>
<p>每一个组件实例都有自己的作用域。这意味着你不能在子组件的模板中直接使用父组件的data，父<br>组件的data可以通过props传递到子组件。<strong>props</strong>是一个自定义的属性用来传递父组件的信息，<br>子组件通过<code>props</code>选项来明确的声明它期望获得的数据：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;child&apos;, &#123;</span><br><span class="line">  // declare the props</span><br><span class="line">  props: [&apos;message&apos;],</span><br><span class="line">  // just like data, the prop can be used inside templates</span><br><span class="line">  // and is also made available in the vm as this.message</span><br><span class="line">  template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//我们可以这样传递一个简单的字符串给child组件</span><br><span class="line">&lt;child message=&quot;hello!&quot;&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure>
<h4 id="驼峰式vs-分界符"><a href="#驼峰式vs-分界符" class="headerlink" title="驼峰式vs-分界符"></a>驼峰式vs<code>-</code>分界符</h4><blockquote>
<p>HTML的属性是不区分大小写的，所以当使用非字符串模板时，驼峰式属性吗需要用他们的’-‘分界符<br>命名规则来替换：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;child&apos;, &#123;</span><br><span class="line">  // camelCase in JavaScript</span><br><span class="line">  props: [&apos;myMessage&apos;],</span><br><span class="line">  template: &apos;&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;!-- kebab-case in HTML --&gt;</span><br><span class="line">&lt;child my-message=&quot;hello!&quot;&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果使用的是字符串模板，没有这个限制。</p>
</blockquote>
<h4 id="动态的Props"><a href="#动态的Props" class="headerlink" title="动态的Props"></a>动态的Props</h4><blockquote>
<p>和属性绑定普通表达式类似，在父组件中可以使用<code>v-bind</code>动态的绑定data和props，不论父组件的<br>data是否改变，它始终会传递给子组件：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;input v-model=&quot;parentMsg&quot;&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;child v-bind:my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//使用v-bind的简写形式：</span><br><span class="line">&lt;child :my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Literal-文本-VS-Dynamic"><a href="#Literal-文本-VS-Dynamic" class="headerlink" title="Literal(文本) VS Dynamic"></a>Literal(文本) VS Dynamic</h4><blockquote>
<p>一个常犯的错误就是使用文本语法传递一个数字：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- this passes down a plain string &quot;1&quot; --&gt;</span><br><span class="line">&lt;comp some-prop=&quot;1&quot;&gt;&lt;/comp&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然而，由于这是一个文本属性，传递的数字是字符串类型的，如果要传递一个js的number类型，我们<br>需要使用<code>v-bind</code>它会将值预估为js的表达式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- this passes down an actual number --&gt;</span><br><span class="line">&lt;comp v-bind:some-prop=&quot;1&quot;&gt;&lt;/comp&gt;</span><br></pre></td></tr></table></figure>
<h4 id="单项数据流"><a href="#单项数据流" class="headerlink" title="单项数据流"></a>单项数据流</h4><blockquote>
<p>在父子组件中所有的数据都是单向流动的：当父组件的属性改变时，它会流向子组件，但是子组件的<br>变化不会流向父组件。这样可以阻止子组件意外变化而引起父组件状态的突变，这会让你的应用程序<br>很难找到原因。<br>另外，任何时候只要父组件更新了，子组件的所有props都会刷新到最近的值，这意味着你不要尝试<br>改变子组件的prop，如果你做了，Vue会在控制台警告你。<br>通常有两种情况你要改变prop：</p>
<ol>
<li>prop只是用来传递一个初始值，子组件只是想用它做一个局部的对象属性。</li>
<li>prop作为一个原始值传递<br>适当的使用场景是：</li>
<li>定义一个局部data属性，使用prop’s的初始值作为它的值：</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">props: [&apos;initialCounter&apos;],</span><br><span class="line">data: function () &#123;</span><br><span class="line">  return &#123; counter: this.initialCounter &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>定义一个属性的计算，通过prop’s的值计算：</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [&apos;size&apos;],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: function () &#123;</span><br><span class="line">    return this.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意对象和数组是引用传递，所以当传递数组和对象给子组件时，在子组件修改它会影响父组件的<br>状态。</p>
</blockquote>
<h4 id="Prop验证"><a href="#Prop验证" class="headerlink" title="Prop验证"></a>Prop验证</h4><blockquote>
<p>定义一个明确的获得的prop类型是很有用的，如果要求不满足，Vue会报警告，当多人开发时是很<br>有用的：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;example&apos;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    // basic type check (`null` means accept any type)</span><br><span class="line">    propA: Number,</span><br><span class="line">    // multiple possible types</span><br><span class="line">    propB: [String, Number],</span><br><span class="line">    // a required string</span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;,</span><br><span class="line">    // a number with default value</span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 100</span><br><span class="line">    &#125;,</span><br><span class="line">    // object/array defaults should be returned from a</span><br><span class="line">    // factory function</span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      default: function () &#123;</span><br><span class="line">        return &#123; message: &apos;hello&apos; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // custom validator function</span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: function (value) &#123;</span><br><span class="line">        return value &gt; 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>type</code>有以下原始类型：</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Bollean</li>
<li>Function</li>
<li>Object</li>
<li>Array<br>另外，<code>type</code>可以是自定义构造函数的类型，通过<code>instanceof</code>校验。</li>
</ul>
</blockquote>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><blockquote>
<p>子组件如何和父组件通信呢？使用Vue的自定义事件系统。</p>
</blockquote>
<h4 id="使用v-on来定义事件"><a href="#使用v-on来定义事件" class="headerlink" title="使用v-on来定义事件"></a>使用<code>v-on</code>来定义事件</h4><blockquote>
<p>每一个Vue实例都实现了<a href="https://vuejs.org/v2/api/#Instance-Methods-Events" target="_blank" rel="external">事件接口</a>,</p>
<ul>
<li>使用<code>$on(eventName)</code>监听事件</li>
<li>使用<code>$emit(eventName)</code>触发事件<br>注意Vue的事件系统和浏览器的<a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget" target="_blank" rel="external">事件API</a>是分开的。<br>尽管他们工作类似，但是<code>$on</code>和<code>$emit</code>不是<code>addEventListener</code>和<code>dispatchEvent</code>的别名。<br>另外，父组件可以监听子组件使用<code>$on</code>发出的事件：</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;counter-event-example&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;</span><br><span class="line">  &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;button-counter&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&apos;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      counter: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment: function () &#123;</span><br><span class="line">      this.counter += 1</span><br><span class="line">      this.$emit(&apos;increment&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#counter-event-example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    total: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    incrementTotal: function () &#123;</span><br><span class="line">      this.total += 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>绑定原生事件到组件</strong><br>在<code>v-on</code>指令添加后缀<code>.native</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-on:click.native=&quot;doTheThing&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>
<h4 id="form表单组件使用自定义事件"><a href="#form表单组件使用自定义事件" class="headerlink" title="form表单组件使用自定义事件"></a>form表单组件使用自定义事件</h4><blockquote>
<p>使用<code>v-modle</code>来创建自定义表单组件：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;something&quot;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>仅仅是语法糖：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当在组件中使用时：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-input v-bind:value=&quot;something&quot; v-on:input=&quot;something = arguments[0]&quot;&gt;&lt;/custom-input&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>目前组件与<code>v-modle</code>的工作，它必须：</p>
<ul>
<li>接收一个<code>value</code>属性</li>
<li>放射出一个<code>input</code>事件</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;currency-input v-model=&quot;price&quot;&gt;&lt;/currency-input&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.component(&apos;currency-input&apos;, &#123;</span><br><span class="line">  template: &apos;\</span><br><span class="line">    &lt;span&gt;\</span><br><span class="line">      $\</span><br><span class="line">      &lt;input\</span><br><span class="line">        ref=&quot;input&quot;\</span><br><span class="line">        v-bind:value=&quot;value&quot;\</span><br><span class="line">        v-on:input=&quot;updateValue($event.target.value)&quot;\</span><br><span class="line">      &gt;\</span><br><span class="line">    &lt;/span&gt;\</span><br><span class="line">  &apos;,</span><br><span class="line">  props: [&apos;value&apos;],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // Instead of updating the value directly, this</span><br><span class="line">    // method is used to format and place constraints</span><br><span class="line">    // on the input&apos;s value</span><br><span class="line">    updateValue: function (value) &#123;</span><br><span class="line">      var formattedValue = value</span><br><span class="line">        // Remove whitespace on either side</span><br><span class="line">        .trim()</span><br><span class="line">        // Shorten to 2 decimal places</span><br><span class="line">        .slice(0, value.indexOf(&apos;.&apos;) + 3)</span><br><span class="line">      // If the value was not already normalized,</span><br><span class="line">      // manually override it to conform</span><br><span class="line">      if (formattedValue !== value) &#123;</span><br><span class="line">        this.$refs.input.value = formattedValue</span><br><span class="line">      &#125;</span><br><span class="line">      // Emit the number value through the input event</span><br><span class="line">      this.$emit(&apos;input&apos;, Number(formattedValue))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的这个例子很天真，可以参考<a href="https://jsfiddle.net/chrisvfritz/1oqjojjx/?utm_source=website&amp;utm_medium=embed&amp;utm_campaign=1oqjojjx" target="_blank" rel="external">这个</a></p>
</blockquote>
<h3 id="非父子组件通信"><a href="#非父子组件通信" class="headerlink" title="非父子组件通信"></a>非父子组件通信</h3><blockquote>
<p>当两个不是父子关系的组件该如何通信呢？一个简单的场景，你可以创建一个vue空实例作为中央事<br>件汽车：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var bus = new Vue()</span><br><span class="line"></span><br><span class="line">// in component A&apos;s method</span><br><span class="line">bus.$emit(&apos;id-selected&apos;, 1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// in component B&apos;s created hook</span><br><span class="line">bus.$on(&apos;id-selected&apos;, function (id) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在更复杂的场景中，可以采用专门的<a href="https://vuejs.org/v2/guide/state-management.html" target="_blank" rel="external">事件管理模式</a></p>
</blockquote>
<h3 id="内容分发槽"><a href="#内容分发槽" class="headerlink" title="内容分发槽"></a>内容分发槽</h3><blockquote>
<p>当使用组件时，经常想要组合他们：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;app&gt;</span><br><span class="line">  &lt;app-header&gt;&lt;/app-header&gt;</span><br><span class="line">  &lt;app-footer&gt;&lt;/app-footer&gt;</span><br><span class="line">&lt;/app&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意两件事：</p>
<ol>
<li><code>&lt;app&gt;</code>组件不知道在其内部要呈现的内容是什么.</li>
<li><code>&lt;app&gt;</code>组件看起来像是有自己的模板。<br>使用特殊的<code>&lt;slot&gt;</code>元素。</li>
</ol>
</blockquote>
<h3 id="编辑范围"><a href="#编辑范围" class="headerlink" title="编辑范围"></a>编辑范围</h3><blockquote>
<p>想象一个这样的模板：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;child-component&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/child-component&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>message</code>会绑定到父组件的data还是子组件的data么？它会绑定到父组件的data。组件范围的一个<br>规则是：<br>在父模板中的一切都是在父模板范围内编译，在模板就是在子模板范围内编译。<br>一个常见的错误就是尝试在子模板中绑定一个子模板的property/method:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- does NOT work --&gt;</span><br><span class="line">&lt;child-component v-show=&quot;someChildProperty&quot;&gt;&lt;/child-component&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>假设<code>someChildProperty</code>是子组件的prop,上面的例子不能运行，因为父模板不会意识到子组件的<br>状态。如果你需要绑定子范围的指令到一个组件的根节点上，你需要在子组件范围的模板上绑定：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;child-component&apos;, &#123;</span><br><span class="line">  // this does work, because we are in the right scope</span><br><span class="line">  template: &apos;&lt;div v-show=&quot;someChildProperty&quot;&gt;Child&lt;/div&gt;&apos;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      someChildProperty: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="单个插槽"><a href="#单个插槽" class="headerlink" title="单个插槽"></a>单个插槽</h3><blockquote>
<p>父内容将会被抛弃除非子组件模板上至少包含一个<code>&lt;slot&gt;</code>插槽。当只有一个没任何属性的插槽时，<br>全部内容都会被替换。<code>&lt;slot&gt;</code>的原始内容会被作为回退内容，如果持有组件是空的或者没有内容<br>金额插入式回退内容才会显示。有一个<code>&lt;my-component&gt;</code>的组件：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h2&gt;I&apos;m the child title&lt;/h2&gt;</span><br><span class="line">  &lt;slot&gt;</span><br><span class="line">    This will only be displayed if there is no content</span><br><span class="line">    to be distributed.</span><br><span class="line">  &lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当一个父组件使用它时：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;I&apos;m the parent title&lt;/h1&gt;</span><br><span class="line">  &lt;my-component&gt;</span><br><span class="line">    &lt;p&gt;This is some original content&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;This is some more original content&lt;/p&gt;</span><br><span class="line">  &lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>渲染结果是：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;I&apos;m the parent title&lt;/h1&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;I&apos;m the child title&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;This is some original content&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;This is some more original content&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="命名的插槽"><a href="#命名的插槽" class="headerlink" title="命名的插槽"></a>命名的插槽</h3><blockquote>
<p><code>&lt;slot&gt;</code>有一个<code>name</code>属性，用来进一步定义内容如何被分配，你可以有多个不同名字的<code>&lt;slot&gt;</code>,<br>命名的<code>&lt;slot&gt;</code>将会匹配任何有相应的<code>slot</code>属性的元素。如果有没有名字的<code>&lt;slot&gt;</code>,它会匹配<br>任何没有被匹配上的内容，如果没有默认的<code>&lt;slot&gt;</code>,没有匹配上的内容将会被放弃。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>父标记：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;app-layout&gt;</span><br><span class="line">  &lt;h1 slot=&quot;header&quot;&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line">  &lt;p slot=&quot;footer&quot;&gt;Here&apos;s some contact info&lt;/p&gt;</span><br><span class="line">&lt;/app-layout&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>渲染的结果是：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;p&gt;Here&apos;s some contact info&lt;/p&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当设计组件组合时内容分发是一个有用的机制。</p>
</blockquote>
<h3 id="限定作用域的Slot"><a href="#限定作用域的Slot" class="headerlink" title="限定作用域的Slot"></a>限定作用域的Slot</h3><blockquote>
<p>2.1.0新出现的，限定作用域的slot是一种特殊的类型，作为一种可重用的模板用来代替已经渲染了<br>的元素。在子组件中，传递data给一个slot：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;child&quot;&gt;</span><br><span class="line">  &lt;slot text=&quot;hello from child&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在父组件中，<code>&lt;template&gt;</code>元素会持有一个特殊的<code>scope</code>属性来表示它是一个限定作用域的slot<br>模板，作用域的值是一个临时变量来掌控从子组件传递过来的data：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;child&gt;</span><br><span class="line">    &lt;template scope=&quot;props&quot;&gt;</span><br><span class="line">      &lt;span&gt;hello from parent&lt;/span&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它的渲染结果是：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">    &lt;span&gt;hello from parent&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;hello from child&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>列表中如何使用slot呢?</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-awesome-list :items=&quot;items&quot;&gt;</span><br><span class="line">  &lt;!-- scoped slot can be named too --&gt;</span><br><span class="line">  &lt;template slot=&quot;item&quot; scope=&quot;props&quot;&gt;</span><br><span class="line">    &lt;li class=&quot;my-fancy-item&quot;&gt;&#123;&#123; props.text &#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/my-awesome-list&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>list组件模板：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;slot name=&quot;item&quot;</span><br><span class="line">    v-for=&quot;item in items&quot;</span><br><span class="line">    :text=&quot;item.text&quot;&gt;</span><br><span class="line">    &lt;!-- fallback content here --&gt;</span><br><span class="line">  &lt;/slot&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<h3 id="动态的组件"><a href="#动态的组件" class="headerlink" title="动态的组件"></a>动态的组件</h3><blockquote>
<p>通过<code>is</code>属性动态的切换预定了的组件：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    currentView: &apos;home&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    home: &#123; /* ... */ &#125;,</span><br><span class="line">    posts: &#123; /* ... */ &#125;,</span><br><span class="line">    archive: &#123; /* ... */ &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;component v-bind:is=&quot;currentView&quot;&gt;</span><br><span class="line">  &lt;!-- component changes when vm.currentView changes! --&gt;</span><br><span class="line">&lt;/component&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者直接绑定组件对象：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var Home = &#123;</span><br><span class="line">  template: &apos;&lt;p&gt;Welcome home!&lt;/p&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    currentView: Home</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="保持活跃keep-alive"><a href="#保持活跃keep-alive" class="headerlink" title="保持活跃keep-alive"></a>保持活跃<code>keep-alive</code></h4><blockquote>
<p>如果你想在内存中保存切换出去的组件以避免重新渲染，可以使用<code>&lt;keep-alive&gt;</code>元素包装它：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component :is=&quot;currentView&quot;&gt;</span><br><span class="line">    &lt;!-- inactive components will be cached! --&gt;</span><br><span class="line">  &lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<a href="https://vuejs.org/v2/api/#keep-alive" target="_blank" rel="external">API引用</a>查阅详细信息</p>
</blockquote>
<h3 id="编写可重用组件"><a href="#编写可重用组件" class="headerlink" title="编写可重用组件"></a>编写可重用组件</h3><blockquote>
<p>当编写组件时应该思考后期会不会重用该组件，编写一次性的组件会紧耦合，编写可重用组件需要<br>思考写什么东西呢？有以下三点</p>
<ul>
<li>Props 允许外部环境传递props给组件</li>
<li>Events 允许在外部环境触发事件</li>
<li>Slots 允许外部环境组合具有额外内容的组件<br>在模板中可以清晰的传达出你的意图：</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  :foo=&quot;baz&quot;</span><br><span class="line">  :bar=&quot;qux&quot;</span><br><span class="line">  @event-a=&quot;doThis&quot;</span><br><span class="line">  @event-b=&quot;doThat&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;img slot=&quot;icon&quot; src=&quot;...&quot;&gt;</span><br><span class="line">  &lt;p slot=&quot;main-text&quot;&gt;Hello!&lt;/p&gt;</span><br><span class="line">&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>
<h3 id="子组件引用"><a href="#子组件引用" class="headerlink" title="子组件引用"></a>子组件引用</h3><blockquote>
<p>不管存在的props和events，有时候你需要在js中直接访问子组件，为了完成这个目标你需要给子组<br>件分配一个ref ID，然后通过<code>ref</code>来引用：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;user-profile ref=&quot;profile&quot;&gt;&lt;/user-profile&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var parent = new Vue(&#123; el: &apos;#parent&apos; &#125;)</span><br><span class="line">// access child component instance</span><br><span class="line">var child = parent.$refs.profile</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当<code>ref</code>和<code>v-for</code>一起使用时，你得到的ref将会是一个对象或数组,包含了子组件元数据的镜像。<br>注意：<code>$refs</code>在组件渲染之后才存在，并且它不是反应式的。你应该避免在模板以及属性计算中<br>使用<code>$refs</code></p>
</blockquote>
<h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><blockquote>
<p>在大型app中，我们会把组件拆成一个块，只有当需要的时候才会加载它，在Vue中很简单：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;async-example&apos;, function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    // Pass the component definition to the resolve callback</span><br><span class="line">    resolve(&#123;</span><br><span class="line">      template: &apos;&lt;div&gt;I am async!&lt;/div&gt;&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当从服务器得到组件的定义时调用<code>resolve</code>函数，调用<code>reject</code>表示获取组件定义失败。建议的<br>方式是使用<a href="http://webpack.github.io/docs/code-splitting.html" target="_blank" rel="external">Webpack的代码拆分特性</a>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;async-webpack-example&apos;, function (resolve) &#123;</span><br><span class="line">  // This special require syntax will instruct Webpack to</span><br><span class="line">  // automatically split your built code into bundles which</span><br><span class="line">  // are loaded over Ajax requests.</span><br><span class="line">  require([&apos;./my-async-component&apos;], resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用Es6语法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  &apos;async-webpack-example&apos;,</span><br><span class="line">  () =&gt; System.import(&apos;./my-async-component&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="组件命名惯例"><a href="#组件命名惯例" class="headerlink" title="组件命名惯例"></a>组件命名惯例</h3><blockquote>
<p>你可以使用驼峰式，<code>-</code>分界符等，Vue不关注这些：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// in a component definition</span><br><span class="line">components: &#123;</span><br><span class="line">  // register using kebab-case</span><br><span class="line">  &apos;kebab-cased-component&apos;: &#123; /* ... */ &#125;,</span><br><span class="line">  // register using camelCase</span><br><span class="line">  &apos;camelCasedComponent&apos;: &#123; /* ... */ &#125;,</span><br><span class="line">  // register using TitleCase</span><br><span class="line">  &apos;TitleCasedComponent&apos;: &#123; /* ... */ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在html的模板，需要使用<code>-</code>分界符命名规则：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- alway use kebab-case in HTML templates --&gt;</span><br><span class="line">&lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt;</span><br><span class="line">&lt;camel-cased-component&gt;&lt;/camel-cased-component&gt;</span><br><span class="line">&lt;title-cased-component&gt;&lt;/title-cased-component&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在字符串模板中也没有什么限制：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- use whatever you want in string templates! --&gt;</span><br><span class="line">&lt;my-component&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;myComponent&gt;&lt;/myComponent&gt;</span><br><span class="line">&lt;MyComponent&gt;&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你的模板不通过插槽传递内容，可以自闭合：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component/&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这个只能在字符串模板中 使用。</p>
</blockquote>
<h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><blockquote>
<p>在组建内部可以通过他们的模板来循环调用自己，这个是通过<code>name</code>选项工作的：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: &apos;unique-name-of-my-component&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当你使用<code>Vue.component</code>注册了一个全局组件，这个全局Id自动设置为组建的名字：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;unique-name-of-my-component&apos;, &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不小心，很有可能会引起无限循环：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: &apos;stack-overflow&apos;,</span><br><span class="line">template: &apos;&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样会引起栈溢出的，所以确保循环是有条件的。</p>
</blockquote>
<h3 id="组件之间的相互引用"><a href="#组件之间的相互引用" class="headerlink" title="组件之间的相互引用"></a>组件之间的相互引用</h3><blockquote>
<p>如果你在构建一个文件目录树，你有一个<code>tree-foler</code>组件有这样的一个模板：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">  &lt;span&gt;&#123;&#123; folder.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;tree-folder-contents :children=&quot;folder.children&quot;/&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后<code>tree-folder-contents</code>持有这样的一个模板：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;child in children&quot;&gt;</span><br><span class="line">    &lt;tree-folder v-if=&quot;child.children&quot; :folder=&quot;child&quot;/&gt;</span><br><span class="line">    &lt;span v-else&gt;&#123;&#123; child.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当你仔细看，会发现循环依赖了，也就是A need B， B need A等等，利用<code>beforeCreate</code>来解决<br>这个问题：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate: function () &#123;</span><br><span class="line">  this.$options.components.TreeFolderContents = require(&apos;./tree-folder-contents.vue&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="行内模板"><a href="#行内模板" class="headerlink" title="行内模板"></a>行内模板</h3><blockquote>
<p>建议在组建中通过<code>template</code>使用模板。</p>
</blockquote>
<h3 id="X-Templates"><a href="#X-Templates" class="headerlink" title="X-Templates"></a>X-Templates</h3><blockquote>
<p>用<code>text/x-template</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt;</span><br><span class="line">  &lt;p&gt;Hello hello hello&lt;/p&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;hello-world&apos;, &#123;</span><br><span class="line">  template: &apos;#hello-world-template&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个也不建议使用，因为它分离了组件的其它定义。</p>
</blockquote>
<h3 id="Cheap-Static-Components-with-v-once"><a href="#Cheap-Static-Components-with-v-once" class="headerlink" title="Cheap Static Components with v-once"></a>Cheap Static Components with v-once</h3><blockquote>
<p>在Vue中渲染简单的Html元素是很快的，但是有时候你需要渲染一个包含大量静态内容的组件。在这<br>种情况下可以使用<code>v-once</code>指令到根元素来解析一次并缓存：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;terms-of-service&apos;, &#123;</span><br><span class="line">  template: &apos;\</span><br><span class="line">    &lt;div v-once&gt;\</span><br><span class="line">      &lt;h1&gt;Terms of Service&lt;/h1&gt;\</span><br><span class="line">      ... a lot of static content ...\</span><br><span class="line">    &lt;/div&gt;\</span><br><span class="line">  &apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/30/vue/components/" data-id="ciw58i9y90036uko0rdl6r1c4" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/11/30/vue/form_input/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">form input绑定</div>
    </a>
  
</nav>

  
</article>

</section>
        
          
            <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Canvas/">Canvas</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Electron/">Electron</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Http/">Http</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Redux/">React Redux</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Webpack/">Webpack</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/development-tools/">development tools</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget recents">
      <ul>
        
          <li>
            <a href="/2016/11/30/vue/components/">组件</a>
          </li>
        
          <li>
            <a href="/2016/11/30/vue/form_input/">form input绑定</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/event_handle/">事件处理</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/list_render/">Vue的列表渲染</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/conditional_render/">条件渲染</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">我的文章</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">23</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
</aside>
          
        
      </div>
      <!--<div id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a></br>
      &copy; 2016 zhuxin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</div>-->
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">我的文章</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>