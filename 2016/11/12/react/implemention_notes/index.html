<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>实现说明 | zhuxin_blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="实现说明
这一节主要是对堆栈协调器的实现说明,对React的API有一个技术性的理解，以及React是如何将它分为core,renders,reconciler是很重要的，如果你对React的代码库不是很熟悉，请阅读React代码库的概览。stack reconciler(堆栈协调器)供应所有React的生产代码。它位于src/renders/shared/stack/reconciler目录下并">
<meta property="og:type" content="article">
<meta property="og:title" content="实现说明">
<meta property="og:url" content="http://yoursite.com/2016/11/12/react/implemention_notes/index.html">
<meta property="og:site_name" content="zhuxin_blog">
<meta property="og:description" content="实现说明
这一节主要是对堆栈协调器的实现说明,对React的API有一个技术性的理解，以及React是如何将它分为core,renders,reconciler是很重要的，如果你对React的代码库不是很熟悉，请阅读React代码库的概览。stack reconciler(堆栈协调器)供应所有React的生产代码。它位于src/renders/shared/stack/reconciler目录下并">
<meta property="og:updated_time" content="2016-11-13T11:44:12.281Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="实现说明">
<meta name="twitter:description" content="实现说明
这一节主要是对堆栈协调器的实现说明,对React的API有一个技术性的理解，以及React是如何将它分为core,renders,reconciler是很重要的，如果你对React的代码库不是很熟悉，请阅读React代码库的概览。stack reconciler(堆栈协调器)供应所有React的生产代码。它位于src/renders/shared/stack/reconciler目录下并">
  
    <link rel="alternative" href="/atom.xml" title="zhuxin_blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  
  <link href="//fonts.googleapis.com/css?family=Inconsolata:400,700|Open+Sans:700,400" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <div id="header-title">
        <h1 id="logo-wrap">
          <a href="/" id="logo">
          
              <span id="subtitle">每天进步一点点</span>
          
          </a>
        </h1>
      </div>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">我的文章</a>
        
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</div>
      <div class="outer">
        <section id="main"><article id="post-react/implemention_notes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/12/react/implemention_notes/" class="article-date">
  <time datetime="2016-11-12T03:01:19.631Z" itemprop="datePublished">2016-11-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React/">React</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      实现说明
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="实现说明"><a href="#实现说明" class="headerlink" title="实现说明"></a>实现说明</h3><blockquote>
<p>这一节主要是对堆栈协调器的实现说明,对React的API有一个技术性的理解，以及React是如何将<br>它分为core,renders,reconciler是很重要的，如果你对React的代码库不是很熟悉，请阅读React<br>代码库的概览。stack reconciler(堆栈协调器)供应所有React的生产代码。它位于<code>src/renders/shared/stack/reconciler</code>目录下<br>并且ReactDOM和ReactNative都使用它。</p>
</blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>协调器没有一个公共的API，ReactDOM和ReactNative的渲染器有效的使用它有效的更新用户接口，这些接口是用户编写的用户组件。<br><strong>以递归的过程镶嵌</strong><br>你第一次镶嵌一个组件时:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;App /&gt;, rootEl);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ReactDOM会顺着reconciler(协调器)传递<code>&lt;App /&gt;</code>,自助<code>&lt;App /&gt;</code>是一个React元素，下面的是一个渲染什么的描述，你可以认为它是<br>一个简单的对象：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&lt;App /&gt;);</span><br><span class="line">// &#123; type: App, props: &#123;&#125; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>协调器会检查<code>&lt;App/&gt;</code>是一个class还是一个函数，如果App是一个函数，协调器会调用<code>App(props)</code>来获取要渲染的元素。<br>如果App是一个类，协调器会用<code>new App(props)</code>实例化这个App，调用<code>componentWillMount()</code>生命周期方法，然后调用<code>render()</code>方法<br>来获取渲染的元素.<br>无论哪种方式，协调器会知道App要渲染的元素。这个过程是递归的，App有可能渲染到<code>&lt;Greeting /&gt;</code>, Greeting可能渲染到<code>&lt;Button / &gt;</code>等等,<br>协调器会递归的通过用户定义的组件向下挖去，知道它知道每一个组件会渲染成什么。你可以假设这个过程的伪代码：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">function isClass(type) &#123;</span><br><span class="line">  //React.Component的子类都有这个标记</span><br><span class="line">  return (Boolean(type.prototype) &amp;&amp; Boolean(type.prototype.isReactComponet));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个函数接受一个React元素，比如(&lt;App/&gt;)</span><br><span class="line">//返回一个表示为镶嵌的树的DOM或原生节点</span><br><span class="line">function mount(element) &#123;</span><br><span class="line">  var type = element.type;</span><br><span class="line">  var props = element.props;</span><br><span class="line">  //我们需要查明/确定渲染的元素，将type作为函数运行或者创建一个实例并调用render</span><br><span class="line">  var renderedElement;</span><br><span class="line">  if(isClass(type)) &#123;</span><br><span class="line">    //组件类</span><br><span class="line">    var publicInstance = new type(props);</span><br><span class="line">    //设置属性</span><br><span class="line">    publicInstance.props = props;</span><br><span class="line">    //如果有必要则调用生命周期</span><br><span class="line">    if(publicInstance.componentWillMount) &#123;</span><br><span class="line">      publicInstance.componentWillMount();</span><br><span class="line">    &#125;</span><br><span class="line">    //通过调用render()得到渲染的元素</span><br><span class="line">    renderedElement = publicInstance.render();</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    //组件函数</span><br><span class="line">    renderedElement = type(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //这个过程是递归的因为一个组件返回的元素有可能是一个别的类型的组件</span><br><span class="line">  return mount(renderedElement);</span><br><span class="line">  //注意：这个实现是没有完成的而且会无限循环，它只会处理类似&lt;App /&gt;,&lt;Button&gt;的元素</span><br><span class="line">  //它还没有支持处理像&lt;div /&gt;或&lt;p/&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var rootEl = document.getElementById(&apos;root&apos;);</span><br><span class="line">var node = mount(&lt;App /&gt;);</span><br><span class="line">rootEl.appendChild(node);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这仅仅是一段伪代码，它不是真正的实现，它会导致栈溢出，因为我们没有讨论终止递归的条件。<br>我们回顾一下上面例子的几个关键概念：</p>
<ul>
<li>React元素是一些简单的对象来代表组件类型和属性(比如<code>&lt;App/&gt;</code>)。</li>
<li>用户自定义的组件（比如<code>&lt;App /&gt;</code>）可以是一个类也可以是一个函数但是他们最终都会被渲染为元素。</li>
<li>“mounting”是一个递归的过程它用来创建DOM以及Native树，给React的顶级元素（比如<code>&lt;App&gt;</code>）.</li>
</ul>
</blockquote>
<h3 id="Mounting-Host-Elements-镶嵌主机元素"><a href="#Mounting-Host-Elements-镶嵌主机元素" class="headerlink" title="Mounting Host Elements(镶嵌主机元素)"></a>Mounting Host Elements(镶嵌主机元素)</h3><blockquote>
<p>如果我们最终不向屏幕渲染任何东西这个过程将毫无作用，除了用户自定义的组件，React元素也可以表示特定<br>平台的组件.比如，<code>Button</code>可能在render方法中会返回一个<code>&lt;div /&gt;</code>。如果一个元素的类型是字符串，这样处理<br>主机元素：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&lt;div /&gt;);</span><br><span class="line">// &#123; type: &apos;div&apos;, props: &#123;&#125; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没有用户定义与主机元素相联系的代码。<br>当协调器遇到一个主机元素时，协调器会让render小心的镶嵌它，比如，ReactDOM会创建一个DOM节点，如果这个主机元素<br>有子节点，协调器会按照上面的算法递归的镶嵌，子元素是否是主机元素都没有关系（<code>&lt;div&gt;&lt;hr&gt;&lt;/div&gt;</code>），复杂的组件（<code>&lt;div&gt;&lt;Button/&gt;&lt;/div&gt;</code>）<br>子组件生产出来的DOM节点将会追加到父DOM节点，递归的方式，组装为完整的DOM结构。<br>注意：协调器本身不依赖于DOM，完整的镶嵌过程依赖于render（有时候，在源码中称之为镶嵌快照），最终结果可以是DOM node（React DOM）<br>一个字符串(ReactDOM Server)或者是原声的视图(React Native).<br>如果我们想扩展去处理主机元素的话，可以这样：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">function isClass(type) &#123;</span><br><span class="line">  // React.Component子类都有这个标记</span><br><span class="line">  return (</span><br><span class="line">    Boolean(type.prototype) &amp;&amp;</span><br><span class="line">    Boolean(type.prototype.isReactComponent)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个函数只处理复杂类型的元素</span><br><span class="line">//它只处理类似于&lt;App/&gt;和&lt;Button /&gt;这样的，而不是&lt;div/&gt;</span><br><span class="line">function mountComposite(element) &#123;</span><br><span class="line">  var type = element.type;</span><br><span class="line">  var props = element.props;</span><br><span class="line"></span><br><span class="line">  var renderedElement;</span><br><span class="line">  if (isClass(type)) &#123;</span><br><span class="line">    //组件类</span><br><span class="line">    var publicInstance = new type(props);</span><br><span class="line">    // 设置属性</span><br><span class="line">    publicInstance.props = props;</span><br><span class="line">    //如果有必要，调用生命周期</span><br><span class="line">    if (publicInstance.componentWillMount) &#123;</span><br><span class="line">      publicInstance.componentWillMount();</span><br><span class="line">    &#125;</span><br><span class="line">    renderedElement = publicInstance.render();</span><br><span class="line">  &#125; else if (typeof type === &apos;function&apos;) &#123;</span><br><span class="line">    //组件函数</span><br><span class="line">    renderedElement = type(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // This is recursive but we&apos;ll eventually reach the bottom of recursion when</span><br><span class="line">  //这是个递归的过程，但是当元素是主机元素时（比如&lt;div/&gt;而不是复杂的组件）我们最终会到达递归的底部</span><br><span class="line">  return mount(renderedElement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个函数只处理主机类型元素</span><br><span class="line">//比如，它处理&lt;div/&gt;,&lt;p/&gt;不会出来&lt;App/&gt;</span><br><span class="line">function mountHost(element) &#123;</span><br><span class="line">  var type = element.type;</span><br><span class="line">  var props = element.props;</span><br><span class="line">  var children = props.children || [];</span><br><span class="line">  if (!Array.isArray(children)) &#123;</span><br><span class="line">    children = [children];</span><br><span class="line">  &#125;</span><br><span class="line">  children = children.filter(Boolean);</span><br><span class="line"></span><br><span class="line">  //这一块的代码不会再协调器中</span><br><span class="line">  //不同的渲染器可能会初始化不同的节点</span><br><span class="line">  //比如，React Native可能会创建IOS或者Android的视图</span><br><span class="line">  var node = document.createElement(type);</span><br><span class="line">  Object.keys(props).forEach(propName =&gt; &#123;</span><br><span class="line">    if (propName !== &apos;children&apos;) &#123;</span><br><span class="line">      node.setAttribute(propName, props[propName]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  //镶嵌子元素</span><br><span class="line">  children.forEach(childElement =&gt; &#123;</span><br><span class="line">    // Children may be host (e.g. &lt;div /&gt;) or composite (e.g. &lt;Button /&gt;).</span><br><span class="line">    //子元素们可能是主机元素（比如&lt;div/&gt;）或复杂性元素(&lt;Button/&gt;)</span><br><span class="line">    //我们会递归的装载他们</span><br><span class="line">    var childNode = mount(childElement);</span><br><span class="line"></span><br><span class="line">    //这行代码也是渲染器特有的</span><br><span class="line">    //不同的渲染器有不同的结果</span><br><span class="line">    node.appendChild(childNode);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  //将DOM节点的装载结果返回</span><br><span class="line">  //这儿递归结束</span><br><span class="line">  return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mount(element) &#123;</span><br><span class="line">  var type = element.type;</span><br><span class="line">  if (typeof type === &apos;function&apos;) &#123;</span><br><span class="line">    // User-defined components</span><br><span class="line">    return mountComposite(element);</span><br><span class="line">  &#125; else if (typeof type === &apos;string&apos;) &#123;</span><br><span class="line">    // Platform-specific components</span><br><span class="line">    return mountHost(element);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var rootEl = document.getElementById(&apos;root&apos;);</span><br><span class="line">var node = mount(&lt;App /&gt;);</span><br><span class="line">rootEl.appendChild(node);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然这也能工作但里协调器的真正实现还有很远的距离，主要是漏掉了对更新的支持。</p>
</blockquote>
<h3 id="介绍（引入）内部实例"><a href="#介绍（引入）内部实例" class="headerlink" title="介绍（引入）内部实例"></a>介绍（引入）内部实例</h3><blockquote>
<p>React的关键特性是你可以重复渲染任何东西，并且他不会创新创建DOM或重置state：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;App /&gt;, rootEl);</span><br><span class="line">//会重新使用存在的DOM</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, rootEl);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然而，我们上面的实现知识装载初始状态的树，不能对他执行更新操作，因为没有存储一些必要的信息，<br>如publicInstance，或DOM节点对应于哪些组件。stack reconciler代码库通过将<code>mount()</code>函数和一个方法<br>放在一个类上。这种方式有一些缺陷，我们现在正在一相反的方向解决这个问题，重写reconciler正在进行中<br>不管怎样，现在它的工作方式就是这样的。<br>将<code>mountHost</code>和<code>mountComposite</code>函数拆分出来的替代方案就是，我们将创建两个类：<code>DOMComponent</code>和<code>CompositeComponent</code><br>两个类都有一个接收elements的<code>constructor</code>，还有一个返回镶嵌了dom节点的<code>mount()</code>方法，我们将会使用工厂模式代替类中<br>顶级的mount()函数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function instantiateComponent(element) &#123;</span><br><span class="line">  var type = element.type;</span><br><span class="line">  if(typeof type === &apos;function&apos;) &#123;</span><br><span class="line">    //用户定义的组件</span><br><span class="line">    return new CompositeComponent(element);</span><br><span class="line">  &#125;else if(typeof === &apos;string&apos;) &#123;</span><br><span class="line">    //平台组件</span><br><span class="line">    return new DOMComponent(element);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先，让我们思考<code>CompositeComponent</code>的实现方式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class CompositeComponent &#123;</span><br><span class="line">  constructor(element) &#123;</span><br><span class="line">    this.currentElement = element;</span><br><span class="line">    this.renderedElement = null;</span><br><span class="line">    this.publicInstance = null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getPublicInstance() &#123;</span><br><span class="line">    //对应复杂的组件，暴露出这个类实例</span><br><span class="line">    return this.publicInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mount() &#123;</span><br><span class="line">    var element = this.currentElement;</span><br><span class="line">    var type = element.type;</span><br><span class="line">    var props = element.props;</span><br><span class="line">    var publicInstance;</span><br><span class="line">    var renderedElement;</span><br><span class="line">    if(isClass(type)) &#123;</span><br><span class="line">      //组件类</span><br><span class="line">      publicInstance = new type(props);</span><br><span class="line">      //设置属性</span><br><span class="line">      publicInstance.props = props;</span><br><span class="line">      //如果有必要，调用生命周期</span><br><span class="line">      if(publicInstance.componentWillMount) &#123;</span><br><span class="line">        publicInstance.componentWillMount();</span><br><span class="line">      &#125;</span><br><span class="line">      renderedElement = publicInstance.render();</span><br><span class="line">    &#125;else if(typeof type === &apos;function&apos;) &#123;</span><br><span class="line">      publicInstance = null;</span><br><span class="line">      renderedElement = type(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //保存公共实例</span><br><span class="line">    this.publicInstance = publicInstance;</span><br><span class="line">    //根据元素实例化子组件的内部实例</span><br><span class="line">    //&lt;div&gt;,&lt;p&gt;将为一个DOM节点</span><br><span class="line">    //&lt;App /&gt; &lt;Button&gt;将为一个复杂组件</span><br><span class="line">    var renderedComponent = instantiateComponent(renderedElement);</span><br><span class="line">    this.renderedComponent = renderedComponent;</span><br><span class="line"></span><br><span class="line">    //装载renderd的输出</span><br><span class="line">    return renderedComponent.mount();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重构<code>mountHost()</code>之后的主要区别是，我们可以保持<code>this.node</code>以及<code>this.renderedChildren</code>于内部的组件实例相关联。<br>我们也可以在未来将它们用于非破坏性的更新。因此，每一个内部实例，复杂的以及主机的，现在指向其孩子内部实例。<br>为了帮助构思它，如果一个<code>&lt;App&gt;</code>组件函数渲染了一个<code>&lt;Button&gt;</code>类组件，并且<code>Button</code>类渲染了一个<code>&lt;div&gt;</code>，内部实例树<br>长得是这个样子的：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[object CompositeComponent] &#123;</span><br><span class="line">  currentElement: &lt;App /&gt;,</span><br><span class="line">  publicInstance: null,</span><br><span class="line">  rendererComponent: [object CompositeComponent] &#123;</span><br><span class="line">    currentElement: &lt;Button /&gt;,</span><br><span class="line">    publicInstance: [object Button],</span><br><span class="line">    renderedComponent: [object DOMComponent] &#123;</span><br><span class="line">      currentElement: &lt;div /&gt;,</span><br><span class="line">      node: [object HTMLDivElement],</span><br><span class="line">      renderedChildren: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在DOM中你仅仅能看见<code>div</code>,但是内部实例树既包含复杂的内部实例也包含主机的内部实例。<br>复杂的内部实例需要被存储：</p>
<ul>
<li>当前的元素</li>
<li>如果元素类型是个类，public实例</li>
<li>单个的内部实例的渲染结果，它既可以是<code>DOMComponent</code>也可以是<code>CompositeComponent</code><br>主机内部实例也需要被存储:</li>
<li>当前的元素</li>
<li>DOM节点</li>
<li>所有的子内部实例，它们既可以是<code>DOMComponent</code>也可以是<code>CompositeComponent</code>.<br>如果你努力设想在复杂的程序中一个内部实例是什么样的结构，(React DevTools)[<a href="https://github.com/facebook/react-devtools" target="_blank" rel="external">https://github.com/facebook/react-devtools</a>]<br>可以给你一个近似的结果，主机实例是灰色的，复杂实例是紫色的。<br>要完成这个重构，我们要引入一个函数镶嵌完整的树到节点容器。比如<code>ReactDOM.render()</code>,它返回一个公共实例：</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function mountTree(element, containerNode) &#123;</span><br><span class="line">  //创建顶层的内部实例</span><br><span class="line">  var rootComponent = instantiateComponent(element);</span><br><span class="line"></span><br><span class="line">  //装载顶层组件到containetr</span><br><span class="line">  var node = rootComponent.mount();</span><br><span class="line">  containerNode.appendChild(node);</span><br><span class="line">  //返回它提供的公共实例</span><br><span class="line">  var publicInstance = rootComponent.getPublicInstance();</span><br><span class="line">  return publicInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var rootEl = document.getElementById(&apos;root&apos;);</span><br><span class="line">mountTree(&lt;App /&gt;, rootEl);</span><br></pre></td></tr></table></figure>
<h3 id="Unmounting-正在解除挂载"><a href="#Unmounting-正在解除挂载" class="headerlink" title="Unmounting(正在解除挂载)"></a>Unmounting(正在解除挂载)</h3><blockquote>
<p>现在我们有内部实例维持他们的字元素与DOM节点，我们可以实现unmounting，d对于一个复杂的组件，unmounting调用生命周期的钩子<br>然后递归：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class CompositeComponent &#123;</span><br><span class="line"></span><br><span class="line">  //....</span><br><span class="line">  unmount() &#123;</span><br><span class="line">    //如果有必要调用生命周期的钩子</span><br><span class="line">    var publicInstance = this.publicInstance;</span><br><span class="line">    if(publicInstance) &#123;</span><br><span class="line">      if(publicInstance.componentWillUnMount) &#123;</span><br><span class="line">        publicInstance.componentWillUnMount();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //卸载单个渲染的组件</span><br><span class="line">    var renderedComponent = this.renderedComponent;</span><br><span class="line">    renderedComponent.unmount();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于<code>DOMComponent</code>,unmounting告诉每一个子元素卸载:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class DOMComponent &#123;</span><br><span class="line">  //...</span><br><span class="line"></span><br><span class="line">  unmount() &#123;</span><br><span class="line">    //卸载所有children</span><br><span class="line">    var renderedChildren = this.renderedChildren;</span><br><span class="line">    renderedChildren.forEach( child =&gt; child.unmount());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在实践中，卸载DOM组件也会移除事件监听器并且清楚缓存，在这里跳过这些细节。<br>现在我们添加一个新的顶级函数调用<code>unmountTree(containerNode)</code>，这和<code>ReactDOM.unmountComponentAtNode()</code>很相似：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function unmountTree(containerNode) &#123;</span><br><span class="line">  //从DOM节点中读取内部实例</span><br><span class="line">  //(这个还不能工作，我们需要改变mountTree来来储存它)</span><br><span class="line">  var node = containerNode.firstChild;</span><br><span class="line">  var rootComponent = node._internalInstance;</span><br><span class="line"></span><br><span class="line">  //卸载这个树并且情况这个container</span><br><span class="line">  rootComponent.unmount();</span><br><span class="line">  containerNode.innerHTML = &apos;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了使它工作，我们需要从DOM节点中获取内部根实例，我们将会修改<code>mountTree()</code>添加<code>_internalInstance</code>属性到根DOM节点。<br>我们也会告诉<code>mountTree()</code>销毁任何存在的树，所以它可以被调用多次：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function mountTree(element, containerNode) &#123;</span><br><span class="line">  //销毁任何存在的树</span><br><span class="line">  if(containerNode.firstChild) &#123;</span><br><span class="line">    unmountTree(containerNode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //创建顶层内部实例</span><br><span class="line">  var rootComponent = instantiateComponent(element);</span><br><span class="line"></span><br><span class="line">  //装载顶层内部实例到container</span><br><span class="line">  var mode = rootComponent.mount();</span><br><span class="line">  containerNode.appendChild(node);</span><br><span class="line"></span><br><span class="line">  //保存一个到内部实例的引用</span><br><span class="line">  node._internalInstance = rootComponent;</span><br><span class="line"></span><br><span class="line">  //返回它所提供的公共实例</span><br><span class="line">  var publicInstance = rootComponent.getPublicInstance();</span><br><span class="line">  return publicInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，运行<code>unmountTree()</code>或者运行<code>mountTree()</code>多次，移除旧的树然后运行组件的生命周期方法<code>componentWillUnmount</code>.</p>
</blockquote>
<h3 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h3><blockquote>
<p>在上一节，我们实现了<code>unmounting</code>,但是如果每一个属性的变化都会改变unmounted和mounted整个树，这对于React来说没有用，<br>协调器的目的是尽可能的保持和重用现有实例：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var rootEl = document.getElementById(&apos;root&apos;);</span><br><span class="line">mountTree(&lt;App /&gt;, rootEl);</span><br><span class="line">//这里应返回已存在的DOM</span><br><span class="line">mountTree(&lt;App /&gt;, rootEl);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们将会扩展我们的内部实例建立一个或多个方法，除了<code>mount()</code>和<code>unmount()</code>，<code>DOMComponent</code>和<code>CompositeComponent</code>将会<br>实现一个新的<code>receive(nextElement)</code>方法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CompositeComponent &#123;</span><br><span class="line">  //...</span><br><span class="line"></span><br><span class="line">  receive(nextElement) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DOMComponent &#123;</span><br><span class="line">  //...</span><br><span class="line"></span><br><span class="line">  receive(nextElement) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它的职责是根据下一个元素提供的说明做任何有必要的组建更新，这部分通常称之为’虚拟dom差异比较’，尽管真正发生的是内部树的递归然后<br>让每个内部实例接收到更新。</p>
</blockquote>
<h3 id="更新复杂组件-Updating-Composite-Component"><a href="#更新复杂组件-Updating-Composite-Component" class="headerlink" title="更新复杂组件(Updating Composite Component)"></a>更新复杂组件(Updating Composite Component)</h3><blockquote>
<p>当一个复杂组件接收到一个新的元素时，我们运行<code>componentWillUpdate()</code>生命周期钩子。然后我们根据新的属性重新渲染组件，然后得到<br>下一个渲染的元素：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class CompositeComponent &#123;</span><br><span class="line"></span><br><span class="line">  //...</span><br><span class="line"></span><br><span class="line">  receive(nextElement) &#123;</span><br><span class="line">    var prevProps = this.currentElement.props;</span><br><span class="line">    var publicInstance = this.publicInstance;</span><br><span class="line">    var prevRenderedComponent = this.renderedComponent;</span><br><span class="line">    var prevRenderedElement = this.renderedElement;</span><br><span class="line"></span><br><span class="line">    //修改*自己的*元素</span><br><span class="line">    this.currentElement = nextElement;</span><br><span class="line">    var type = nextElement.type;</span><br><span class="line">    var nextProps = nextElement.props;</span><br><span class="line"></span><br><span class="line">    //解决下一次的render()输出的是什么</span><br><span class="line">    var nextRenderedElement;</span><br><span class="line">    if(isClass(type)) &#123;</span><br><span class="line">      //组件类</span><br><span class="line">      //如果有必要调用生命周期</span><br><span class="line">      if(publicInstance.componentWillUpdate) &#123;</span><br><span class="line">        publicInstance.componentWillUpdate(prevProps);</span><br><span class="line">      &#125;</span><br><span class="line">      //修改属性</span><br><span class="line">      publicInstance.props = nextProps;</span><br><span class="line">      //重新渲染</span><br><span class="line">      nextRenderedElement = publicInstance.render();</span><br><span class="line">    &#125;else if(typeof type === &apos;function&apos;) &#123;</span><br><span class="line">      //组件函数</span><br><span class="line">      nextRenderedElement = type(nextProps);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接下来，我们可以看一下渲染的元素的类型，如果在最后一次的渲染中<code>type</code>没有发生变化，下面的<br>组件可以就地更新。例如：如果第一次返回<code>&lt;Button color=&#39;red&#39; /&gt;</code>，第二次返回<code>&lt;Button color=&#39;blue&#39;&gt;</code><br>我们只需要告诉相关联的内部实例接收下一个元素：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//如果渲染的元素的类型没有变化</span><br><span class="line">//复用已存在的组建实例并退出</span><br><span class="line">if(prevRenderedElement.type === nextRenderedElement.type) &#123;</span><br><span class="line">  prevRenderedComponent.receive(nextRenderedElement);</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是，如果下一次渲染的组件类型和上一次渲染的组件类型不同，我们不会修改内部实例，一个<code>&lt;button&gt;</code>不会变为<br>一个<code>&lt;input&gt;</code>：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line"></span><br><span class="line">  //如果我们达到这一点，我们需要卸载先前的</span><br><span class="line">  //装载组件，装载新的，交换他们的节点</span><br><span class="line"></span><br><span class="line">  //找到老节点因为它将被替换</span><br><span class="line">  var prevNode = prevRenderedComponent.getHostNode();</span><br><span class="line"></span><br><span class="line">  //卸载老child并装载新的child</span><br><span class="line">  prevRenderedComponent.unmount();</span><br><span class="line">  var nextRenderedComponent = instantiateComponent(nextRenderedElement);</span><br><span class="line">  var nextNode = nextRenderedComponent.mount();</span><br><span class="line"></span><br><span class="line">  //替换child的引用</span><br><span class="line">  this.renderedComponent = nextRenderedComponent;</span><br><span class="line"></span><br><span class="line">  //用新的替换老节点</span><br><span class="line">  //注意：这是渲染器特定的代码并且在理想情况下，因位于CompositeComponent的外面</span><br><span class="line">  prevNode.parentNode.replaceChild(nextNode, prevNode);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>综上所述，当一个复杂的组件接收到一个新的元素时，要么委托去修改内部实例，要么卸载它并在原来<br>的位置新建一个。<br>这里有另外一种情况，一个组件将会重新装载而不是接收一个元素，当元素的<code>key</code>改变时，我们不讨论<br><code>key</code>的处理，因为它会增加教程的复杂性。注意：我们需要在内部实例添加一个叫<code>getHostNode</code>的方法，<br>它可能位于特定平台的节点并取代它的更新过程。它的实现简单明了：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class CompositeComponent &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  getHostNode() &#123;</span><br><span class="line">    // Ask the rendered component to provide it.</span><br><span class="line">    // This will recursively drill down any composites.</span><br><span class="line">    return this.renderedComponent.getHostNode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DOMComponent &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  getHostNode() &#123;</span><br><span class="line">    return this.node;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新主机组件"><a href="#更新主机组件" class="headerlink" title="更新主机组件"></a>更新主机组件</h3><blockquote>
<p>主机组件实现，比如<code>DOMComponent</code>已不同的方式更新，当它们接收到新的元素时，他们需要更新基于平台特有的视图,<br>在React DOM的情景中，这意味着要更新DOM属性：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class DOMComponent &#123;</span><br><span class="line">  //...</span><br><span class="line">  receive(nextElement) &#123;</span><br><span class="line">    var node = this.node;</span><br><span class="line">    var prevElement = this.currentElement;</span><br><span class="line">    var prevProps = prevElement.props;</span><br><span class="line">    var nextProps = nextElement.props;    </span><br><span class="line">    this.currentElement = nextElement;</span><br><span class="line"></span><br><span class="line">    // Remove old attributes.</span><br><span class="line">    Object.keys(prevProps).forEach(propName =&gt; &#123;</span><br><span class="line">      if (propName !== &apos;children&apos; &amp;&amp; !nextProps.hasOwnProperty(propName)) &#123;</span><br><span class="line">        node.removeAttribute(propName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // Set next attributes.</span><br><span class="line">    Object.keys(nextProps).forEach(propName =&gt; &#123;</span><br><span class="line">      if (propName !== &apos;children&apos;) &#123;</span><br><span class="line">        node.setAttribute(propName, nextProps[propName]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接着，主机组件需要更新它们的children，和复杂组件不同的是，他们可能包含不止一个child，在下面这个简单的例子中，<br>我们使用内部实例数组并遍历它，是更新还是替换内部实例依赖于接收到的<code>type</code>是否与他们先前的<code>type</code>一致，真正的reconciler<br>也会也需要元素的<code>key</code>来进行插入还是删除，但是我们省略相关的实现。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line"></span><br><span class="line">    //这是React元素的数组</span><br><span class="line">    var prevChildren = prevProps.children || [];</span><br><span class="line">    if (!Array.isArray(prevChildren)) &#123;</span><br><span class="line">      prevChildren = [prevChildren];</span><br><span class="line">    &#125;</span><br><span class="line">    var nextChildren = nextProps.children || [];</span><br><span class="line">    if (!Array.isArray(nextChildren)) &#123;</span><br><span class="line">      nextChildren = [nextChildren];</span><br><span class="line">    &#125;</span><br><span class="line">    //这是内部实例的数组</span><br><span class="line">    var prevRenderedChildren = this.renderedChildren;</span><br><span class="line">    var nextRenderedChildren = [];</span><br><span class="line"></span><br><span class="line">    //当我们遍历children时，我们要添加对这个数组的一些操作</span><br><span class="line">    var operationQueue = [];</span><br><span class="line"></span><br><span class="line">    //注意：下面的部分非常简单，他不会处理重新排序，它的存在只是为了说明整体流程，但不具体</span><br><span class="line">    for (var i = 0; i &lt; nextChildren.length; i++) &#123;</span><br><span class="line">      // Try to get an existing internal instance for this child</span><br><span class="line">      var prevChild = prevRenderedChildren[i];</span><br><span class="line"></span><br><span class="line">      // If there is no internal instance under this index,</span><br><span class="line">      // a child has been appended to the end. Create a new</span><br><span class="line">      // internal instance, mount it, and use its node.</span><br><span class="line">      if (!prevChild) &#123;</span><br><span class="line">        var nextChild = instantiateComponent(nextChildren[i]);</span><br><span class="line">        var node = nextChild.mount();</span><br><span class="line"></span><br><span class="line">        // Record that we need to append a node</span><br><span class="line">        operationQueue.push(&#123;type: &apos;ADD&apos;, node&#125;);</span><br><span class="line">        nextRenderedChildren.push(nextChild);</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // We can only update the instance if its element&apos;s type matches.</span><br><span class="line">      // For example, &lt;Button size=&quot;small&quot; /&gt; can be updated to</span><br><span class="line">      // &lt;Button size=&quot;large&quot; /&gt; but not to an &lt;App /&gt;.</span><br><span class="line">      var canUpdate = prevChildren[i].type === nextChildren[i].type;</span><br><span class="line"></span><br><span class="line">      // If we can&apos;t update an existing instance, we have to unmount it</span><br><span class="line">      // and mount a new one instead of it.</span><br><span class="line">      if (!canUpdate) &#123;</span><br><span class="line">        var prevNode = prevChild.node;</span><br><span class="line">        prevChild.unmount();</span><br><span class="line"></span><br><span class="line">        var nextChild = instantiateComponent(nextChildren[i]);</span><br><span class="line">        var nextNode = nextChild.mount();</span><br><span class="line"></span><br><span class="line">        // Record that we need to swap the nodes</span><br><span class="line">        operationQueue.push(&#123;type: &apos;REPLACE&apos;, prevNode, nextNode&#125;);</span><br><span class="line">        nextRenderedChildren.push(nextChild);</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // If we can update an existing internal instance,</span><br><span class="line">      // just let it receive the next element and handle its own update.</span><br><span class="line">      prevChild.receive(nextChildren[i]);</span><br><span class="line">      nextRenderedChildren.push(prevChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Finally, unmount any children that don&apos;t exist:</span><br><span class="line">    for (var j = nextChildren.length; j &lt; prevChildren.length; j++) &#123;</span><br><span class="line">     var prevChild = prevRenderedChildren[j];</span><br><span class="line">     var node = prevChild.node;</span><br><span class="line">     prevChild.unmount();</span><br><span class="line"></span><br><span class="line">     // Record that we need to remove the node</span><br><span class="line">     operationQueue.push(&#123;type: &apos;REMOVE&apos;, node&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Point the list of rendered children to the updated version.</span><br><span class="line">    this.renderedChildren = nextRenderedChildren;</span><br><span class="line"></span><br><span class="line">    // ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后一步，我们执行DOM操作，真实的reconciler是很复杂的因为它还得处理移动:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Process the operation queue.</span><br><span class="line">  while (operationQueue.length &gt; 0) &#123;</span><br><span class="line">    var operation = operationQueue.shift();</span><br><span class="line">    switch (operation.type) &#123;</span><br><span class="line">    case &apos;ADD&apos;:</span><br><span class="line">      this.node.appendChild(operation.node);</span><br><span class="line">      break;</span><br><span class="line">    case &apos;REPLACE&apos;:</span><br><span class="line">      this.node.replaceChild(operation.nextNode, operation.prevNode);</span><br><span class="line">      break;</span><br><span class="line">    case &apos;REMOVE&apos;:</span><br><span class="line">      this.node.removeChild(operation.node);</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主机组件更新也是这样。</p>
</blockquote>
<h3 id="顶级更新"><a href="#顶级更新" class="headerlink" title="顶级更新"></a>顶级更新</h3><blockquote>
<p>现在<code>CompositeComponent</code>和<code>DOMComponent</code>实现了<code>receive(nextElement)</code>方法，当元素类型同最后一次相同时，<br>我们可以改变顶层<code>mountTree()</code>来使用它:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function mountTree(element, containerNode) &#123;</span><br><span class="line">  // Check for an existing tree</span><br><span class="line">  if (containerNode.firstChild) &#123;</span><br><span class="line">    var prevNode = containerNode.firstChild;</span><br><span class="line">    var prevRootComponent = prevNode._internalInstance;</span><br><span class="line">    var prevElement = prevRootComponent.currentElement;</span><br><span class="line"></span><br><span class="line">    // If we can, reuse the existing root component</span><br><span class="line">    if (prevElement.type === element.type) &#123;</span><br><span class="line">      prevRootComponent.receive(element);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Otherwise, unmount the existing tree</span><br><span class="line">    unmountTree(containerNode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在调用<code>mountTree()</code>两次非破坏性的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var rootEl = document.getElementById(&apos;root&apos;);</span><br><span class="line"></span><br><span class="line">mountTree(&lt;App /&gt;, rootEl);</span><br><span class="line">// Reuses the existing DOM:</span><br><span class="line">mountTree(&lt;App /&gt;, rootEl);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是React内部工作的基本原理。</p>
</blockquote>
<h3 id="What-We-Left-Out"><a href="#What-We-Left-Out" class="headerlink" title="What We Left Out"></a>What We Left Out</h3><blockquote>
<p>这篇文章和真实的代码库进行了一个简单的比较，这儿有几个我们没有解决的问题：</p>
<ul>
<li>组件可以返回null，reconciler(协调器)可以处理数组中的”空插槽(empty slots)”并渲染出去。</li>
<li>协调器会从元素中读取<code>key</code>,并且用它建立内部实例和数组中元素之间的关系，在真实的React实现中，大量的复杂性和它有关。</li>
<li>除了复杂的以及主机的内部实例，还有一些类对应空元素和文本组件。可以通过null代表文本节点和数组的空插槽。</li>
<li>renders(渲染器)使用注入来传递主机内部类给reconciler(协调器)，比如，React DOM告诉协调器使用ReactDOMComponent作为主机内部实例来实现.</li>
<li>更新子机列表的逻辑被提取到一个叫ReactMultiChild 的一个mixin,它被用与ReactDOM和React Native的内部实例类的实现。</li>
<li>协调器也实现了在复杂组件中对<code>setState()</code>的支持，在事件处理中，大量的更新会成批的放入单个更新。</li>
<li>协调器会小心处理附加及分离到复杂组件和主机节点的refs</li>
<li>生命周期的钩子，会在DOM准备好之后调用，像<code>componentDidMount()</code>,<code>componentDidUpdate()</code>,获取’回调队列’并批处理执行。</li>
<li>React将当前的更新的信息放到一个叫<code>transaction</code>的内部对象中，<code>transactions</code>用于追踪挂起的生命周期钩子队列。当前DOM的<br>内部警告以及其余”global”会给到一个特定的更新，<code>transactions</code>用来确保React更新后清空一切，例如，<code>transactions</code>提供<br>React DOM恢复输入选择后的更新。</li>
</ul>
</blockquote>
<h3 id="Jumping-into-the-Code"><a href="#Jumping-into-the-Code" class="headerlink" title="Jumping into the Code"></a>Jumping into the Code</h3><blockquote>
<ul>
<li><code>ReactMount</code>is where the code like mountTree() and unmountTree() from this tutorial lives,它负责装载和卸载顶级组件<br><code>ReactNativeMount</code>是ReactNative的模拟。</li>
<li>本教程中<code>ReactDOMComponent</code>和<code>DOMComponent</code>是同等的，它实现了ReactDOM渲染器的主机组件类。<code>ReactNativeBaseComponent</code>是<br>React Native的模拟。</li>
<li><code>ReactCompositeComponent</code>和<code>CompositeComponent</code>是同等的，它处理调用用户自定义组建以及维持state。</li>
<li><code>instantiateReactComponent</code>包含了一个开关用来选择一个正确的内部实例类用来构造一个元素。在此教程中和<code>instantiateComponent()</code>是同等的。</li>
<li><code>ReactReconciler</code>是<code>mountComponent</code>和<code>receiveComponent</code>以及<code>unmountComponent</code>方法的包装。它在内部实例上调用底层的实现。当然它也<br>包含所有内部实例实现的共享代码。</li>
<li><code>ReactChildReconciler</code>实现了通过元素的<code>key</code>,<code>mounting</code>，<code>updating</code>,<code>unmounting</code>children的逻辑。</li>
<li><code>ReactMultiChild</code>实现了渲染器对操作队列的处理。child的插入，移动，删除。</li>
<li><code>mount()</code>,<code>receive()</code>,<code>unmount</code>因为一些遗留原因在React代码库中，实际上被称为<code>mountComponent()</code>,<code>receiveComponent</code>,<br><code>unmountComponent()</code></li>
<li>内部实例的属性以下划线开头，比如,_currentElement,在代码库中自始至终它们被认为是只读的。</li>
</ul>
</blockquote>
<h3 id="Future-Directions-未来方向"><a href="#Future-Directions-未来方向" class="headerlink" title="Future Directions(未来方向)"></a>Future Directions(未来方向)</h3><blockquote>
<p>stack reconciler具有的局限性，如同步，不能中断工作或chunks的拆分。在新的<code>Fiber reconciler</code>中有一个完全不同的结构，在未来我们打算使用<br>它代替现有的reconciler，但是目前还很遥远。</p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/12/react/implemention_notes/" data-id="ciw58i9wz002auko0cjc95lkj" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/11/15/react/design_principles/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          设计原则
        
      </div>
    </a>
  
  
    <a href="/2016/11/10/react/reconciler_algorithm/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">React Reconciler Algorithm</div>
    </a>
  
</nav>

  
</article>

</section>
        
          
            <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Canvas/">Canvas</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Electron/">Electron</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Http/">Http</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Redux/">React Redux</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Webpack/">Webpack</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/development-tools/">development tools</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget recents">
      <ul>
        
          <li>
            <a href="/2016/11/30/vue/components/">组件</a>
          </li>
        
          <li>
            <a href="/2016/11/30/vue/form_input/">form input绑定</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/event_handle/">事件处理</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/list_render/">Vue的列表渲染</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/conditional_render/">条件渲染</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">我的文章</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">23</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
</aside>
          
        
      </div>
      <!--<div id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a></br>
      &copy; 2016 zhuxin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</div>-->
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">我的文章</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>