<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>zhuxin_blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="zhuxin_blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="zhuxin_blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zhuxin_blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="zhuxin_blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  
  <link href="//fonts.googleapis.com/css?family=Inconsolata:400,700|Open+Sans:700,400" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <div id="header-title">
        <h1 id="logo-wrap">
          <a href="/" id="logo">
          
              <span id="subtitle">每天进步一点点</span>
          
          </a>
        </h1>
      </div>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">我的文章</a>
        
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</div>
      <div class="outer">
        <section id="main">
  
    <article id="post-vue/style_class_binding" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/29/vue/style_class_binding/" class="article-date">
  <time datetime="2016-11-29T08:47:31.342Z" itemprop="datePublished">2016-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/29/vue/style_class_binding/">样式绑定</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Class和Style的绑定"><a href="#Class和Style的绑定" class="headerlink" title="Class和Style的绑定"></a>Class和Style的绑定</h3><blockquote>
<p>对数据绑定的共同需求是操纵元素的列表样式及行内样式，由于他们都是属性，可以通过<code>v-bind</code><br>来处理他们。当<code>v-bind</code>绑定的是<code>class</code>以及<code>style</code>时，除了字符串，表达式也可以被评估为<br>对象或者数组。</p>
</blockquote>
<h3 id="绑定HTML的类"><a href="#绑定HTML的类" class="headerlink" title="绑定HTML的类"></a>绑定HTML的类</h3><h4 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h4><blockquote>
<p>我们可以传递一个对象给<code>v-bind:class</code>来动态的切换class：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的语法意味着class的存在由<code>isActive</code>是否为真决定。可以通过对象中的多个字段来切换多个<br>类，另外<code>v-bind:class</code>指令可以与<code>class</code>属性共同存在，下面的例子：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;static&quot;</span><br><span class="line">     v-bind:class=&quot;&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以及相应的数据对象：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它的渲染结果是：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当<code>isActive</code>和<code>hasError</code>改变时，类列表页会相应的变化，比如，当<code>hasError</code>为<code>true</code>时，<br>相应的类列表会变为<code>&quot;static active text-danger&quot;</code>.<br>绑定的对象不一定非得内联：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: true,</span><br><span class="line">    &apos;text-danger&apos;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>渲染结果是相同的，我们也可以绑定一个返回对象的计算属性，例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  error: null</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      active: this.isActive &amp;&amp; !this.error,</span><br><span class="line">      &apos;text-danger&apos;: this.error &amp;&amp; this.error.type === &apos;fatal&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h4><blockquote>
<p>我们可以传递一个数组给<code>v-bind:class</code>应用于类列表：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: &apos;active&apos;,</span><br><span class="line">  errorClass: &apos;text-danger&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它的渲染结果是:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你想在列表中有条件的切换类，你可以使用三元运算符：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>errorClass</code>会一直应用，但是只有当<code>isActive</code>为真时<code>activeClass</code>才会被应用。但是当你<br>有多个条件切换的类在列表中会有点罗嗦，可以在列表语法中使用对象语法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="With-Components"><a href="#With-Components" class="headerlink" title="With Components"></a>With Components</h3><blockquote>
<p>当你在自定义组建中使用<code>class</code>属性时，类将会被添加到组件的根节点上，该元素已存在的类不会<br>被覆盖，比如，你这么声明一个组件：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在使用它时又添加了一些类：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最终的渲染结果是：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于类绑定也是同样的效果：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当<code>isActive</code>为true时，渲染结果为：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;foo bar active&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h3 id="行内样式的绑定"><a href="#行内样式的绑定" class="headerlink" title="行内样式的绑定"></a>行内样式的绑定</h3><h4 id="类语法"><a href="#类语法" class="headerlink" title="类语法"></a>类语法</h4><blockquote>
<p><code>v-bind:style</code>的对象语法简单易懂，看起来很像CSS，你可以使用驼峰式或者”-“形式的属性命名:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: &apos;red&apos;,</span><br><span class="line">  fontSize: 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>直接绑定一个样式对象让模板看起来很干净是一个好主意：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: &apos;red&apos;,</span><br><span class="line">    fontSize: &apos;13px&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对象语法经常结合返回对象的计算属性来使用。</p>
</blockquote>
<h4 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h4><blockquote>
<p><code>v-bind:style</code>的数组语法允许你对一个元素应用多个样式对象：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Auto-prefixing-自动添加前缀"><a href="#Auto-prefixing-自动添加前缀" class="headerlink" title="Auto-prefixing(自动添加前缀)"></a>Auto-prefixing(自动添加前缀)</h4><blockquote>
<p>当你在<code>v-bind:style</code>中使用一个需要添加供应商前缀的属性时，Vue会自动的检测出并且添加一个<br>合适的前缀来应用该样式，比如<code>transform</code></p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/29/vue/style_class_binding/" data-id="ciw3cie8j0040qso06jl7kena" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/computed_properties" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/29/vue/computed_properties/" class="article-date">
  <time datetime="2016-11-29T06:24:55.080Z" itemprop="datePublished">2016-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/29/vue/computed_properties/">Vue属性的计算及监听器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Vue属性计算及监听器"><a href="#Vue属性计算及监听器" class="headerlink" title="Vue属性计算及监听器"></a>Vue属性计算及监听器</h3><h3 id="属性计算"><a href="#属性计算" class="headerlink" title="属性计算"></a>属性计算</h3><blockquote>
<p>模板内使用表达式是很方便的，但只是对于简单的操作。如果在模板中放入大量的逻辑，只会让模板<br>变得庞大且难以管理：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你需要看一会才知道这个模板显示的是倒序的字符串，如果你要在模板中多次使用的话，这会变得很<br>糟糕。对于复杂逻辑，应该使用属性的计算。</p>
</blockquote>
<h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // a computed getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` points to the vm instance</span><br><span class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里我们已经宣布了一个计算的属性<code>reversedMessage</code>,我们提供的这个函数和属性的getter函数<br>类似<code>rm.reversedMessage</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(vm.reversedMessage) // -&gt; &apos;olleH&apos;</span><br><span class="line">vm.message = &apos;Goodbye&apos;</span><br><span class="line">console.log(vm.reversedMessage) // -&gt; &apos;eybdooG&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>vm.reversedMessage</code>的值依赖于<code>vm.message</code>的值。你可以将计算的属性像普通属性一样绑定到<br>模板上，Vue会意识到<code>vm.reversedMessage</code>依赖<code>vm.message</code>,所以当<code>vm.message</code>改变的时候<br>修改对应绑定的<code>vm.reversedMessage</code>的值，当然最好的部分是我们已经以声明的方式创建了依赖<br>关系:计算的getter函数是纯函数并且没有副作用，这样可以很轻松的测试。</p>
</blockquote>
<h3 id="计算的缓存VS方法"><a href="#计算的缓存VS方法" class="headerlink" title="计算的缓存VS方法"></a>计算的缓存VS方法</h3><blockquote>
<p>你可能已经注意到我们可以通过在表达式中调用方法得到相同的结果：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Reversed message: &quot;&#123;&#123; reverseMessage() &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// in component</span><br><span class="line">methods: &#123;</span><br><span class="line">  reverseMessage: function () &#123;</span><br><span class="line">    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以定义一个方法来代替属性的计算。对于最终结果，这两种方式确实完全相同。但是，不同之<br>处是，计算的属性会缓存基于它的依赖，一个计算的属性只有当它的依赖项发生改变时才会重新计算<br>这意味着只要<code>message</code>没有改变，多次访问计算的属性<code>reversedMessage</code>会返回上次计算的结果<br>而不是重新运行该函数。下面的计算的属性永远不会发生变化，因为<code>Date.now()</code>不是一个反应式<br>的依赖项：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  now: function () &#123;</span><br><span class="line">    return Date.now()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>作为比较，不管是否重新渲染，一个方法的调用都需要重新运行该方法。我们为什么需要缓存呢？<br>想象一个非常耗时的计算属性A，它需要在一个很大的数组中循环并且进行大量的计算，然后可能有<br>其余的计算属性依赖于A的计算属性，如果没有还从的话，我们将毫无必要的执行多次A的计算，当在<br>不需要使用缓存的情况下，使用方法代替。</p>
</blockquote>
<h3 id="计算的属性VS监听的属性"><a href="#计算的属性VS监听的属性" class="headerlink" title="计算的属性VS监听的属性"></a>计算的属性VS监听的属性</h3><blockquote>
<p>Vue确实提供了一种通用的方法来观察Vue实例中data的变化做出反应：<code>watch properties</code>.当你<br>的一些数据需要基于其它一些数据做出改变时，可以尝试使用<code>watch</code>属性。但是使用属性的计算相对<br>来说更好一点，考虑下面的例子：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Foo&apos;,</span><br><span class="line">    lastName: &apos;Bar&apos;,</span><br><span class="line">    fullName: &apos;Foo Bar&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: function (val) &#123;</span><br><span class="line">      this.fullName = val + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: function (val) &#123;</span><br><span class="line">      this.fullName = this.firstName + &apos; &apos; + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的代码有重复，和属性的计算相比较：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Foo&apos;,</span><br><span class="line">    lastName: &apos;Bar&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: function () &#123;</span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样更好一点。</p>
</blockquote>
<h3 id="计算属性的Setter"><a href="#计算属性的Setter" class="headerlink" title="计算属性的Setter"></a>计算属性的Setter</h3><blockquote>
<p>默认情况下计算的属性时只读的，但是当你需要时你可以提供一个setter函数：    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    // getter</span><br><span class="line">    get: function () &#123;</span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    // setter</span><br><span class="line">    set: function (newValue) &#123;</span><br><span class="line">      var names = newValue.split(&apos; &apos;)</span><br><span class="line">      this.firstName = names[0]</span><br><span class="line">      this.lastName = names[names.length - 1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在当你执行<code>vm.fullName = &#39;John Doe&#39;</code>,setter函数将会被执行，相应的<code>vm.firstName</code>和<br><code>vm.lastName</code>也会改变。</p>
</blockquote>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><blockquote>
<p>虽然在多数情况下，属性的计算是很合适的，但是有时候自定义监听器也是有必要的。这也是为什么<br>Vue提供了一个同用的方式，通过<code>watch</code>选项来对数据的变化做出反应。当你要响应不断变化的数据<br>执行异步操作或者昂贵操作的时候很有用。例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;watch-example&quot;&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    &lt;input v-model=&quot;question&quot;&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Since there is already a rich ecosystem of ajax libraries    --&gt;</span><br><span class="line">&lt;!-- and collections of general-purpose utility methods, Vue core --&gt;</span><br><span class="line">&lt;!-- is able to remain small by not reinventing them. This also   --&gt;</span><br><span class="line">&lt;!-- gives you the freedom to just use what you&apos;re familiar with. --&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/axios@0.12.0/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/lodash@4.13.1/lodash.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var watchExampleVM = new Vue(&#123;</span><br><span class="line">  el: &apos;#watch-example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    question: &apos;&apos;,</span><br><span class="line">    answer: &apos;I cannot give you an answer until you ask a question!&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    // whenever question changes, this function will run</span><br><span class="line">    question: function (newQuestion) &#123;</span><br><span class="line">      this.answer = &apos;Waiting for you to stop typing...&apos;</span><br><span class="line">      this.getAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // _.debounce is a function provided by lodash to limit how</span><br><span class="line">    // often a particularly expensive operation can be run.</span><br><span class="line">    // In this case, we want to limit how often we access</span><br><span class="line">    // yesno.wtf/api, waiting until the user has completely</span><br><span class="line">    // finished typing before making the ajax request. To learn</span><br><span class="line">    // more about the _.debounce function (and its cousin</span><br><span class="line">    // _.throttle), visit: https://lodash.com/docs#debounce</span><br><span class="line">    getAnswer: _.debounce(</span><br><span class="line">      function () &#123;</span><br><span class="line">        var vm = this</span><br><span class="line">        if (this.question.indexOf(&apos;?&apos;) === -1) &#123;</span><br><span class="line">          vm.answer = &apos;Questions usually contain a question mark. ;-)&apos;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        vm.answer = &apos;Thinking...&apos;</span><br><span class="line">        axios.get(&apos;https://yesno.wtf/api&apos;)</span><br><span class="line">          .then(function (response) &#123;</span><br><span class="line">            vm.answer = _.capitalize(response.data.answer)</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(function (error) &#123;</span><br><span class="line">            vm.answer = &apos;Error! Could not reach the API. &apos; + error</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      // This is the number of milliseconds we wait for the</span><br><span class="line">      // user to stop typing.</span><br><span class="line">      500</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这个场景中，使用<code>watch</code>选项允许我们执行异步操作，限制多久执行操作，以及只有获取到数据<br>才设置state。而这些在属性计算都是不可用的。除了这个选项你还可以使用必要的<a href="https://vuejs.org/v2/api/#vm-watch" target="_blank" rel="external">vm.$watch API</a></p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/29/vue/computed_properties/" data-id="ciw3cie7y003sqso07ufc6w6a" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/template_syntax" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/29/vue/template_syntax/" class="article-date">
  <time datetime="2016-11-28T16:31:05.488Z" itemprop="datePublished">2016-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/29/vue/template_syntax/">Vue模板语法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><blockquote>
<p>Vue使用基于HTML的模板语法，允许你以声明式的方式绑定渲染的DOM到Vue实例的data。<br>所有的Vue模板是有效的html，它可以被特定兼容性的浏览器及html解析器解析。在引擎下，Vue编<br>译模板到虚拟DOM的render函数里，与反应系统相结合，聪明的计算出最小数量的组件重新渲染当<br>应用程序state发生变化时，最小数量的DOM操作。如果很熟悉虚拟DOM的概念，并更喜欢原生js的<br>特性，可以直接写render函数来代替模板。</p>
</blockquote>
<h3 id="文本插入"><a href="#文本插入" class="headerlink" title="文本插入"></a>文本插入</h3><h4 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h4><blockquote>
<p>最常用的文本绑定就是使用双括号语法这种格式，比如: <code>&lt;span&gt;Message: &lt;/span&gt;</code><br><code></code>将会替换为相应data对象的属性值，当data的msg属性值改变时，<code></code>也会改变。<br>通过使用<code>v-once</code>指令让data属性改变时相应的<code></code>不更新。但是记住，这回影响任何在该<br>节点绑定的数据。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-once&gt;This will never change: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<h4 id="原始html"><a href="#原始html" class="headerlink" title="原始html"></a>原始html</h4><blockquote>
<p>双花括号的语法以文本格式解释data，而不是HTML,如果要输出HTML，使用<code>v-html</code>指令.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div v-html=&quot;raw&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var vue = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">    raw: &apos;&lt;p style=&apos;color:red&apos;&gt;测试&lt;/p&gt;&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>Vue不是基于字符串模板引擎，组件是UI重用和组成首选的基本单位。注意：在网站动态的渲染任何<br>HTML是非常危险的，因为会引起XSS攻击，只有使用HTML插入在信赖的内容上并永远不会使用用户提<br>供的内容才是安全的。</p>
</blockquote>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><blockquote>
<p>双花括号语法不能使用在HTML的属性中，替换方案是使用<code>v-bind</code>命令:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于boolean类型的属性同样有效，当值为false时，移除此属性：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-bind:disabled=&quot;someDynamicCondition&quot;&gt;Button&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<h4 id="使用JS表达式"><a href="#使用JS表达式" class="headerlink" title="使用JS表达式"></a>使用JS表达式</h4><blockquote>
<p>Vue支持在数据绑定时使用js表达式，比如:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line">&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;</span><br><span class="line">&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class="line">&lt;div v-bind:id=&quot;&apos;list-&apos; + id&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样绑定的限制是，在双花括号语法中只能使用一个表达式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- this is a statement, not an expression: --&gt;</span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line">&lt;!-- flow control won&apos;t work either, use ternary expressions --&gt;</span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>模板表达式是沙箱式的，你可以访问类似<code>Math</code>和<code>Date</code>的全局变量，但是不能在模板表达式中<br>访问用户自定义的全局变量。</p>
</blockquote>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><blockquote>
<p>指令是以<code>v</code>为前缀的特殊的属性，指令属性值期望的是一个简单的js表达式，指令的作用就是当表<br>达式的值更改时，将响应作用应用到DOM上：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当<code>seen</code>表达式的值为false时，<code>v-if</code>指令将移除<code>p</code>元素，反之则插入<code>p</code>元素。</p>
</blockquote>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><blockquote>
<p>一些指令可以携带一个参数，它由指令<code>:</code>后的名字表示。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>href</code>是一个参数，它告诉<code>v-bind</code>指令绑定元素的<code>href</code>属性到<code>url</code>表达式的值，还有就是<br><code>v-on</code>指令，用来监听DOM事件:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间名称就是要监听的DOM时间.</p>
</blockquote>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><blockquote>
<p>修饰符是一个特殊的后缀又一个<code>.</code>表示，它表明一个指令由一种特殊的方式绑定，比如<code>.prevent</code><br>让<code>v-on</code>指令调用<code>e.preventDefault()</code>阻止事件的默认执行。</p>
</blockquote>
<h4 id="筛选器"><a href="#筛选器" class="headerlink" title="筛选器"></a>筛选器</h4><blockquote>
<p>Vue.js允许你定义筛选器，可以应用于常见的文本格式，筛选器常用在两个地方,双花括号以及<code>v-bind</code><br>表达式，筛选器添加在js表达式的后面，由管道<code>|</code>符号表示：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- in mustaches --&gt;</span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line">&lt;!-- in v-bind --&gt;</span><br><span class="line">&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：Vue2.x的筛选器只能用在双花括号以及<code>v-bind</code>表达式中，因为筛选器的主要设计用来文本<br>转换的目的，对于更复杂的指令，使用<a href="https://vuejs.org/v2/guide/computed.html" target="_blank" rel="external">计算的属性</a>来代替。<br>筛选器函数总是接收表达式的值作为第一个参数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  filters: &#123;</span><br><span class="line">    capitalize: function (value) &#123;</span><br><span class="line">      if (!value) return &apos;&apos;</span><br><span class="line">      value = value.toString()</span><br><span class="line">      return value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>筛选器可以使链式的：   </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>筛选器是js函数，所以他们可以接收参数：    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA(&apos;arg1&apos;, arg2) &#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里，<code>&#39;arg1&#39;</code>将作为第二个参数传递给filter函数,而<code>arg2</code>表达式会评估它的值并作为第三<br>个参数传递。</p>
</blockquote>
<h4 id="速记"><a href="#速记" class="headerlink" title="速记"></a>速记</h4><blockquote>
<p>频繁的使用<code>v-</code>前缀的指令很繁琐，所以Vue提供了两种常用指令的简写方式<code>v-bind</code>,<code>v-on</code>:</p>
</blockquote>
<h5 id="v-bind的速记方式"><a href="#v-bind的速记方式" class="headerlink" title="v-bind的速记方式"></a><code>v-bind</code>的速记方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- full syntax --&gt;</span><br><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- shorthand --&gt;</span><br><span class="line">&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<h5 id="v-on的速记方式"><a href="#v-on的速记方式" class="headerlink" title="v-on的速记方式"></a><code>v-on</code>的速记方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- full syntax --&gt;</span><br><span class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- shorthand --&gt;</span><br><span class="line">&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/29/vue/template_syntax/" data-id="ciw3cie8a003wqso05p0hboue" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/get_started" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/28/vue/get_started/" class="article-date">
  <time datetime="2016-11-28T12:44:58.565Z" itemprop="datePublished">2016-11-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/28/vue/get_started/">Vue纵览</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Vue实例的属性和方法"><a href="#Vue实例的属性和方法" class="headerlink" title="Vue实例的属性和方法"></a>Vue实例的属性和方法</h3><blockquote>
<p>Vue实例通过<code>var app = new Vue({})</code>来创建，构造参数接收一个对象，该对象包含的属性有<br><code>data</code>, <code>template</code>, <code>el</code>, <code>methods</code>, 生命周期回调函数等等，简单的实例:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      a: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      hello: function() &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Vue的生命周期钩子"><a href="#Vue的生命周期钩子" class="headerlink" title="Vue的生命周期钩子"></a>Vue的生命周期钩子</h3><blockquote>
<p>每一个Vue实例在创建的时候都需要经过几个初始化步骤。比如，它需要设置data的监听器，模板的<br>编译，将实例镶嵌到DOM上，以及当data修改时更新DOM。沿着这个途径，它会调用一些生命周期的<br>钩子,以便给我们一些执行自定义逻辑的机会。比如：<code>created</code>钩子当实例创建完成后会调用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      a: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    created: function() &#123;</span><br><span class="line">      console.log(this.msg);</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    updated: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这些生命钩子调用时，他们的上下文(this)指向当前vue实例。</p>
</blockquote>
<h3 id="生命周期图"><a href="#生命周期图" class="headerlink" title="生命周期图"></a>生命周期图</h3><p><img src="/images/lifecycle.png" alt="lifecycleImg"></p>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/28/vue/get_started/" data-id="ciw3cie81003tqso0hnbtpbjh" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-phabricator/what_is_docker" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/24/phabricator/what_is_docker/" class="article-date">
  <time datetime="2016-11-23T16:23:08.071Z" itemprop="datePublished">2016-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/development-tools/">development tools</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/24/phabricator/what_is_docker/">docker</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Docker-容器引擎"><a href="#Docker-容器引擎" class="headerlink" title="Docker(容器引擎)"></a>Docker(容器引擎)</h3><blockquote>
<p>docker是一个开源的可以运行任何app的轻量级的容器。docker容器既’hardware-agnostic(硬件不可知？)’又<br>‘platform-agnostic(平台不可知？)’.这意味着它可以运行在任何地方，在你的笔记本也行，在云平台亦可以。<br>并且不要求使用特定的语言，框架，包系统。这使得应用程序的部署，web app的规模调整，后端服务能更好的构建<br>而不依赖于特定的堆栈或提供者。<br>docker是一个开放源码的部署引擎,它是由<a href="http://web.archive.org/web/20130530031104/https://www.dotcloud.com/" target="_blank" rel="external">dotCloud</a>驱动的。</p>
</blockquote>
<h3 id="比VMs好"><a href="#比VMs好" class="headerlink" title="比VMs好"></a>比VMs好</h3><blockquote>
<p>分发应用程序及沙坑执行的常用方法是使用虚拟机。典型的VM格式有VMware的vmdk，Oracle的VirtualBox<br>亚马逊的ESC2,理论上这些格式允许每个开发者可以自动的打包应用程序到一个指定的机器以便于分发及部署。<br>实际上，几乎不会有这种情况，因为受到以下原因的制裁：</p>
<ul>
<li>Size: VMs很大，存储及移动他们不是很明智。</li>
<li>性能: 运行VMs消耗CPU和内存很大，所以在很多场景下使用它们很不明智，安装过虚拟机的我深有体会。</li>
<li>可移植性</li>
<li>以硬件为中心: VMs的设计是基于机器管理员的想法，而不是软件开发者 。因此，它提供了非常有限的<br>的工具给开发者，building, testing, running,比如，VMs提供应用程序的版本控制，监控，配置，<br>日志记录等等。<br>相比之下，Docker依赖于一种不同于集装箱化的沙盒方法，不像传统的虚拟化，集装箱化发生在内核<br>级别。Docker容器非常小，几乎0内存0cpu消耗，可完全移植，并且是以程序为中心设计而设计的。<br>也许最重要的是，Docker可以在操作系统中运行，也可以在虚拟机中运行。</li>
</ul>
</blockquote>
<h3 id="Play-Well-With-Others"><a href="#Play-Well-With-Others" class="headerlink" title="Play Well With Others"></a>Play Well With Others</h3><blockquote>
<p>Docker不需要你购买特定的语言，特定的框架，特定的打包系统，特定的配置语言。<br>你的程序是Unix进程么？使用文件了么？tcp链接？环境变量？标准Unix流以及命令行参数作为输入<br>输出，在Docker都可以。</p>
</blockquote>
<h3 id="Escape-dependecy-hell-逃脱地狱依赖"><a href="#Escape-dependecy-hell-逃脱地狱依赖" class="headerlink" title="Escape dependecy hell(逃脱地狱依赖)"></a>Escape dependecy hell(逃脱地狱依赖)</h3><blockquote>
<p>一个常见的问题就是开发人员很难以一个简单自动的方式管理一个程序的所有依赖，常见的原因有以下一些:</p>
<ul>
<li>跨平台依赖(cross-platform dependencies).现在的应用程序经常依赖系统库、二进制文件、特定语言包，<br>特定的框架模块、作为另外一个项目开发的内部组件等等的组合。这些依赖处在不同的”世界”并且需要不同的工具<br>而且相互之间不一定能正常的工作，所以需要尴尬的自定义集成。</li>
<li>依赖冲突.不同的应用程序有可能需要依赖一个库的不同版本。</li>
<li>自定义依赖.开发者可能需要准备应用程序依赖的一个自定义版本，一些打包工具可以处理依赖的自定义版本,<br>但是有些工具则不行，并且每种的处理方式又不同。<br>Docker让开发者在一个地方描述所有的程序依赖来轻松的解决了地狱依赖的这些常见的问题，同时精简了组装过程。<br>Docker通过运行Unix命令序列来定义一个build,在同一个容器里一个接一个的。构造命令修改了容器里的内容(经常<br>是安装新文件，新文件系统)，下一个命令修改了更多的内容等等。由于每一个命令都是基于上一个命令的结果，命令<br>执行的顺序标识依赖项。下面的是一个典型的Docker构造过程：</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:12.04</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y python python-pip curl</span><br><span class="line">RUN curl -sSL https://github.com/shykes/helloflask/archive/master.tar.gz | tar -xzv</span><br><span class="line">RUN cd helloflask-master &amp;&amp; pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Docker不关心依赖的构建关系，只要他们可以在容器中可以通过Unix命令构建。</p>
</blockquote>
<h3 id="ToDo（入门）"><a href="#ToDo（入门）" class="headerlink" title="ToDo（入门）"></a>ToDo（入门）</h3>
      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/24/phabricator/what_is_docker/" data-id="ciw3cie4p002nqso058sqmrkv" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-phabricator/eslint" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/21/phabricator/eslint/" class="article-date">
  <time datetime="2016-11-21T15:42:13.212Z" itemprop="datePublished">2016-11-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/development-tools/">development tools</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/21/phabricator/eslint/">eslint</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Why-We-Need-Eslint"><a href="#Why-We-Need-Eslint" class="headerlink" title="Why We Need Eslint?"></a>Why We Need Eslint?</h3><blockquote>
<p>在团队配合中，有的人是Mac开发，有的人是Windows来发，使用Eslint来强制开发人员统一代码<br>格式，比如常见的<code>tab</code>以及空格,以及windows和Mac的回车标识，也可强制开发人员删除无用的<br>垃圾代码，比如<code>alert(1212), console.log(111)</code>等等，或者条件语句中使用<code>if(true){}</code>,<br>总之它就是用来检测开发人员代码书写规范的一个集成工具。so beautiful!</p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/21/phabricator/eslint/" data-id="ciw3cie4a002iqso0equwfkn4" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/movitation_design" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/17/vue/movitation_design/" class="article-date">
  <time datetime="2016-11-17T11:43:37.495Z" itemprop="datePublished">2016-11-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/17/vue/movitation_design/">了解Vue</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>vue是一个用来构建交互式web界面的库。它的核心集中于视图层，它很容易与其他库或现有的项目集成。<br>另一方面，Vue完全有能力服务员复杂的单页面应用。但是Vue和其它的框架有什么不同呢？</p>
</blockquote>
<h3 id="和React的比较"><a href="#和React的比较" class="headerlink" title="和React的比较"></a>和React的比较</h3><blockquote>
<p>React和Vue有很多相似之处:</p>
<ul>
<li>利用虚拟DOM</li>
<li>提供了reactive(反应性)和可组合的视图组件<br>在代码核心库中，保持对相关库管理的routing，全局state的关注。作用域也很相似。我们想保证的不仅<br>有技术上的准确也要确保技术的平衡，我们找出React哪里优于Vue，比如，React庞大的生态圈以及<br>自定义渲染器的丰富性。</li>
</ul>
</blockquote>
<h5 id="性能（渲染性能）"><a href="#性能（渲染性能）" class="headerlink" title="性能（渲染性能）"></a>性能（渲染性能）</h5><blockquote>
<p>Vue胜过React，当渲染UI时，DOM的操作通常是非常昂贵的，没有库可以使那些原生的操作更快，我们能做的<br>最好的就是:</p>
<ol>
<li>尽量减少必要的DOM变化的数量，React和Vue都使用了虚拟DOM来解决这个问题。</li>
<li>尽可能在顶层的DOM操作上添加较小的开销(纯js计算)，这里是React和Vue的区别。<br>javascript开销和计算必要的DOM操作机制有直接关系，Vue和React都利用虚拟DOM来达到它，但是Vue的实现更<br>轻量级，因此比React的开销更少。<br>React和Vue都提供了功能组件，他们是stateless，instanceless的因此需要的开销很少。当它们用于性能关键<br>的场景中，Vue更快，为了证明这个，我们渲染1万个item100次，强烈建议自己实践，因为它和软件、浏览器相关。<br>相关比较如下:</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                  Vue       React</span><br><span class="line">Fatest            23ms      63ms</span><br><span class="line">Mediam            42ms      81ms</span><br><span class="line">Average           51ms      94ms</span><br><span class="line">95thPerc.         73ms      164ms</span><br><span class="line">Slowest           343ms     453ms</span><br></pre></td></tr></table></figure>
<h5 id="更新性能"><a href="#更新性能" class="headerlink" title="更新性能"></a>更新性能</h5><blockquote>
<p>在React中，当一个组件的state改变了，它会触发整个组件的sub-tree的重新渲染，为了避免child组件不必要<br>的渲染，你需要在该组件中使用<code>shouldComponentUpdate</code>并定义不变的结构，而在Vue中，在渲染过程中，会自<br>动的追踪组件的依赖项，所以系统会精确的知道哪个组件需要正真的重新渲染。这就意味着未优化的Vue比未优化的<br>React要快。由于Vue的加强了渲染性能，即使React进行了全部的优化操作，通常也比Vue慢。</p>
</blockquote>
<h5 id="在开发过程中"><a href="#在开发过程中" class="headerlink" title="在开发过程中"></a>在开发过程中</h5><blockquote>
<p>虽然在生产环境中的性能指标是非常重要的，因为这和用户体验相关联。但是在开发时的性能仍然重要，因为这与<br>我们开发者相关联.<br>Vue和React在大多数程序中开发可以保持足够快速。但是，在高帧速率的可视化或动画时，Vue每秒处理10帧，而<br>React每秒只有1帧。这是因为在开发环境中React需要检查大量的不变量，这是用来提示一些重要的错误或警告用的。<br>当然在Vue中也是同意这是很重要的，但是当执行这些检查时，我们对性能保持密切关注。</p>
</blockquote>
<h5 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML &amp; CSS"></a>HTML &amp; CSS</h5><blockquote>
<p>在React中，所有的东西是javascript，虽然听起来很简单且高雅但是当你向下挖掘时，在javascript中写HTML和CSS，<br>当解决问题时，会很痛苦。而在Vue中，我们信奉web的技术并将它们，将css写在html顶部。</p>
<p>####### JSX vs Templates<br>在React中，所有的组件在JSX中来表示他们的UI，下面是个例子:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  let &#123; items &#125; = this.props</span><br><span class="line">  let children</span><br><span class="line">  if (items.length &gt; 0) &#123;</span><br><span class="line">    children = (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;items.map(item =&gt;</span><br><span class="line">          &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    children = &lt;p&gt;No items found.&lt;/p&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&apos;list-container&apos;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JSX有以下优点：</p>
<ul>
<li>使用编程语言（js）构建你的视图。</li>
<li>在某些方式下，对JSX的工具支持比vue的模板更先进。<br>在Vue中，我们有<code>render functions</code>甚至还有支持<code>jsx</code>。</li>
</ul>
</blockquote>
<h3 id="HTML-amp-CSS-1"><a href="#HTML-amp-CSS-1" class="headerlink" title="HTML &amp; CSS"></a>HTML &amp; CSS</h3><blockquote>
<p>在Vue中，有渲染器函数并且支持<code>jsx</code>,默认情况下，我们提供模板作为选择方案:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;list-container&quot;&gt;</span><br><span class="line">    &lt;ul v-if=&quot;items.length&quot;&gt;</span><br><span class="line">      &lt;li v-for=&quot;item in items&quot;&gt;</span><br><span class="line">        &#123;&#123; item.name &#125;&#125;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;p v-else&gt;No items found.&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它的优势：</p>
<ul>
<li>模板中有少量的实现并且代码风格优雅</li>
<li>模板一直是称述性质的</li>
<li>任何有效的HTML在模板中也是有效的</li>
<li>读起来很像英语</li>
<li>不需要再高版本的javascript中增加可读性。<br>另外一个好处就是你可以使用预处理器处理<code>HTML-compliant</code>模板，比如Pug书写你的Vue模板:</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.list-container</span><br><span class="line">  ul(v-if=&quot;items.length&quot;)</span><br><span class="line">    li(v-for=&quot;item in items&quot;) &#123;&#123; item.name &#125;&#125;</span><br><span class="line">  p(v-else) No items found.</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Component-Scoped CSS（组件范围的CSS）</strong><br>除非你的组件分布在多个文件中（比如CSS Modules），范围性的CSS在React中通常是在js中。而在<br>Vue中，你完全可以在单个文件中访问到CSS：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">  @media (min-width: 250px) &#123;</span><br><span class="line">    .list-container:hover &#123;</span><br><span class="line">      background: orange;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>scoped</code>属性自动的对组件范围内的元素通过添加一个唯一的属性来编译。</p>
</blockquote>
<h3 id="规模"><a href="#规模" class="headerlink" title="规模"></a>规模</h3><blockquote>
<p>React社区在状态管理上引入了<code>flux/redux</code>,状态管理方式可以在Vue很容易的集成进来。但是尽管<br>如此，React的生态圈还是要比Vue丰富。Vue提供了一个十分简单生成Vue项目的<a href="https://github.com/vuejs/vue-cli" target="_blank" rel="external">命令行工具</a>。</p>
</blockquote>
<h3 id="Scaling-Down"><a href="#Scaling-Down" class="headerlink" title="Scaling Down"></a>Scaling Down</h3><blockquote>
<p>React的学习曲线比较陡峭，在你学习之前你需要了解JSX以及ES2015.Vue中可以简单的通过在html引入vue库<br>来使用vue，React也行啊！！！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Native-Rendering"><a href="#Native-Rendering" class="headerlink" title="Native Rendering"></a>Native Rendering</h3><blockquote>
<p>React Native可以已React组件的形式写原生的IOS、Android程序，在这方面，Vue已经与<a href="https://alibaba.github.io/weex/" target="_blank" rel="external">Weex</a>合作了。<br>Weex是由阿里巴巴开发的一个跨平台UI框架，这意味着使用Weex，你可以以Vue的组件语法规则开发出的程序可以在浏览器，IOS，Android运行。<br>额，这点我承认确实比react-native强悍啊。。。。，当然Weex正在活跃的开发，和react-native一样不成熟。但是Vue和Weex合作开发啊，选择<br>React社区还是选择Vue社区呢？如果Weex和Vue成熟稳定的话选择Vue生态圈我觉得还是不错的。</p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/17/vue/movitation_design/" data-id="ciw3cie8b003xqso0sb7a0krr" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-phabricator/install_phabricator" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/16/phabricator/install_phabricator/" class="article-date">
  <time datetime="2016-11-16T14:15:53.637Z" itemprop="datePublished">2016-11-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/development-tools/">development tools</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/16/phabricator/install_phabricator/">phbricator的安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Phabricator"><a href="#Phabricator" class="headerlink" title="Phabricator"></a>Phabricator</h3><blockquote>
<p>Phabricator是一个开发软件工具的集成，包含任务管理，代码review，管理git,svn等等,持续集成的构建，<br>内部通道的讨论等等。</p>
</blockquote>
<h3 id="在我们局域网内安装phabricator"><a href="#在我们局域网内安装phabricator" class="headerlink" title="在我们局域网内安装phabricator"></a>在我们局域网内安装phabricator</h3><blockquote>
<p>Phabricator是一个LAMP应用程序，所以:</p>
<ul>
<li>一台linux或Mac OS电脑。(ps: windows不行奥，因为一些命令行在windows无法执行。。。)</li>
<li>一个域名(可有可无，在内网上访问就行了，除非你需要家里办公也访问)(格式:phabricator.xxxxx.com).</li>
<li>一些基本的系统管理员的技能(linux命令得熟悉啊！)</li>
<li>一个web容器，Apache或Nginx（常用的两种方式）</li>
<li>PHP(version: &gt;= 5.2, 版本7不支持), MySql(version: &gt;= 5.5), git.<br>系统管理员应该会的一些技能（也就是linux的一些指令）,比如：在操作系统安装软件，文件系统的操作，进程<br>的管理，权限的处理，修改配置文件，设置环境变量等等。</li>
</ul>
</blockquote>
<h3 id="安装需要的组件"><a href="#安装需要的组件" class="headerlink" title="安装需要的组件"></a>安装需要的组件</h3><blockquote>
<ul>
<li>git(在包管理系统中一般称为’git’)</li>
<li>Apache(一般称为”httpd”或”apache2”)或者nginx</li>
<li>MySQL Server(一般是”mysqlId”或”mysql-server”)</li>
<li>PHP(一般是”php”)</li>
<li>需要的PHP扩展，比如”php-mysql”, “php5-mysql”<br>如果已经安装好了这些，那么获取Phrbricator以及它的依赖:</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//选择你要安装的文件夹，并在该文件夹下执行以下命令</span><br><span class="line">git clone https://github.com/phacility/libphutil.git</span><br><span class="line">git clone https://github.com/phacility/arcanist.git</span><br><span class="line">git clone https://github.com/phacility/phabricator.git</span><br></pre></td></tr></table></figure>
<blockquote>
<p>APC是建议安装的，所以没有深究。</p>
</blockquote>
<h3 id="Apache容器的配置"><a href="#Apache容器的配置" class="headerlink" title="Apache容器的配置"></a>Apache容器的配置</h3><blockquote>
<ul>
<li>配置web容器(Apache, nginx)</li>
<li>在浏览器访问phabricator<br>Apache的httpd.conf</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *&gt;</span><br><span class="line">  # Change this to the domain which points to your host.</span><br><span class="line">  ServerName phabricator.example.com</span><br><span class="line"></span><br><span class="line">  # Change this to the path where you put &apos;phabricator&apos; when you checked it</span><br><span class="line">  # out from GitHub when following the Installation Guide.</span><br><span class="line">  #</span><br><span class="line">  # Make sure you include &quot;/webroot&quot; at the end!</span><br><span class="line">  DocumentRoot /path/to/phabricator/webroot</span><br><span class="line">  RewriteEngine on</span><br><span class="line">  RewriteRule ^(.*)$          /index.php?__path__=$1  [B,L,QSA]</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果Apache的配置文件目录不是Phabricator的目录，那么你需要添加<code>&lt;Directory /&gt;</code>块，这个块<br>标示依赖于你的Apache的版本，通过运行<code>httpd -v</code>得到当前运行Apache的版本，如果版本号小于2.4,</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot;/path/to/phabricator/webroot&quot;&gt;</span><br><span class="line">  Order allow,deny</span><br><span class="line">  Allow from all</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果大于2.4:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot;/path/to/phabricator/webroot&quot;&gt;</span><br><span class="line">  Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置完成之后，请重启Apache，并继续接下来的配置.</p>
</blockquote>
<h3 id="Nginx的配置"><a href="#Nginx的配置" class="headerlink" title="Nginx的配置"></a>Nginx的配置</h3><blockquote>
<p>nginx.conf:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  server_name phabricator.example.com;</span><br><span class="line">  #你的phabricator安装目录</span><br><span class="line">  root        /path/to/phabricator/webroot;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    index index.php;</span><br><span class="line">    rewrite ^/(.*)$ /index.php?__path__=/$1 last;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location /index.php &#123;</span><br><span class="line">    fastcgi_pass   localhost:9000;</span><br><span class="line">    fastcgi_index   index.php;</span><br><span class="line"></span><br><span class="line">    #required if PHP was built with --enable-force-cgi-redirect</span><br><span class="line">    fastcgi_param  REDIRECT_STATUS    200;</span><br><span class="line"></span><br><span class="line">    #variables to make the $_SERVER populate in PHP</span><br><span class="line">    fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;</span><br><span class="line">    fastcgi_param  QUERY_STRING       $query_string;</span><br><span class="line">    fastcgi_param  REQUEST_METHOD     $request_method;</span><br><span class="line">    fastcgi_param  CONTENT_TYPE       $content_type;</span><br><span class="line">    fastcgi_param  CONTENT_LENGTH     $content_length;</span><br><span class="line"></span><br><span class="line">    fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;</span><br><span class="line"></span><br><span class="line">    fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;</span><br><span class="line">    fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;</span><br><span class="line"></span><br><span class="line">    fastcgi_param  REMOTE_ADDR        $remote_addr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置完成之后重启nginx，并继续接下来的配置</p>
</blockquote>
<h3 id="配置Mysql"><a href="#配置Mysql" class="headerlink" title="配置Mysql"></a>配置Mysql</h3><blockquote>
<p>当MySQL运行时，需要加载Phabricator的schemata，所以要在phabricator目录下执行:<code>./bin/storage upgrade</code><br>如果你配置的用户不是连接数据库的特权用户，所以需要覆盖默认的用户，所以更改schema，通过一下命令更改<br><code>./bin/storage upgrade --user &lt;user&gt; --password &lt;password&gt;</code>并且<code>./bin/storage upgrade --force</code><br><strong>注意：</strong>当修改了phabricator后，运行<code>storage upgrade</code>来应用新的修改。</p>
</blockquote>
<h3 id="配置账号及注册"><a href="#配置账号及注册" class="headerlink" title="配置账号及注册"></a>配置账号及注册</h3><blockquote>
<p>phabricator提供了很多的登录体系，你可以配置谁可以访问或者注册你安装的phabricator以及用户用存在的账号登录phabricator。<br>登录方式称之为授权给予，比如可用的”用户名/密码”授权，允许你通过传统的用户名密码登录，其余的支持用证书登录。比如:</p>
<ul>
<li><strong>用户名密码：</strong>使用用户名密码登录注册</li>
<li><strong>LDAP：</strong>使用LDAP证书登录注册</li>
<li><strong>OAuth：</strong>用户使用支持OAuth2的协议登录，比如(Facebook,Google,GitHub)</li>
<li><strong>其余的提供程序：</strong>有许多可用的支持，Phabricator可以扩展，相关知识请自行了解。<br>默认情况下，没有可用的提供程序，你必须在安装完成之后使用”Auth”程序添加一种或多种提供程序。在你添加供应程序之后，<br>你可以使用存在的账号连接phabricator（比如你可以使用GitHub的OAuth账号登录Phabricator）或者用户使用它注册新的账<br>号（假设你启用这些选项）<br><strong>恢复管理员账号</strong>如果你意外的在phabrication中锁住了，你可以使用<code>bin/auth</code>脚本恢复管理员账号的访问，恢复访问，请使用:<br><code>./bin/auth recover &lt;username&gt;</code>,username是你想恢复的管理员的账号。<br><strong>通过web页面管理账号</strong>使用管理员账号登录phabricator并路由到<code>/people</code>,点击”People”,如果你是管理员，你可以看见创建<br>及修改账号的选项。<br><strong>手动的创建新账号</strong>，有两种手工创建账号的方式，一种是通过web网页另一种是通过命令行，<code>./bin/accountadamin</code>,一些选项<br>(如设置密码，更改账号标记)只能在命令行中可见。你可以使用此命令来使一个用户成为管理员（比如你意外的移除了你管理员的标记）<br>或者创建一个管理员账号。</li>
</ul>
</blockquote>
<h3 id="TODO-配置文件存储"><a href="#TODO-配置文件存储" class="headerlink" title="TODO(配置文件存储)"></a>TODO(配置文件存储)</h3><h3 id="TODO-配置邮件发送"><a href="#TODO-配置邮件发送" class="headerlink" title="TODO(配置邮件发送)"></a>TODO(配置邮件发送)</h3>
      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/16/phabricator/install_phabricator/" data-id="ciw3cie4m002kqso0ifwa5c6w" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-react/internal_instance" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/16/react/internal_instance/" class="article-date">
  <time datetime="2016-11-15T16:59:33.447Z" itemprop="datePublished">2016-11-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React/">React</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/16/react/internal_instance/">内部实例的伪实现（思考）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>为什么需要内部实例呢?<br>React的主要特性是你可以重新渲染任何东西，并且你不会重复创建DOM以及重置state.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;App /&gt;, rootEl);</span><br><span class="line">//下面这一行会重新使用已存在的DOM</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, rootEl);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当组件需要更新时，如何存储必要的信息呢？比如说<code>publicInstances</code>,DOM元素与组件之间的关系。<br>堆栈协调器代码库通过在类中加了一个<code>mount()</code>函数解决这个问题，这种方式有点缺点，正在改进。<br>把<code>mountHost()</code>和<code>mountComposite()</code>分离出来的替代方案是创建了两个类<code>DOMComponent</code>和<code>CompositeComponent</code><br>这两个类都有一个接收<code>element</code>的构造函数，当然还有一个<code>mount()</code>方法返回已镶嵌的节点，用一个工厂方法实例化正确的<br>class来替代顶级<code>mount()</code>方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function instantiateComponent(element) &#123;</span><br><span class="line">  var type = element.type;</span><br><span class="line">  if(typeof type === &apos;function&apos;) &#123;</span><br><span class="line">    return new CompositeComponent(type);</span><br><span class="line">  &#125;else if(typeof type === &apos;string&apos;) &#123;</span><br><span class="line">    return new DOMComponent(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CompositeComponent(复杂组件)的实现:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class CompositeComponent &#123;</span><br><span class="line">  constructor(element) &#123;</span><br><span class="line">    this.currentElement = element;</span><br><span class="line">    this.renderedComponent = null;</span><br><span class="line">    this.publicInstance = null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getPublicInstance() &#123;</span><br><span class="line">    // For composite components, expose the class instance.</span><br><span class="line">    return this.publicInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mount() &#123;</span><br><span class="line">    var element = this.currentElement;</span><br><span class="line">    var type = element.type;</span><br><span class="line">    var props = element.props;</span><br><span class="line"></span><br><span class="line">    var publicInstance;</span><br><span class="line">    var renderedElement;</span><br><span class="line">    if (isClass(type)) &#123;</span><br><span class="line">      // Component class</span><br><span class="line">      publicInstance = new type(props);</span><br><span class="line">      // Set the props</span><br><span class="line">      publicInstance.props = props;</span><br><span class="line">      // Call the lifecycle if necessary</span><br><span class="line">      if (publicInstance.componentWillMount) &#123;</span><br><span class="line">        publicInstance.componentWillMount();</span><br><span class="line">      &#125;</span><br><span class="line">      renderedElement = publicInstance.render();</span><br><span class="line">    &#125; else if (typeof type === &apos;function&apos;) &#123;</span><br><span class="line">      // Component function</span><br><span class="line">      publicInstance = null;</span><br><span class="line">      renderedElement = type(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Save the public instance</span><br><span class="line">    this.publicInstance = publicInstance;</span><br><span class="line"></span><br><span class="line">    // Instantiate the child internal instance according to the element.</span><br><span class="line">    // It would be a DOMComponent for &lt;div /&gt; or &lt;p /&gt;,</span><br><span class="line">    // and a CompositeComponent for &lt;App /&gt; or &lt;Button /&gt;:</span><br><span class="line">    var renderedComponent = instantiateComponent(renderedElement);</span><br><span class="line">    this.renderedComponent = renderedComponent;</span><br><span class="line"></span><br><span class="line">    // Mount the rendered output</span><br><span class="line">    return renderedComponent.mount();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>DOMComponent</code>类的实现:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class DOMComponent &#123;</span><br><span class="line">  constructor(element) &#123;</span><br><span class="line">    this.currentElement = element;</span><br><span class="line">    this.renderedChildren = [];</span><br><span class="line">    this.node = null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getPublicInstance() &#123;</span><br><span class="line">    // For DOM components, only expose the DOM node.</span><br><span class="line">    return this.node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mount() &#123;</span><br><span class="line">    var element = this.currentElement;</span><br><span class="line">    var type = element.type;</span><br><span class="line">    var props = element.props;</span><br><span class="line">    var children = props.children || [];</span><br><span class="line">    if (!Array.isArray(children)) &#123;</span><br><span class="line">      children = [children];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Create and save the node</span><br><span class="line">    var node = document.createElement(type);</span><br><span class="line">    this.node = node;</span><br><span class="line"></span><br><span class="line">    // Set the attributes</span><br><span class="line">    Object.keys(props).forEach(propName =&gt; &#123;</span><br><span class="line">      if (propName !== &apos;children&apos;) &#123;</span><br><span class="line">        node.setAttribute(propName, props[propName]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Create and save the contained children.</span><br><span class="line">    // Each of them can be a DOMComponent or a CompositeComponent,</span><br><span class="line">    // depending on whether the element type is a string or a function.</span><br><span class="line">    var renderedChildren = children.map(instantiateComponent);</span><br><span class="line">    this.renderedChildren = renderedChildren;</span><br><span class="line"></span><br><span class="line">    // Collect DOM nodes they return on mount</span><br><span class="line">    var childNodes = renderedChildren.map(child =&gt; child.mount());</span><br><span class="line">    childNodes.forEach(childNode =&gt; node.appendChild(childNode));</span><br><span class="line"></span><br><span class="line">    // Return the DOM node as mount result</span><br><span class="line">    return node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果是，每一个内部实例都不论是复合型的还是平台特有的，都指向他的child的内部实例，比如:<br><code>&lt;App&gt;</code>组件渲染了一个<code>&lt;Button&gt;</code>,<code>&lt;Button&gt;</code>渲染了一个<code>&lt;div&gt;</code>,内部实例树将是下面的样子:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[object CompositeComponent] &#123;</span><br><span class="line">  currentElement: &lt;App /&gt;,</span><br><span class="line">  publicInstance: null,</span><br><span class="line">  renderedComponent: [object CompositeComponent] &#123;</span><br><span class="line">    currentElement: &lt;Button /&gt;,</span><br><span class="line">    publicInstance: [object Button],</span><br><span class="line">    renderedComponent: [object DOMComponent] &#123;</span><br><span class="line">      currentElement: &lt;div /&gt;,</span><br><span class="line">      node: [object HTMLDivElement],</span><br><span class="line">      renderedChildren: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在DOM中只看见<code>&lt;div&gt;</code>,但是内部实例可以包含混合型及平台特有的内部实例二者。混合型内部实例<br>需要存储:</p>
<ul>
<li>当前元素</li>
<li>如果元素类型是类，则包含公共实例</li>
<li>单独的渲染的内部实例，既可以是<code>DOMComponent</code>,也可以是<code>CompositeComponent</code>.<br>平台特有内部实例需要存储:</li>
<li>当前元素</li>
<li>DOM节点</li>
<li>所有的子内部实例，它们既可以是<code>DOMComponent</code>也可以是<code>CompositeComponent</code>.</li>
</ul>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/16/react/internal_instance/" data-id="ciw3cie5m0030qso0bja7p972" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-react/design_principles" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/15/react/design_principles/" class="article-date">
  <time datetime="2016-11-14T16:00:36.545Z" itemprop="datePublished">2016-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React/">React</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/15/react/design_principles/">设计原则</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>我们写这篇文章的目的是为了让你对React有一个更好的认知，什么能做和什么不能做以及React的设计理念<br>虽然我们很乐意看到社区的贡献，但是我们也不希望悠然违反一些原则。<br>注意：这篇文章是假设你对React有一个很深的理解，它描述了React的设计原则，而不是React组件及程序<br>对React的简介请阅读<a href="https://facebook.github.io/react/docs/thinking-in-react.html" target="_blank" rel="external">Thinking in React</a></p>
</blockquote>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><blockquote>
<p>React的主要特性是组建的组成，不同人编写的组件可以一起更好的工作，你可以给一个组件添加功能而不会影响整个代码库的更改.<br>比如：在一个组件中引入一些本地state而不会对使用它的组件造成影响。同样，如果有必要可以添加初始化以及拆卸的代码到任何组件中。<br>在组建中使用state或生命周期挂钩也不是坏的，比如一些功能强大的特性，它们应该有节制的使用，但是我们没有移除它们的打算，相反的，<br>我们认为他们是使得的React更有用的组成部分。我们将来会使更多的<a href="https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State" target="_blank" rel="external">功能模式</a><br>但是，本地state和生命周期挂钩将为该模型的一部分。<br>组件经常被描述为’just functions’,但是在我们的视角中，他们需要变得更加有用，在React中，组件描述了任何组成的行为，包括rendering<br>生命周期，以及state，一些外部的库，像Relay增加组件了其他的责任，比如描述data依赖。</p>
</blockquote>
<h3 id="Common-Abstraction（通用的抽象）"><a href="#Common-Abstraction（通用的抽象）" class="headerlink" title="Common Abstraction（通用的抽象）"></a>Common Abstraction（通用的抽象）</h3><blockquote>
<p>通常情况下我们抵制在用户级就可以实现的行为，我们不想用无用的库膨胀你的应用，但是也有些例外，比如：如果React对本地state和生命周期<br>挂钩不提供支持，用户会创建通用抽象给他们，当有多个抽象竞争时React不能充分利用他们的属性执行，它不得不以最低的标准工作。这也是为什么<br>我们有时会给React添加一些特性，如果我们注意到许多组件不兼容或低效的执行某些功能，我们可能更愿意考到React。我们不会轻易的干这件事。<br>当我们做它时，因为我们有信心提高抽象层次使整个生态系统受益。state，生命周期挂钩跨浏览器事件正常化是个很好的例子。我们经常与社区讨论<br>改善建议，你可以在<a href="https://github.com/facebook/react/issues?q=is%3Aopen+is%3Aissue+label%3A%22big+picture%22" target="_blank" rel="external">big picture</a>中找到这些讨论</p>
</blockquote>
<h3 id="Escape-Hatches-逃生舱口"><a href="#Escape-Hatches-逃生舱口" class="headerlink" title="Escape Hatches(逃生舱口)"></a>Escape Hatches(逃生舱口)</h3><blockquote>
<p>React是实用主义的，它是由写Facebook的产品需求而驱动的，虽然它受一些范例的影响，但也不是完全主流。比如，函数式编程，对不同技能的开发<br>保持可访问是项目的一个明确的目标。如果我们想反对一个我们不喜欢的模式，在反对它之前我们考虑所有存在的场景。如果一些模式对于构建app和有用<br>但是很难表达，我们会为它提供必要的API。</p>
</blockquote>
<h3 id="Stability-稳定性"><a href="#Stability-稳定性" class="headerlink" title="Stability(稳定性)"></a>Stability(稳定性)</h3><blockquote>
<p>我们重视API的稳定性，Facebook有两万个组件在使用React，这也是我们为什么通常不愿意改变公共API或行为。但是”nothing changes”稳定性的意义有点被<br>高估了,它迅速停滞了。相反，我们更喜欢”在生产环境大量使用并且一些东西变化时有一个明确的迁移路径”的稳定意义。当我们反对一种形式时，我们在Facebook研究<br>它的内部使用并添加反对警告。这让我们评估改变的重大影响。有时，我们发现它太简单的话我们会退出，并且我们需要战略性的思考关于这次改动代码库的要点是否准备好。<br>如果我们自行这次的更改不是太具有破坏性并且此次战略性转移对用户场景是可实施的，我们会在社区中释放反对警告。我们会和外部使用React的用户密切联系并且我们会<br>监视流行的开源项目并指引他们修理这些警告。由于React代码库规模庞大，内部迁移成功是一个很好的指标并且其余公司也不会有问题。</p>
</blockquote>
<h3 id="Scheduling-时间表-进度表"><a href="#Scheduling-时间表-进度表" class="headerlink" title="Scheduling(时间表 进度表)"></a>Scheduling(时间表 进度表)</h3><blockquote>
<p>在React中即使你的组件被描述为函数，你也不能直接调用它们。每一个组件返回一个<a href="https://facebook.github.io/react/contributing/design-principles.html" target="_blank" rel="external">需要渲染什么的描述</a><br>并且这个描述包括用户自定义组件及主机组件。通过组件的递归得到render结果去更改UI树。这是一个不明显但是很强大的区别，因为你不会调用组件函数但是让React自己调用.<br>这意味着如果有必要React有权延迟调用它。在当下的实现中，在单个刻度期间，React递归的走着树并调用所有的要修改的树的render函数。在反应的设计中这是一个共同的主题，<br>一些流行的库实现的是”push”方法，当新数据可用时再执行计算。然而React坚持”pull”方法，计算会被推迟，除非有必要。<br>React不是一个普通的数据处理库，它是用来构建用户界面的。我们认为在app中有独特的优势，因为它知道哪些计算是有意义的哪些没有。如果有些多东西在屏幕外，我们可以<br>延迟它的数据逻辑处理,如果数据到达的速度快于frame的速度，我们可以批量更新，我们可以优先考虑用户交互的工作（点击button的动画效果）来避免dropping frame，<br>不太重要的(从网络获取数据)后台工作</p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/15/react/design_principles/" data-id="ciw3cie56002rqso0se4p6w0s" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          
            <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Canvas/">Canvas</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Electron/">Electron</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Http/">Http</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Redux/">React Redux</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Webpack/">Webpack</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/development-tools/">development tools</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget recents">
      <ul>
        
          <li>
            <a href="/2016/11/29/vue/style_class_binding/">样式绑定</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/computed_properties/">Vue属性的计算及监听器</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/template_syntax/">Vue模板语法</a>
          </li>
        
          <li>
            <a href="/2016/11/28/vue/get_started/">Vue纵览</a>
          </li>
        
          <li>
            <a href="/2016/11/24/phabricator/what_is_docker/">docker</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">我的文章</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
</aside>
          
        
      </div>
      <!--<div id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a></br>
      &copy; 2016 zhuxin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</div>-->
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">我的文章</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>