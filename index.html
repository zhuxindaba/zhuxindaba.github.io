<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="zhuxin">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="zhuxin_blog"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="zhuxin_blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>zhuxin_blog</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">zhuxin_blog</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/11/01/front_end/react/react-redux/">
                redux
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-11-01</span>
            
            
            
                <span class="category">
                    <a href="/categories/React-Redux/">React Redux</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="为什么要用react-redux"><a href="#为什么要用react-redux" class="headerlink" title="为什么要用react-redux?"></a>为什么要用react-redux?</h3><blockquote>
<p>在单页应用中,服务器的相应,UI状态,缓存数据,被选中的标签,是否加载动画效果等等这些都可以理解为state,当应用变得庞<br>大复杂时传统的javascript代码处理这些状态 ,只会让维护变得更加困难,而用redux的原因就是将应用程序中的state的变化变得<br>可预测</p>
</blockquote>
<h3 id="redux的三大原则"><a href="#redux的三大原则" class="headerlink" title="redux的三大原则"></a>redux的三大原则</h3><ol>
<li>单一的store,整个应用的state存放在一个object tree中,并且这个store是唯一的</li>
<li><p>state是只读的,唯一改变state的方法就是触发action,action就是一个描述你要干什么的js对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var actionName = &#123;</span><br><span class="line">	type: typeName,//必须为type表示你将要执行什么动作,</span><br><span class="line">	desc: &apos;&apos;	//自己定义，你将希望通过这个动作告知其余组建通过这个动作发生的事</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用reducer修改state,reducer是一个纯函数,它接收的参数为先前的state和将要执行的action,并返回新的state</p>
</li>
</ol>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Action是把数据从应用中传到store的有效载荷,它是store数据的唯一来源,一般通过<code>store.dispatch( {type: &#39;xx&#39;, desc: &#39;xx&#39;} )</code>将action传到store</p>
<h3 id="ActionCreator"><a href="#ActionCreator" class="headerlink" title="ActionCreator"></a>ActionCreator</h3><p>ActionCreator就是生成action对象的函数,返回一个action对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function addTodo(text) &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		type: &apos;ADD_TODO&apos;,</span><br><span class="line">		text</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>在store里调用action创建函数: <code>store.dispatch(addTodo(&#39;learn redux&#39;))</code><br>在React组建中如何调用呢？需要用到react-redux中提供的connect()(ComponentName)将dispatch函数注入到组建的props中然后通过<br><code>this.props.dispatch(addTodo(text))</code>调用<br>bindActionCreators()待定</p>
<hr>
<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>Action只是描述了事件发生了而已,但是并没有指明应用如何更新state,而更新state正是reducer做的事情。    </p>
<h6 id="设计state的结构"><a href="#设计state的结构" class="headerlink" title="设计state的结构"></a>设计state的结构</h6><p>在redux应用中,所有的state都被保存在一个单一对象中。reducer就是一个函数,接收旧的state和action,返回新的state.<br>不要在reducer里做以下操作:    </p>
<ol>
<li>修改传入参数</li>
<li>执行有副作用的操作,如API请求和路由跳转  </li>
<li>调用非纯函数,如Date.norw()或Math.random(),每个reducer只负责全局state中它负责的一部分。每个reducer的state<br>参数都不同，分别对应它管理的那部分的state数据,combineReducers()所做的只是生成一个函数,这个函数来调用你的一系列<br>reducer，每个reducer根据它们的key来筛选出state中的一部分数据并处理,然后这个生成函数将所有reducer的结果合并成一个大的对象。</li>
</ol>
<hr>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>action用来描述发生了什么，使用reducer根据action更新state，Store就是将它们联系到一起的对象,Store的职责:    </p>
<ol>
<li>维持应用程序的state    </li>
<li>提供getState()获取state    </li>
<li>提供dispatch(action)方法更新state    </li>
<li>提供subscribe(listener)注册监听器<br>Redux应用中只有唯一的一个store,通过redux的createStore(reducers, initialState)创建store<br>createStore()的第二个参数用来设置初始状态    </li>
</ol>
<hr>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>严格的单项数据流是redux架构的设计核心,Redux应用中数据的生命周期遵循下面4个步骤:   </p>
<ol>
<li>调用store.dispatch(action),你可以在任何地方调用store.dispatch(action),组件中，定时器中    </li>
<li>Redux store调用传入的reducer函数.Store会把连个参数传入reducer：当前的state树和action。<br>reducer是一个纯函数。它仅仅用于计算下一个state。它应该是完全可以预测的：多次传入相同的输入<br>必须产生相同的输出。它不应该做有副作用的操作，如API调用或路由跳转。这些应该在dispatch action前发生    </li>
<li>根reducer应该用combineReducers()把多个reducer输出合并成单一的一个state树<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function todos(state=[], action) &#123;</span><br><span class="line">	//...</span><br><span class="line">	return nextState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function visibleTodoFilter(state=&apos;SHOW_ALL&apos;, action) &#123;</span><br><span class="line">	//...</span><br><span class="line">	return nextState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const reducers = combineReducers(&#123;</span><br><span class="line">	todos,</span><br><span class="line">	visibleTodoFilter</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><br><br>当你触发action后，combineReducers返回的reducers会负责调用两个reducer,然后把两个结果集合并成一个state树:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return&#123;</span><br><span class="line">	todos: nextTodos,</span><br><span class="line">	visibleTodoFilter: nextVisibleTodoFilter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Redux Store保存了根reducer返回的完整的state树，这个新的树就是应用的下一个state!所有调用store.subscribe(listener)<br>的监听器都将被调用;监听器里可以调用<code>store.getState()</code>获取当前的state<br>现在，可以应用新的state来更新UI，在组建中的componentDidMount生命周期中调用<code>this.setState()</code>来更新        </li>
</ol>
<hr>
<h3 id="搭配React"><a href="#搭配React" class="headerlink" title="搭配React"></a>搭配React</h3><p>Redux和React之间没有关系。Redux支持React、Angular、jQuery甚至纯javascript    </p>
<ol>
<li>Redux的React绑定包含了容器组件和展示组件相分离的开发思想，明智的做法就是只在最顶层组件（路由操作）<br>里使用Redux。其余内部组件仅仅是展示性的，所有数据都通过props传入    </li>
<li>连接到Redux，<strong>通过react-redux提供的connect()方法将包装好的组件连接到redux</strong>。     <pre><code>**任何一个从connect()包装好的组件都可以得到一个dispatch方法作为组件的props，以及得到全局state中所需的内容**
connect()的唯一参数是selector。此方法可以从Redux store中接收到全局state，然后返回组件中需要的props
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		return(</span><br><span class="line">			//...</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//基于全局state，哪些是我们想要注入props的</span><br><span class="line">//https://github.com/reactjs/reselect这个待研究，用这个注入效果更好?</span><br><span class="line">function select(state) &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		xxx: state.xxx</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//包装component</span><br><span class="line">export default connect(select)(App);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="异步Action"><a href="#异步Action" class="headerlink" title="异步Action"></a>异步Action</h3><pre><code>前面所述的是同步action,每当dispatch action时,state会理解被更新。那么Redux如何操作异步数据流?
</code></pre><h6 id="Action-1"><a href="#Action-1" class="headerlink" title="Action"></a>Action</h6><p>当调用异步API时,有两个非常关键的时刻:发起请求的时刻,和接收响应的时刻（也可能是超时）。<br><br><br>这两个时刻都可以更改应用的state;为此，你需要dispatch普通的同步action。一般情况下，每个api请求都至少需要dispatch三个不同的action:    </p>
<ul>
<li><p><strong>一个通知reducer请求开始的action</strong><br>对于这种action,reducer可能会切换一下state中的isFeching标记.以此来告诉UI来显示进度条.    </p>
</li>
<li><p><strong>一个通知reducer请求成功结束的action</strong><br>对于这种action,reducer可能会把接收到的新数据合并到state中,并重置isFetching。UI则会隐藏进度条，并显示接收到的数据    </p>
</li>
<li><p><strong>一个通知reducer请求失败的action</strong><br>对于这种action，reducer可能会重置isFetching.或者，有些reducer会保存这些失败信息,并在UI显示出来.    </p>
</li>
</ul>
<hr>
<h3 id="异步Action-Creator"><a href="#异步Action-Creator" class="headerlink" title="异步Action Creator"></a>异步Action Creator</h3><blockquote>
<p>如何将不同的action creator和网络请求结合起来?使用Redux Thunk这个中间件,通过使用中间件，action creator除了返回action对象<br>外还乐意返回函数,当action creator返回函数时，这个函数会被Redux Thunk middleware执行。这个函数并不需要保持纯净；它可以带有<br>副作用，包括异步执行、API请求。这个函数还可以dispatch action    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//thunk action creator</span><br><span class="line">//使用方式和同步cation一样	dispatch(fetchPosts(&apos;xxx&apos;))</span><br><span class="line">export function fetchPosts(xxx) &#123;</span><br><span class="line">	//Thunk middleware知道如可处理函数</span><br><span class="line">	//这里把dispatch方法通过参数的形式传给函数，以此来让它自己也能dispatch action</span><br><span class="line"></span><br><span class="line">	return function(dispatch) &#123;</span><br><span class="line"></span><br><span class="line">		dispatch(action);</span><br><span class="line"></span><br><span class="line">		//执行api请求使用isomorphic-fetch库替代XMLHttpRequest</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br>        我们如何在dispatch机制中引入Redux Thunk middleware？使用appluMiddleware(),<strong>thunk的一个优点就是它的结果可以再次被dispatch</strong>    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//**index.js代码**</span><br><span class="line">import thunkMiddleware from &apos;react-thunk&apos;;</span><br><span class="line">import createLogger from &apos;redux-logger&apos;;</span><br><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;</span><br><span class="line"></span><br><span class="line">const createStoreWithMiddleware = applyMiddleware(</span><br><span class="line">	thunkMiddleware,	//允许我们dispatch()函数</span><br><span class="line">	createLogger</span><br><span class="line">)(createStore);</span><br><span class="line"></span><br><span class="line">const reducers = combineReducers(&#123;</span><br><span class="line">	//拆分的单个reducer函数</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const store = createStoreWithMiddleware(reducers);</span><br></pre></td></tr></table></figure>
<p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//**action.js代码**</span><br><span class="line">export function fetchPosts(xxx) &#123;</span><br><span class="line">	return (dispatch) =&gt; &#123;</span><br><span class="line">		//...</span><br><span class="line">		dispatch(action)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function fetchPostsIfNeeder(xxx) &#123;</span><br><span class="line">	//可接收getState()方法</span><br><span class="line">	return (fetch, getState) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<hr>
<h3 id="异步数据流"><a href="#异步数据流" class="headerlink" title="异步数据流"></a>异步数据流</h3><p>如果不使用middleware的话,Redux的store只支持同步数据流。而这也是createStore()所默认提供的创建方式，可以使用applyMiddleware()<br>来增强createStore(),使用redux-thunk这样支持异步的middleware都包装了store的dispatch()方法,以此让你dispatch一些除了action以外<br>的内容。<strong>当niddleware链中的最后一个middleware dispatch action 时，这个action必须是一个普通对象。</strong>    </p>
<h3 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h3><p><strong>middleware是指可以被嵌入在框架接收请求道产生相应过程之中的代码，它提供的是位于action被发起之后，到达reducer之前的扩展点</strong><br>可以利用Redux middleware来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。        </p>
<p><strong>使用Redux的一个益处就是它让state的变化过程变得可预知和透明。每当一个action发起后，新的state就会被计算保<br>存下来。state不能自身修改，只能由特定的action引起变化</strong>    </p>
<hr>
<h3 id="减少样板代码"><a href="#减少样板代码" class="headerlink" title="减少样板代码"></a>减少样板代码</h3><ul>
<li><p>Action的type用常量，可以将所有type放在一个文件中，然后引入    </p>
</li>
<li><p>Action Creators创建生成action的函数    </p>
</li>
<li><p>生产Action Creators写简单的action creator函数，尤其是数量巨大的时候，代码不易于维护，可以写一个用于生成action creator的函数：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function makeActionCreator(type, ...argNames) &#123;</span><br><span class="line">	return function(...args) &#123;</span><br><span class="line">		let action = &#123; type &#125;;</span><br><span class="line">		argNames.forEach(arg, index) &#123;</span><br><span class="line">			action[argNames[index]] = args[index];</span><br><span class="line">		&#125;</span><br><span class="line">		return action;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const ADD_TODO = &apos;ADD_TODO&apos;;</span><br><span class="line">const EDIT_TODO = &apos;EDIT_TODO&apos;</span><br><span class="line">const REMOVE_TODO = &apos;REMOVE_TODO&apos;;</span><br><span class="line"></span><br><span class="line">export const addTodo = makeActionCreator(ADD_TODO, &apos;todo&apos;);</span><br><span class="line">export const editTodo = makeActionCreator(EDIT_TODO, &apos;id&apos;, &apos;todo&apos;);</span><br><span class="line">export const removeTodo = makeActionCreator(REMOVE_TODO, &apos;id&apos;);</span><br></pre></td></tr></table></figure>
<p><strong>redux-actions可以帮助生成action creator，这个待研究</strong>    </p>
<ul>
<li>异步Action Creators<br>中间件让你在每个action对象分发出去之前，注入一个自定义的逻辑来解释你的action对象。异步action是中间件<br>最常见用例。如果没有中间件，dispatch只能接收一个普通对象。因此我们必须在components里面进行AJAX调用：    </li>
</ul>
<p><code>actions.js</code><br><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">export function loadPostsSuccess(userId, response) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;LOAD_POSTS_SUCCESS&apos;,</span><br><span class="line">    userId,</span><br><span class="line">    response</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function loadPostsFailure(userId, error) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;LOAD_POSTS_FAILURE&apos;,</span><br><span class="line">    userId,</span><br><span class="line">    error</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function loadPostsRequest(userId) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;LOAD_POSTS_REQUEST&apos;,</span><br><span class="line">    userId</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>component.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; loadPostsRequest, loadPostsSuccess, loadPostsFailure &#125; from &apos;./actionCreators&apos;;</span><br><span class="line"></span><br><span class="line">class Posts extends Component &#123;</span><br><span class="line">  loadData(userId) &#123;</span><br><span class="line">    // 调用 React Redux `connect()` 注入 props ：</span><br><span class="line">    let &#123; dispatch, posts &#125; = this.props;</span><br><span class="line"></span><br><span class="line">    if (posts[userId]) &#123;</span><br><span class="line">      // 这里是被缓存的数据！啥也不做。</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Reducer 可以通过设置 `isFetching` 反应这个 action</span><br><span class="line">    // 因此让我们显示一个 Spinner 控件。</span><br><span class="line">    dispatch(loadPostsRequest(userId));</span><br><span class="line"></span><br><span class="line">    // Reducer 可以通过填写 `users` 反应这些 actions</span><br><span class="line">    fetch(`http://myapi.com/users/$&#123;userId&#125;/posts`).then(</span><br><span class="line">      response =&gt; dispatch(loadPostsSuccess(userId, response)),</span><br><span class="line">      error =&gt; dispatch(loadPostsFailure(userId, error))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.loadData(this.props.userId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    if (nextProps.userId !== this.props.userId) &#123;</span><br><span class="line">      this.loadData(nextProps.userId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.props.isLoading) &#123;</span><br><span class="line">      return &lt;p&gt;Loading...&lt;/p&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let posts = this.props.posts.map(post =&gt;</span><br><span class="line">      &lt;Post post=&#123;post&#125; key=&#123;post.id&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return &lt;div&gt;&#123;posts&#125;&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default connect(state =&gt; (&#123;</span><br><span class="line">  posts: state.posts</span><br><span class="line">&#125;))(Posts);</span><br></pre></td></tr></table></figure></p>
<p><strong><code>redux-thunk</code>中间件可以把action creators写成<code>thunks</code>,也就是返回函数的函数</strong>    </p>
<p>使用react-redux修改上面的代码：   </p>
<p><code>actions.js</code><br><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">export function loadPosts(userId) &#123;</span><br><span class="line">  // 用 thunk 中间件解释：</span><br><span class="line">  return function (dispatch, getState) &#123;</span><br><span class="line">    let &#123; posts &#125; = getState();</span><br><span class="line">    if (posts[userId]) &#123;</span><br><span class="line">      // 这里是数据缓存！啥也不做。</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: &apos;LOAD_POSTS_REQUEST&apos;,</span><br><span class="line">      userId</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 异步分发原味 action</span><br><span class="line">    fetch(`http://myapi.com/users/$&#123;userId&#125;/posts`).then(</span><br><span class="line">      response =&gt; dispatch(&#123;</span><br><span class="line">        type: &apos;LOAD_POSTS_SUCCESS&apos;,</span><br><span class="line">        userId,</span><br><span class="line">        respone</span><br><span class="line">      &#125;),</span><br><span class="line">      error =&gt; dispatch(&#123;</span><br><span class="line">        type: &apos;LOAD_POSTS_FAILURE&apos;,</span><br><span class="line">        userId,</span><br><span class="line">        error</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><code>component.js</code><br><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; loadPosts &#125; from &apos;./actionCreators&apos;;</span><br><span class="line"></span><br><span class="line">class Posts extends Component &#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.props.dispatch(loadPosts(this.props.userId));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    if (nextProps.userId !== this.props.userId) &#123;</span><br><span class="line">      this.props.dispatch(loadPosts(nextProps.userId));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.props.isLoading) &#123;</span><br><span class="line">      return &lt;p&gt;Loading...&lt;/p&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let posts = this.props.posts.map(post =&gt;</span><br><span class="line">      &lt;Post post=&#123;post&#125; key=&#123;post.id&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return &lt;div&gt;&#123;posts&#125;&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default connect(state =&gt; (&#123;</span><br><span class="line">  posts: state.posts</span><br><span class="line">&#125;))(Posts);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<hr>
<h3 id="计算衍生数据"><a href="#计算衍生数据" class="headerlink" title="计算衍生数据"></a>计算衍生数据</h3><p><code>Reselect库</code>可以创建可记忆的可组合的selector函数，Reselect selectors可以高效的计算<br>Redux store里的衍生数据    </p>
<p>不使用<code>reselect</code>当state发生变化，组件更新时，会如果state tree非常大，会带来性能问题        </p>
<ul>
<li><strong>创建可记忆的Selector：</strong><br>只有在我们关注的state发生变化时才重新计算此state，而在其他非相关state的变化不会引起<br>此state重新计算。<br>Reselect提供的<code>creatSelector</code>函数创建可记忆的selector，<code>createSelector</code>接收一个input-selectors<br>数组和一个转换函数作为参数。如果state tree的改变会引起input-selectors值变化，那么selector会调用<br>转换函数，传入input-selectors作为参数，并返回结果，如果input-selectors的值和前一次一样，它将会直接<br>返回前一次计算的数据，而不重新调用转换函数    </li>
</ul>
<p><code>selectors/TodoSelectors.js</code><br><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createSelector &#125; from &apos;reselect&apos;;</span><br><span class="line">import &#123; VisibilityFilters &#125; from &apos;./actions&apos;;</span><br><span class="line"></span><br><span class="line">function selectTodos(todos, filter) &#123;</span><br><span class="line">  switch (filter) &#123;</span><br><span class="line">  case VisibilityFilters.SHOW_ALL:</span><br><span class="line">    return todos;</span><br><span class="line">  case VisibilityFilters.SHOW_COMPLETED:</span><br><span class="line">    return todos.filter(todo =&gt; todo.completed);</span><br><span class="line">  case VisibilityFilters.SHOW_ACTIVE:</span><br><span class="line">    return todos.filter(todo =&gt; !todo.completed);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const visibilityFilterSelector = (state) =&gt; state.visibilityFilter;</span><br><span class="line">const todosSelector = (state) =&gt; state.todos;</span><br><span class="line"></span><br><span class="line">export const visibleTodosSelector = createSelector(</span><br><span class="line">  [visibilityFilterSelector, todosSelector],</span><br><span class="line">  (visibilityFilter, todos) =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      visibleTodos: selectTodos(todos, visibilityFilter),</span><br><span class="line">      visibilityFilter</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p><br><br>        在上例中，visibilityFilterSelector 和 todosSelector 是 input-selector。因为他们并不转换数据，<br>        所以被创建成普通的非记忆的 selector 函数。但是，visibleTodosSelector 是一个可记忆的 selector。<br>        他接收 visibilityFilterSelector 和 todosSelector 为 input-selector，还有一个转换函数来计算过<br>        滤的 todos 列表。</p>
<ul>
<li><strong>组合 Selector</strong><pre><code>可记忆的 selector 自身可以作为其它可记忆的 selector 的 input-selector。下面
的 visibleTodosSelector 被当作另一个 selector 的 input-selector，来进一步通过关键字（keyword）过滤 todos。    
</code></pre></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const keywordSelector = (state) =&gt; state.keyword</span><br><span class="line"></span><br><span class="line">const keywordFilterSelector = createSelector(</span><br><span class="line">  [ visibleTodosSelector, keywordSelector ],</span><br><span class="line">  (visibleTodos, keyword) =&gt; visibleTodos.filter(</span><br><span class="line">    todo =&gt; todo.indexOf(keyword) &gt; -1</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><strong>连接 Selector 和 Redux Store</strong><br>在react-redux中，使用 connect 来连接可记忆的 selector 和 Redux store    </li>
</ul>
<p><code>containers/App.js</code><br><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;</span><br><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;</span><br><span class="line">import &#123; addTodo, completeTodo, setVisibilityFilter &#125; from &apos;../actions&apos;</span><br><span class="line">import AddTodo from &apos;../components/AddTodo&apos;</span><br><span class="line">import TodoList from &apos;../components/TodoList&apos;</span><br><span class="line">import Footer from &apos;../components/Footer&apos;</span><br><span class="line">import &#123; visibleTodosSelector &#125; from &apos;../selectors/todoSelectors&apos;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    // Injected by connect() call:</span><br><span class="line">    const &#123; dispatch, visibleTodos, visibilityFilter &#125; = this.props</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;AddTodo</span><br><span class="line">          onAddClick=&#123;text =&gt;</span><br><span class="line">            dispatch(addTodo(text))</span><br><span class="line">          &#125; /&gt;</span><br><span class="line">        &lt;TodoList</span><br><span class="line">          todos=&#123;this.props.visibleTodos&#125;</span><br><span class="line">          onTodoClick=&#123;index =&gt;</span><br><span class="line">            dispatch(completeTodo(index))</span><br><span class="line">          &#125; /&gt;</span><br><span class="line">        &lt;Footer</span><br><span class="line">          filter=&#123;visibilityFilter&#125;</span><br><span class="line">          onFilterChange=&#123;nextFilter =&gt;</span><br><span class="line">            dispatch(setVisibilityFilter(nextFilter))</span><br><span class="line">          &#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">App.propTypes = &#123;</span><br><span class="line">  visibleTodos: PropTypes.arrayOf(PropTypes.shape(&#123;</span><br><span class="line">    text: PropTypes.string.isRequired,</span><br><span class="line">    completed: PropTypes.bool.isRequired</span><br><span class="line">  &#125;)),</span><br><span class="line">  visibilityFilter: PropTypes.oneOf([</span><br><span class="line">    &apos;SHOW_ALL&apos;,</span><br><span class="line">    &apos;SHOW_COMPLETED&apos;,</span><br><span class="line">    &apos;SHOW_ACTIVE&apos;</span><br><span class="line">  ]).isRequired</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 把 selector 传递给连接的组件</span><br><span class="line">export default connect(visibleTodosSelector)(App)</span><br></pre></td></tr></table></figure></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/11/01/front_end/react/explain-bindActionCreators/">
                bindActionCreators
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-11-01</span>
            
            
            
                <span class="category">
                    <a href="/categories/React-Redux/">React Redux</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="bindActionCreators-actionCreators-dispatch"><a href="#bindActionCreators-actionCreators-dispatch" class="headerlink" title="bindActionCreators(actionCreators, dispatch)"></a>bindActionCreators(actionCreators, dispatch)</h1><p><strong>使用场景</strong>   </p>
<p>需要把action creator往下传到一个组件上，却不想让这个组建觉察到Redux的存在，而且不希望把Redux store<br>或dispatch传给它</p>
<p><br><br><strong>参数</strong>    </p>
<ol>
<li><p><code>actionCreators</code>(Fuction Or Object):一个action creator，或者键值是action creators的对象    </p>
</li>
<li><p><code>dispatch</code>(Function):一个dispatch函数，由<code>store</code>实例提供      </p>
</li>
</ol>
<p><strong>返回值</strong>    </p>
<p><em>(Function or Object)</em>:一个与原对象类似的对象，只不过这个对象中的每个函数值都可以直接dispatch<br>action。如果传入的是一个函数，返回的也是一个函数。</p>
<p><br></p>
<p><strong>示例</strong>    </p>
<p><code>TodoActionCreationCreator.js</code>    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export function addTodo(text) &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		type: &apos;ADD_TODO&apos;,</span><br><span class="line">		text</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function removeTodo(id) &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		type: &apos;REMOVE_TODO&apos;,</span><br><span class="line">		id</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><code>SomeComponent.js</code>   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123; bindActionCreators &#125; from &apos;redux&apos;;</span><br><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line">import * as TodoActionCreators from &apos;./TodoActionCreators&apos;;</span><br><span class="line"></span><br><span class="line">class TodoListContainer extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">	componentDidMount() &#123;</span><br><span class="line">		//由react-redux注入</span><br><span class="line">		let &#123; dispatch &#125; = this.props;</span><br><span class="line"></span><br><span class="line">		let action = TodoActionCreators.addTodo(&apos;Use Redux&apos;);</span><br><span class="line">		dispatch(action);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	render() &#123;</span><br><span class="line"></span><br><span class="line">		let &#123; todos, dispatch &#125; = this.props;</span><br><span class="line"></span><br><span class="line">		//应用bindActionCreator</span><br><span class="line">		let boundActionCreators = bindActionCreators(TodoActionCreators, dispatch);</span><br><span class="line"></span><br><span class="line">		return (</span><br><span class="line">			&lt;TodoList todos=&#123;todos&#125;</span><br><span class="line">				&#123;...boundActionCreators&#125;</span><br><span class="line">			/&gt;</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">		//一种可以替换bindActionCreators的做法是直接把dispatch函数和action creators当作props传递给组件</span><br><span class="line">		//return &lt;TodoList todos=&#123;todos&#125; dispatch=&#123;dispatch&#125; /&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default connect(state =&gt; (&#123;todos: state.todos&#125;))(TodoListContainer);</span><br></pre></td></tr></table></figure>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/11/01/front_end/react/explain-applyMiddleware/">
                applyMiddleware
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-11-01</span>
            
            
            
                <span class="category">
                    <a href="/categories/React-Redux/">React Redux</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="applyMiddleware-…middlewares"><a href="#applyMiddleware-…middlewares" class="headerlink" title="applyMiddleware(…middlewares)"></a>applyMiddleware(…middlewares)</h1><p>使用包含自定义功能的middleware来扩展Redux是一种推荐方式。Middleware可以让你包装store的dispatch方法来达到你想要的目的。<br>同事，middleware还拥有“可组合”这一关键特性。多个middleware可以被组合到一起使用，徐北广场middleware链。其中每个middleward<br>都不需要关心链中它前后的middleware的任何信息</p>
<p>例如redux-thunk支持dispatch function，以此让action creator控制反转。被dispatch的function会接收dispatch作为参数，并且可以<br>异步调用它们。这类的function就称为thunk</p>
<p>Middleware并不需要和<code>createStore</code>绑在一起使用。</p>
<p><strong>参数</strong>    </p>
<ul>
<li>…middlewares(arguments):    </li>
</ul>
<p>遵循Redux middlewareAPI的函数。每个middleware接收<code>store</code>的dispatch和getState函数作为命名参数，并返回一个函数<br>该函数会被传入称为<code>next</code>的下一个middleware的dispatch方法,并返回一个接收action的新函数，这个函数可以直接调用next(action),<br>或者在其他需要的时刻调用。调用链中最后一个middleware会接收真实的store的<code>dispatch</code>方法作为<code>next</code>参数，并结束调用链</p>
<p><strong>返回值</strong>    </p>
<p>(Function)一个应用了middleware后的store enhancer。这个store enhancer就是一个函数，并且需要应用到createStore。它会<br>返回一个应用了middleware的新的<code>createStore</code></p>
<p><strong>Example：自定义Logger Middleware</strong>    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;</span><br><span class="line">import todos from &apos;./reducers&apos;;</span><br><span class="line"></span><br><span class="line">function logger(&#123;getState&#125;) &#123;</span><br><span class="line">	return (next) =&gt; (action) =&gt; &#123;</span><br><span class="line">		console.log(&apos;will dispatch&apos;, action);</span><br><span class="line"></span><br><span class="line">		//调用middleware链中下一个middleware的dispatch</span><br><span class="line">		let returnValue = next(action);</span><br><span class="line"></span><br><span class="line">		console.log(&apos;state after dispatch&apos;, getState());</span><br><span class="line"></span><br><span class="line">		return returnValue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let createStoreWithMiddleware = applyMiddleware(logger)(createStore);</span><br><span class="line">let store = createStoreWithMiddleware(todos, [&apos;use redux&apos;]);</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;type: &apos;ADD_TODO&apos;, text: &apos;understand the middleware&apos;&#125;)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">控制台打印</span><br><span class="line">will dispatch:&#123;type: &apos;ADD_TODO&apos;, text: &apos;use redux&apos;&#125;</span><br><span class="line">state after dispatch[&apos;use redux&apos;, &apos;understand the middleware&apos;]</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p><br><br><strong>Example：使用Thunk Middleware来做异步Action</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore, combineReducers, applyMiddleware &#125; from &apos;redux&apos;;</span><br><span class="line">import thunk from &apos;redux-thunk&apos;;</span><br><span class="line">import * as reducers from &apos;./reducers&apos;;</span><br><span class="line"></span><br><span class="line">//调用applyMiddleware,使用middleware增强createStore</span><br><span class="line">let createStoreWithMiddleware = applyMiddleware(thunk)(store);</span><br><span class="line"></span><br><span class="line">let reducer = combineReducers(reducers);</span><br><span class="line">//像原生createStore一样使用</span><br><span class="line">let store = createStoreWithMiddleware(reducer);</span><br><span class="line"></span><br><span class="line">function fetchSecretSauce() &#123;</span><br><span class="line">&#125;	return fetch(&apos;http:xx.xx.xx/xx/xx&apos;);</span><br><span class="line"></span><br><span class="line">//普通的action creator，它们返回的action不需要middleware就能被dispatch</span><br><span class="line">//但是，它们只表达【事实】，并不表达【异步数据流】</span><br><span class="line">function makeASandwich(forPerson, secretSauce) &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		type: &apos;MAKE_SANDWICH&apos;,</span><br><span class="line">		forPerson,</span><br><span class="line">		secretSauce</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function apologize(fromPerson, toPerson, error) &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		type: &apos;APOLOGIZE&apos;,</span><br><span class="line">		fromPerson,</span><br><span class="line">		toPerson,</span><br><span class="line">		error</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function withdrawMoney(amount) &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		type: &apos;WITHDRAW&apos;,</span><br><span class="line">		amount</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//即使不使用middleware，也可以dispatch action：</span><br><span class="line">store.dispatch(withdrawMoney(100))</span><br><span class="line"></span><br><span class="line">//如何处理异步action？如：API调用，或者路由跳转</span><br><span class="line">//用thunk：它是一个返回函数的函数</span><br><span class="line"></span><br><span class="line">function makeASandWichSecretSauce(forPerson) &#123;</span><br><span class="line"></span><br><span class="line">	//控制反转！返回一个接收`dispatch`的函数</span><br><span class="line">	//Thunk middleware知道如何把异步 thunk action 转为普通action</span><br><span class="line">	return function (dispatch) &#123;</span><br><span class="line">		return fetchSecretSauce().then(</span><br><span class="line">			sauce =&gt; dispatch(makeASandwich(forPerson, sauce)),</span><br><span class="line">			error =&gt; dispatch(apologize(&apos;The Sandwich Shop&apos;, forPerson, error))</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Thunk middleware可以让我们像dispatch普通action一样dispatch异步的thunk action</span><br><span class="line">store.dispatch(makeASandWichSecretSauce(&apos;Me&apos;));</span><br></pre></td></tr></table></figure></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/11/01/front_end/react/API-Explain/">
                Redux API和词汇解释
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-11-01</span>
            
            
            
                <span class="category">
                    <a href="/categories/React-Redux/">React Redux</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="Redux-API和词汇解释-词汇解释-State"><a href="#Redux-API和词汇解释-词汇解释-State" class="headerlink" title="Redux API和词汇解释 ###词汇解释 - State"></a>Redux API和词汇解释 ###词汇解释 - <strong>State</strong></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">顶层state为一个对象,键-值集合，尽可能保证state可序列化。</span><br></pre></td></tr></table></figure>
<p><br> - <strong>Action</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Action是一个用来表示即将改变state的对象。它是将数据放入store的唯一途径。action必须拥有一个`type`域，用来</span><br><span class="line">指明需要执行的action type</span><br></pre></td></tr></table></figure>
<p><br> - <strong>Reducer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Reducer接收两个参数：之前累计运算的结果和当前被累计的值，返回的是一个新的累计结果。在Redux中，累计对的运算</span><br><span class="line">结果是state对象，而被累计的值是action。Reducer由上次累计的结果state与当前被累积的action计算得到一个新state。</span><br><span class="line">`Reducer必须是纯函数，不要在Reducer中有副作用操作，比如API调用`</span><br></pre></td></tr></table></figure>
<p><br> - <strong>dispatch函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*dispatch function*是一个接收action或者异步action的函数，该函数要么往store分发一个或多个action，要么不分发</span><br><span class="line">任何action</span><br></pre></td></tr></table></figure>
<p><br> <strong>一般的dispatch function 和store实例提供的没有middleware的base dispatch function之间的区别：</strong> Base dispatch functionzing是同步地把action与上一次从store返回的state发往reducer，然后重新计算出新的state，它 期望action会是一个可以被reducer消费的普通对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`Middleware`封装了base dispatch function，允许dispatch function处理action之外的异步action。middleware封装了</span><br><span class="line">base dispatch function，允许dispatch function处理action之外的异步action。Middleware可以改变、延迟、忽略action</span><br><span class="line">或异步action，也可以在传递给下一个middleware之前对它们进行解释</span><br></pre></td></tr></table></figure>
<p><br> - <strong>Action Creator</strong><br> Action Creator就是一个创建action的函数，action是一个信息的负载，而action creator是一个创建action的工厂，调用action creator 只会生成action，但不分发，需要调用store的<code>dispatch</code>function才会引起变化，bound action creator，是指一个函数调用action creator并 立即将结果分发给一个特定的store实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果action creator需要读取当前的state、调用API、或引起诸如路由变化等副作用，那么它应该返回一个异步action而不是action。</span><br></pre></td></tr></table></figure>
<p><br> - <strong>异步Action</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">异步action是一个发给dispatch函数的值，但是这个值还不能被reducer消费。在发往base dispatch() function之前，middleware会把异步action</span><br><span class="line">转化成一个或一组action。异步action可以有多种type，这取决于你所使用的middleware，比如thunk，虽然不会立即把数据传递给reducer，但是一旦</span><br><span class="line">操作完成就会出发action的分发事件。</span><br></pre></td></tr></table></figure>
<p><br> - <strong>Middleware</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Middleware是一个组合dispatch function的高阶函数，返回一个新的dispatch function，通常将异步actions转换成action。</span><br><span class="line"></span><br><span class="line">Middleware利用复合函数使其可以组合其他函数，可用于记录action日志、产生其他诸如变化路由的操作用，或将异步的API调用</span><br><span class="line">变为一组同步的action</span><br></pre></td></tr></table></figure>
<p><br> - <strong>Store</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Store维持着应用的state tree对象。因为应用的构建发生于reducer，所以一个Redux应用当中应当只有一个store</span><br></pre></td></tr></table></figure>
<p><br> - <strong>Store Creator</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Store Creator是一个创建Redux store的函数。理解由Redux导出的base store creator与从store enhancer返回的store creator</span><br><span class="line">之间的区别</span><br></pre></td></tr></table></figure>
<p><br> - <strong>Store enhancer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Store enhancer是一个组合store creator的高阶函数，返回一个新的强化过的store creator。这与middleware相似，它允许你通过符合函数</span><br><span class="line">改变store接口</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="API文档-顶级暴露的方法-createStore-reducer-initialState"><a href="#API文档-顶级暴露的方法-createStore-reducer-initialState" class="headerlink" title="API文档 #### 顶级暴露的方法 - createStore(reducer, [initialState])"></a>API文档<br> #### 顶级暴露的方法 - <strong>createStore(reducer, [initialState])</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建一个Redux store来以存放应用中的所有state，应用中有且仅有一个store</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<ol>
<li><p><code>reducer(*Function*)</code>:接收两个参数，分别是当前的state树和要处理的action，返回新的state树。</p>
</li>
<li><p><code>[initialState](any)</code>:初始时的state，如果你使用combineReducers创建reducer，它必须是一个普通对象，与传入的keys保持同样的结构</p>
</li>
</ol>
<p><strong>返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Store):保存了应用所有state的对象。**改变state的惟一方法是dispatch action。**你也可以subscribe坚挺state的变化，然后更新UI</span><br></pre></td></tr></table></figure>
<p><br> - <strong>combineReducers(reducers)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**state对象的结构由传入的多个reducer的key决定**,通过为传入对象的reducer命名来控制state key的命名。例如</span><br><span class="line">`combineReducers(&#123;todos: todoReducer, counter: counterReducer&#125;)`将state的结构变为`&#123;todos: &apos;xxx&apos;, counter: &apos;xxx&apos;&#125;`</span><br><span class="line">ES6的简写方法`combineReducers(&#123; counter, todos &#125;)`等价于`combineReducers(&#123; counter: counter, todos: todos &#125;)`</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong><a href="./explain-applyMiddleware.md">applyMiddleware(…middlewares)</a></strong></p>
</li>
<li><p><strong><a href="./explain-bindActionCreators.md">bindActionCreators(actionCreators, dispatch)</a></strong></p>
</li>
<li><p><strong>compose(…functions)</strong>待研究</p>
</li>
</ul>
<p>####Store API<br><em> <em>*Store</em></em></p>
<ul>
<li><p>getState()</p>
</li>
<li><p>dispatch(action)</p>
</li>
<li><p>subscribe(listener)</p>
</li>
<li><p>getReducer()</p>
</li>
<li><p>replaceReducer(nextReducer)</p>
</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/11/01/front_end/react/life_cycle/">
                react生命周期
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-11-01</span>
            
            
            
                <span class="category">
                    <a href="/categories/React-Redux/">React Redux</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="组件的生命周期说明"><a href="#组件的生命周期说明" class="headerlink" title="组件的生命周期说明"></a>组件的生命周期说明</h2><hr>
<h3 id="constructor的说明"><a href="#constructor的说明" class="headerlink" title="constructor的说明"></a>constructor的说明</h3><p>组建初始化时运行，仅一次</p>
<h3 id="componentWillMount-组件即将镶嵌"><a href="#componentWillMount-组件即将镶嵌" class="headerlink" title="componentWillMount(组件即将镶嵌)"></a>componentWillMount(组件即将镶嵌)</h3><p>在初始化渲染之前立刻调用,如果在这个方法内调用setState()方法,render()将会感知到更新后的state,将会执行仅一次,尽管state改变了。  </p>
<h3 id="componentDidMount-组件已经镶嵌"><a href="#componentDidMount-组件已经镶嵌" class="headerlink" title="componentDidMount(组件已经镶嵌)"></a>componentDidMount(组件已经镶嵌)</h3><p>仅调用一次<br>在组件初始化渲染之后立刻调用一次,在生命周期的这个时间点,组件拥有一个DOM展现,你可以通过ReactDOM.findDOMNode(this)获取整个dom节点<br>也可以访问dom组件中的ref属性代表的组件,可以在该方法中发送ajax请求<br>原先的this.getDOMNode()已经被弃用了，</p>
<h3 id="componentWillReceiveProps-组件即将接收props"><a href="#componentWillReceiveProps-组件即将接收props" class="headerlink" title="componentWillReceiveProps(组件即将接收props)"></a>componentWillReceiveProps(组件即将接收props)</h3><p>在组件接收到新的props的时候调用,在初始化渲染的时候,改方法不会调用,用此函数可以作为react在prop传入之后,render()渲染之前更新state的机会。<br>老的props可以通过this.props获取到。在该函数中调用this.setState()将不会引起第二次渲染。  </p>
<h3 id="shouldComponentUpdate-组件应该被更新"><a href="#shouldComponentUpdate-组件应该被更新" class="headerlink" title="shouldComponentUpdate(组件应该被更新)"></a>shouldComponentUpdate(组件应该被更新)</h3><p>在接受到新的props或者state,将要渲染之前调用。该方法在初始化渲染的时候不会调用,在使用forceUpdate方法的时候也不会。如果确定新的props和state<br>不会导致组件更新，则此处应该返回false.    </p>
<pre><code>shouldComponentUpdate() {
    return nextProps.id != this.props.id;
}
</code></pre><p>如果shouldComponentUpdate返回false,则render()将不会执行,直到下一次state改变(另外componentWillUpdate和componentDidUpdate也不会被调用)<br>默认情况下,shouldComponentUpdate总会返回true,使用shouldComponentUpdate可以提升应用的性能  </p>
<h3 id="componentWillUpdate-组件即将更新"><a href="#componentWillUpdate-组件即将更新" class="headerlink" title="componentWillUpdate(组件即将更新)"></a>componentWillUpdate(组件即将更新)</h3><p>在接受到新的props和state之前立刻调用，在初始化渲染的时候该方法不会被调用。使用该方法做一些更新之前的准备工作。<br><code>注:不能在该方法中使用this.setState()如果需要更新state来相应某个prop的改变请使用componentWillReceiveProps()</code></p>
<h3 id="componentDidUpdate-组件已经更新"><a href="#componentDidUpdate-组件已经更新" class="headerlink" title="componentDidUpdate(组件已经更新)"></a>componentDidUpdate(组件已经更新)</h3><p>在组件的更新已经同步到DOM中之后立刻被调用。改方法不会在初始化渲染的时候调用。使用该方法可以在组件更新之后操作DOM元素<br><code>使用该方法，你仍然可以获取DOM节点</code></p>
<h3 id="componentWillUnmount-组件将要移除"><a href="#componentWillUnmount-组件将要移除" class="headerlink" title="componentWillUnmount(组件将要移除)"></a>componentWillUnmount(组件将要移除)</h3><p>在组件从DOM中移除的时候立刻被调用。<br>在该方法中执行任何必要的清理，比如无效的定时器，或者清除在componentDidMount中创建的DOM元素</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/10/21/front_end/http/server/">
                WEB服务器、代理
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-10-21</span>
            
            
            
                <span class="category">
                    <a href="/categories/Http/">Http</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><strong>代理和网关的对比</strong><br>代理连接的是两个或多个使用相同协议的应用程序，二网关连接的则是两个或多个使用不同协议的<br>端点。网关扮演的是“协议转换器”的角色，即使客户端和服务器使用不同的协议，客户端也可以通过<br>它完成与服务器之间的事务处理</p>
<p><strong>为什么使用代理</strong></p>
<ul>
<li>安全防火墙</li>
<li>Web缓存</li>
<li><p>反向代理</p>
<blockquote>
<p>代理可以假扮web服务器。这些被称为替代物或者反向代理的代理接受发送给Web服务器的真是请求<br>，但与Web服务器不同的是，他们可以发起与其他服务器的通信，以便按需定位所请求的内容。<br>可以用这些反向代理来提高访问慢速Web服务器上公共内容时的性能。在这种配置中，通常将这些<br>反向代理称为服务器加速器</p>
</blockquote>
</li>
<li><p>内容路由器</p>
<blockquote>
<p>代理服务器可以作为“内容路由器”使用，根据因特网流量状况以及内容类型将请求导向特定的Web<br>服务器。<br>内容路由器也可以用来实现各种服务级的请求。</p>
</blockquote>
</li>
<li><p>转码器</p>
<blockquote>
<p>代理服务器在将内容发送给客户端之前，可以修改内容的主体格式。在这些数据表示法之间进行的<br>透明转换被称为转码<br>转码代理可以在传输GIF图片时，将其转换成JPEG图片，以减小尺寸，也可以对图片进行压缩，同样<br>也可以对文本文件进行压缩，代理甚至可以在传输文档的过程中将其转换成外语。</p>
</blockquote>
</li>
<li><p>匿名者</p>
<blockquote>
<p>匿名者代理会主动从HTTP报文中删除身份特性（比如客户端IP地址、From首部、Referer首部、<br>cookie、URI的会话ID）从而提供高度的私密性和匿名性</p>
</blockquote>
</li>
</ul>
<p><strong>代理会何去何从</strong></p>
<ol>
<li>怎样将代理部署到网络中去</li>
<li>怎样将代理以层级方式连接在一起</li>
<li>怎样先将网络流量导入到代理服务器中</li>
</ol>
<p><strong>代理服务器的部署</strong></p>
<ul>
<li>出口代理</li>
<li>访问（入口）代理</li>
<li><p>反向代理</p>
<blockquote>
<p>代理通常会被部署在网络边缘,在Web服务器之前，作为代替物（反向代理），在那里他们可以处理<br>所有传送给Web服务器的请求，并只在必要时向Web服务器请求资源，反向代理通常会直接冒用Web<br>服务器的名字和ip地址，这样所有的请求就会被发送给代理而不是服务器了</p>
</blockquote>
</li>
<li><p>网络交换代理</p>
</li>
</ul>
<p><strong>代理的层次结构</strong><br>可以通过代理的层次结构将代理级联起来，在代理的层次结构中，会将报文从一个代理传给另一个代<br>理，直到最终抵达原始服务器为止（然后通过代理传回给客户端）<br><strong>代理层次结构中的路由</strong><br>代理服务器可以根据众多因素，将报文转发给一个不断变化的代理服务器和原始服务器集。比如：</p>
<ul>
<li>负载均衡</li>
<li>地理位置附近的路由</li>
<li>协议/类型路由<blockquote>
<p>子代理可能会根据不同的URI将报文转发到不同的父代理和原始服务器上去，某些特定类型的URI<br>可能会通过一些特殊的代理服务器转发请求，一遍进行特殊的协议处理。</p>
</blockquote>
</li>
</ul>
<p><strong>代理如何获取流量</strong><br>有四种方式可以使客户端流量流向代理</p>
<ol>
<li>修改客户端</li>
<li>修改网络</li>
<li>修改DNS的命名空间</li>
<li>修改Web服务器</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/10/21/front_end/http/leanr_tcp_ip/">
                在浏览器输入URL后，发生了什么?
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-10-21</span>
            
            
            
                <span class="category">
                    <a href="/categories/Http/">Http</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <ol>
<li>浏览器解析主机名</li>
<li>浏览器查询这个主机名的IP地址（DNS）</li>
<li>浏览器获得端口号</li>
<li>浏览器发起IP:port的连接</li>
<li>浏览器想服务器发送一条HTTP GET报文</li>
<li>浏览器从服务器读取HTTP响应报文</li>
<li>浏览器关闭连接</li>
</ol>
<blockquote>
<p>HTTP通信都是由TCP/IP承载的，TCP/IP是一种常用的<strong>分组交换网络分层协议集</strong>.TCP的数据是通过名为IP分组<br>（或IP数据报）的小数据块来发送的。HTTP（应用层）-&gt;TCP(传输层)-&gt;IP（网络层）-&gt;网络接口(数据链路层)，<br>HTTP要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的TCP连接按序传输。TCP收到数据之后<br>会将数据流砍成被称作段的小数据块，并将段封装在IP分组中，通过因特网传输，这些工作都是通过TCP/IP软件<br>处理的。<br>每个TCP段都是由IP分组承载，从一个IP地址发送到另一个IP地址，每个IP分组中都包括:</p>
<ol>
<li>一个IP分组首部（通常为20字节），包含了源和目的地的IP地址，长度和其他标记</li>
<li>一个TCP段首部（通常为20字节），包含了TCP的端口号、TCP的控制标记，以及数据排序和完成性的数字值</li>
<li>一个TCP数据块（0个或多个字节）</li>
</ol>
</blockquote>
<p>TCP连接通过4个值识别: <strong>&lt;源IP地址， 源端口号， 目的地IP地址， 目的地端口号&gt;</strong></p>
<p>TCP客户端和服务器是如何通过TCP套接字接口进行通信的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">客户端                                                        服务器</span><br><span class="line">                                                          S1  创建新的套接字(socket)</span><br><span class="line">                                                          S2  将套接字绑定到端口上去(bind)</span><br><span class="line">                                                          S3  允许套接字进行连接(listen)</span><br><span class="line">                                                          S4  等待连接(accept)</span><br><span class="line">C1 获取IP地址和端口号</span><br><span class="line">C2 创建新的套接字(socket)</span><br><span class="line">C3 连接到服务器的IP:port上去(connect)</span><br><span class="line">                                                          S5 通知应用程序有连接到来</span><br><span class="line">                                                          S6开始读取请求</span><br><span class="line">C4 连接成功</span><br><span class="line">C5 发送HTTP请求（write）</span><br><span class="line">C6 等待HTTP响应（read）</span><br><span class="line">                                                          S7 处理HTTP请求报文</span><br><span class="line">C7 处理HTTP响应                                            S8 回送HTTP响应（write）</span><br><span class="line">C8关闭连接（close）                                         S9 关闭连接（close）</span><br></pre></td></tr></table></figure></p>
<p><strong>对TCP性能的考虑</strong>    </p>
<p>HTTP紧挨着TCP，位于其上层，所以HTTP事务的性能取决于底层TCP通道的性能。TCP网络的时延取决于<br>硬件速度、网络和服务器的负载、请求和响应报文的尺寸、以及客户端和服务器之间的距离。</p>
<p>最常见的TCP相关时延，包括:</p>
<ol>
<li>TCP连接建立握手</li>
<li>TCP慢启动拥塞控制</li>
<li>数据聚集的Nagle算法</li>
<li>用于捎带的TCP延迟确认算法</li>
<li>TIME_WRIT时延和端口耗尽</li>
</ol>
<p><strong>TCP连接的握手时延</strong><br>建立一条新的TCP连接时，甚至是在发生任意数据之前，TCP软件之间会交换一系列的IP分组，对连接<br>的有关参数进行沟通，如果连接只是用来传送少量数据，这些交换过程就会严重降低HTTP的性能。</p>
<p><strong>TCP连接握手的步骤</strong></p>
<ol>
<li>请求新的TCP连接时，客户端要向服务器发送一个小的TCP分组，这个分组设置了一个特殊的SYN标记，说明这是一个连接请求。</li>
<li>如果服务器接受了连接，就会对一些连接参数进行计算，并向客户端回送一个TCP分组，这个分组中的SYN和ACK标记都被置位，说明请求已被接受。</li>
<li>最后，客户端向服务器回送一个确认信息，通知它连接已成功建立，现代的TCP栈都允许客户端在这个确认分组中发送数据。</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/10/21/front_end/http/integration/">
                网关、隧道及中继
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-10-21</span>
            
            
            
                <span class="category">
                    <a href="/categories/Http/">Http</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><strong>网关类型:服务器协议转换器、服务端安全网关、客户端安全网关以及应用程序服务器</strong></p>
<p><strong>HTTP/*: 服务端Web网关</strong></p>
<blockquote>
<p>请求流入到原始服务器，服务器Web网关会将客户端HTTP请求转换为其他协议</p>
</blockquote>
<p><strong>HTTP/HTTPS：服务器端安全网关</strong></p>
<blockquote>
<p>一个组织可以通过网关对所有的输入Web请求加密，以提供额外的隐私和安全性保护，客户端可以用<br>普通的HTTP浏览web内容，单网关会自动加密用户的对话</p>
</blockquote>
<p><strong>HTTPS/HTTP客户端安全加速器网关</strong></p>
<blockquote>
<p>HTTPS/HTTP网关位于Web服务器之前，通常可以作为不可见的拦截网关或者反向代理使用，他们接<br>收安全的HTTPS流量，对安全流量进行解密，并向Web服务器发送普通的HTTP请求。</p>
</blockquote>
<p><strong>隧道</strong></p>
<blockquote>
<p>Web隧道，这种方式可以通过HTTP应用程序访问使用非HTTP协议的应用程序。Web隧道允许用户通过<br>非HTTP连接发送非HTTP流量，这样就可以在HTTP上捎带其他协议数据了。使用Web隧道最常见的原因<br>就是要在HTTP连接中嵌入非HTTP流量，这样，这类流量就可以穿过只允许Web流量通过的防火墙了。</p>
</blockquote>
<p><strong>用CONNECT建立HTTP隧道</strong></p>
<blockquote>
<p>Web隧道是用HTTP的CONNECT方法建立起来的。CONNECT并不是HTTP/1.1核心规范的一部分，但却是<br>一种得到广泛应用的扩展。CONNECT方法请求隧道网关创建一条到达任意目的服务器和端口的TCP连接，<br>并对客户端和服务器之间的后继数据进行盲转发。通过CONNECT方法可以与使用任意协议的任意服务器<br>建立TCP连接。</p>
</blockquote>
<p><strong>CONNECT请求</strong></p>
<blockquote>
<p>除了起始行之外语法与其余HTTP方法类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONNECT host.netspace.com:443 http/1.0</span><br><span class="line">User-agent: Mozilla/4.0</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>CONNECT响应</strong></p>
<blockquote>
<p>发送了请求之后，客户端会等待来自网关的响应，和普通HTTP报文一样，响应码200表示成功，按照<br>惯例，响应中的响应短语通常被设置为”Connection Established”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 Connection Established</span><br><span class="line">Proxy-agent: Netscape-Proxy/1.1</span><br></pre></td></tr></table></figure></p>
<p>与普通HTTP响应不同，这个响应并不需要包含Content-Type首部。此时连接只是对原始字节进行<br>转接，不再是报文的承载者，所以不需要使用内容类型了。</p>
</blockquote>
<p><strong>中继</strong></p>
<blockquote>
<p>HTTP中继是没有完全遵循HTTP规范的简单HTTP代理。中继负责处理HTTP中建立连接的部分，然后<br>对字节进行盲转发。某些简单中继实现中存在一个更常见的问题是，由于它们无法正确处理Connection<br>首部，所以有潜在的挂起keep-alive连接的可能。</p>
</blockquote>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/10/21/front_end/http/digestAuthenticate/">
                摘要认证
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-10-21</span>
            
            
            
                <span class="category">
                    <a href="/categories/Http/">Http</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/10/21/front_end/http/cookie/">
                客户端识别与cookie技术
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-10-21</span>
            
            
            
                <span class="category">
                    <a href="/categories/Http/">Http</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><strong>常见的用来承载用户相关信息的HTTP首部</strong></p>
<blockquote>
<p>From: 用户的E-mail地址<br>User-Agent: 用户的浏览器软件<br>Refer: 用户是从这个页面上依照连接跳转过来的<br>Authorization: 用户名和密码<br>Client-IP(扩展请求):客户端的ip地址<br>X-Forwarded-For(扩展请求): 客户端的IP地址<br>Cookie(扩展请求): 服务器产生的ID标签</p>
</blockquote>
<p><strong>使用客户端IP地址识别用户存在的缺点</strong></p>
<blockquote>
<ul>
<li>客户端IP地址描述的是机器，而不是用户，多个用用户共享一台电脑，就无法区分了。</li>
<li>很多因特网服务提供商都会在用户登录时为其动态分配IP地址。用户每次登录，都会得到一个不<br>同地址。</li>
<li>为提供安全性，并对稀缺的地址资源进行管理，很多用户都是通过网络地址转换防火墙来浏览网<br>络内容。</li>
<li>HTTP代理和网关通常会打开一些新的、到原始服务器的TCP连接，Web服务器看到的将是代理服务<br>器的IP地址而不是客户端的，有的代理会添加特殊的Client-IP或X-Forward-For扩展首部来保存原始<br>的IP地址，但并不是所有的代理都支持这种行为。</li>
</ul>
</blockquote>
<p><strong>胖URL的缺点</strong></p>
<blockquote>
<ul>
<li>URL比较丑陋</li>
<li>无法共享URL，胖URL中包含了与特定用户和会话有关的状态信息，如果将这个URL发送给其他人<br>可能会在无意之间中将你的个人信息共享出去</li>
<li>破坏缓存 为每个URL生成特有的版本就意味着不在有可供访问的URL需要缓存了</li>
<li>额外的服务器负荷 服务器需要重写HTML页面使URL变胖</li>
<li>逃逸口 用户转到其他站点或者请求一个特定的URL时，就很容易在无意中”逃离胖URL会话”</li>
<li>在会话间是非持久的 除非用户收藏了特定的胖URL，否则用户退出登录时，所有的信息都会丢失</li>
</ul>
</blockquote>
<p><strong>cookie</strong></p>
<blockquote>
<p>可以笼统的将cookie分为两类: 会话cookie和持久cookie。会话cookie是一种临时cookie,它记<br>录了用户访问站点时的设置和偏好。用户退出浏览器时，会话cookie就被删除了。持久cookie的生存<br>时间更长一些；它们存储在硬盘上，浏览器退出，计算机重启它们仍然存在。会话cookie和持久cookie<br>之间唯一的区别就是它们的过期时间。如果设置了Discard参数，或者没有设置Expires或Max-Age参数<br>来说明扩展的过期时间，这个cookie就是一个会话cookie。</p>
</blockquote>
<p><strong>cookie是如何工作的</strong></p>
<blockquote>
<p>用户首次访问Web站点时，Web服务器对用户一无所知。Web服务器希望这个用户会再次回来，所以在<br>响应报文中添加Set-Cookie首部。cookie中可以包含任何信息，但它们通常都只包含一个服务器为了<br>进行追踪而产生的独特的标识码。浏览器会记住从服务器返回的Set-Cookie或Set-Cookie2首部中的<br>cookie内容存储在浏览器的cookie数据库中。将来用户返回同一站点时，浏览器会挑中那个服务器<br>贴到用户上的那些cookie，并在一个cookie请求首部中将其传回去。</p>
</blockquote>
<p><strong>cookie罐:客户端的状态</strong></p>
<blockquote>
<p>cookie的基本思想就是让浏览器积累一组服务器特有的信息，每次访问服务器时都将这些信息提供<br>给他，因为浏览器要负责存储cookie信息，所以此系统被称为客户端侧状态，cookie内容的字段们:</p>
<ul>
<li>domain（域）cookie的域，控制哪些站点可以看到那个cookie</li>
<li>allh 是域中所有的主机都获取cookie，还是只有指定了名字的主机获取。</li>
<li>path（路径）域中与cookie相关的路径前缀。这个属性列出的URL路径前缀下所有cookie都是有<br>效的</li>
<li>secure（安全）是否只有在使用SSL连接时才发送这个cookie</li>
<li>expiration cookie的过期秒数</li>
<li>name cookie变量的名字</li>
<li>value cookie变量的值</li>
</ul>
</blockquote>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="disabled" href="/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/2/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2016/11/01/front_end/react/react-redux/">redux</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2016/11/01/front_end/react/explain-bindActionCreators/">bindActionCreators</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2016/11/01/front_end/react/explain-applyMiddleware/">applyMiddleware</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2016/11/01/front_end/react/API-Explain/">Redux API和词汇解释</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="/categories/React-Redux-React-Router/">React Redux React-Router</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/React/">React</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/Git/">Git</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/Bootstrap/">Bootstrap</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/zhuxindaba">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>