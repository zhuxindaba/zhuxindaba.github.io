<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>zhuxin_blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="zhuxin_blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="zhuxin_blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zhuxin_blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="zhuxin_blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  
  <link href="//fonts.googleapis.com/css?family=Inconsolata:400,700|Open+Sans:700,400" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <div id="header-title">
        <h1 id="logo-wrap">
          <a href="/" id="logo">
          
              <span id="subtitle">每天进步一点点</span>
          
          </a>
        </h1>
      </div>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">我的文章</a>
        
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</div>
      <div class="outer">
        <section id="main">
  
    <article id="post-vue/components" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/30/vue/components/" class="article-date">
  <time datetime="2016-11-29T17:48:53.501Z" itemprop="datePublished">2016-11-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/30/vue/components/">组件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h3><blockquote>
<p>组件是Vue的最强大的特性之一，他们帮你扩展基于Html元素来封装可复用的代码，在较高的水平上<br>组件是自定义元素，是Vue编译器的附加行为。在一些场景中，它们可能在一些原生的Html元素以<code>is</code><br>属性的扩展形式出现。</p>
</blockquote>
<h3 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h3><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><blockquote>
<p>通过以下方式创建vue实例：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#some-element&apos;,</span><br><span class="line">  // options</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以使用<code>Vue.component(tagName, options)</code>注册一个全局组件,例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  // options</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：Vue不强制用W3c的规则命名（都小写，使用-连字符），但是遵守这个规则是好的做法。<br>只要一注册，组件可以在一个vue实例中作为一个自定义元素使用，<code>&lt;my-component&gt;&lt;/my-component&gt;</code>.<br>在初始化vue实例时请确保组件已经注册了。比如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;my-component&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// register</span><br><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">// create a root instance</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将会渲染为：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;div&gt;A custom component!&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><blockquote>
<p>没有必要将每一个组件都注册为全局的，你可以在一个实例或组件内部通过<code>components</code>属性局部的<br>使用组件：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Child = &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  components: &#123;</span><br><span class="line">    // &lt;my-component&gt; will only be available in parent&apos;s template</span><br><span class="line">    &apos;my-component&apos;: Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="DOM模板解析警告"><a href="#DOM模板解析警告" class="headerlink" title="DOM模板解析警告"></a>DOM模板解析警告</h3><blockquote>
<p>当使用DOM作为你的模板时（比如：使用<code>el</code>选项来装载具有内容的元素），你会受到HTML固有的工作<br>限制，因为只有浏览器解析并初始化完成后Vue才会得到模板的内容，最值得注意的是，一些元素比如<br><code>&lt;ul&gt;</code>,<code>&lt;ol&gt;</code>,<code>&lt;table&gt;</code>,<code>&lt;select&gt;</code>对他们里面的元素有严格地限制，比如<code>&lt;option&gt;</code>只能出现<br>在特定元素的里面。当在这些具有严格限制的HTNL元素中使用模板时，该如何做呢：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;my-row&gt;...&lt;/my-row&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>自定义的组件<code>&lt;my-row&gt;</code>将会被提升作为合法的内容，但是最终的输出结果会引起错误，使用<code>is</code><br>这个属性作为变通方案：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你使用以下的来源是使用字符串模板，将不会受到以上限制：</p>
<ul>
<li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li>
<li>js行内字符串模板</li>
<li><code>.vue</code>组件<br>因此，尽可能使用字符串模板。</li>
</ul>
</blockquote>
<h3 id="data必须是一个函数"><a href="#data必须是一个函数" class="headerlink" title="data必须是一个函数"></a><code>data</code>必须是一个函数</h3><blockquote>
<p>模板的<code>data</code>必须是一个函数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;hello&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Vue将会暂停并在控制台打印错误，告诉你<code>data</code>必须是一个函数或者是组件实例，这个规则的存在<br>很容易理解：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example-2&quot;&gt;</span><br><span class="line">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</span><br><span class="line">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</span><br><span class="line">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var data = &#123; counter: 0 &#125;</span><br><span class="line">Vue.component(&apos;simple-counter&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;button v-on:click=&quot;counter += 1&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&apos;,</span><br><span class="line">  // data is technically a function, so Vue won&apos;t</span><br><span class="line">  // complain, but we return the same object</span><br><span class="line">  // reference for each component instance</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#example-2&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于这三个组件实例共享同一个<code>data</code>,当增加其中一个值时所有的值都会增加，通过返回一个全新<br>的对象来修复这个问题:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在每一个组件都有自己的内部状态。</p>
</blockquote>
<h3 id="组件的组合"><a href="#组件的组合" class="headerlink" title="组件的组合"></a>组件的组合</h3><blockquote>
<p>组件可以在一起使用，最常见的就是父子关系：组件A可能在自己的模板中使用组件B。他们必然会<br>互相通信：父组件会给子组件传递<code>props</code>,子组件会给父组件报告在子组件内发生了什么。然而通<br>过一个明确定义的接口来保持父子组件的解耦也是非常重要的。这可以确保每个组件在相对隔离的情<br>况下也可书写与推理，因此书写和维护变得更简单了。在Vue.js中，父子组件的通信可以概括为props<br>向下传递，事件向上传递。父组件通过<strong>props</strong>给子组件传递data，子组件通过事件给父组件传递<br>消息。</p>
</blockquote>
<h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><h4 id="通过props传递打他"><a href="#通过props传递打他" class="headerlink" title="通过props传递打他"></a>通过props传递打他</h4><blockquote>
<p>每一个组件实例都有自己的作用域。这意味着你不能在子组件的模板中直接使用父组件的data，父<br>组件的data可以通过props传递到子组件。<strong>props</strong>是一个自定义的属性用来传递父组件的信息，<br>子组件通过<code>props</code>选项来明确的声明它期望获得的数据：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;child&apos;, &#123;</span><br><span class="line">  // declare the props</span><br><span class="line">  props: [&apos;message&apos;],</span><br><span class="line">  // just like data, the prop can be used inside templates</span><br><span class="line">  // and is also made available in the vm as this.message</span><br><span class="line">  template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//我们可以这样传递一个简单的字符串给child组件</span><br><span class="line">&lt;child message=&quot;hello!&quot;&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure>
<h4 id="驼峰式vs-分界符"><a href="#驼峰式vs-分界符" class="headerlink" title="驼峰式vs-分界符"></a>驼峰式vs<code>-</code>分界符</h4><blockquote>
<p>HTML的属性是不区分大小写的，所以当使用非字符串模板时，驼峰式属性吗需要用他们的’-‘分界符<br>命名规则来替换：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;child&apos;, &#123;</span><br><span class="line">  // camelCase in JavaScript</span><br><span class="line">  props: [&apos;myMessage&apos;],</span><br><span class="line">  template: &apos;&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;!-- kebab-case in HTML --&gt;</span><br><span class="line">&lt;child my-message=&quot;hello!&quot;&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果使用的是字符串模板，没有这个限制。</p>
</blockquote>
<h4 id="动态的Props"><a href="#动态的Props" class="headerlink" title="动态的Props"></a>动态的Props</h4><blockquote>
<p>和属性绑定普通表达式类似，在父组件中可以使用<code>v-bind</code>动态的绑定data和props，不论父组件的<br>data是否改变，它始终会传递给子组件：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;input v-model=&quot;parentMsg&quot;&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;child v-bind:my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//使用v-bind的简写形式：</span><br><span class="line">&lt;child :my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Literal-文本-VS-Dynamic"><a href="#Literal-文本-VS-Dynamic" class="headerlink" title="Literal(文本) VS Dynamic"></a>Literal(文本) VS Dynamic</h4><blockquote>
<p>一个常犯的错误就是使用文本语法传递一个数字：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- this passes down a plain string &quot;1&quot; --&gt;</span><br><span class="line">&lt;comp some-prop=&quot;1&quot;&gt;&lt;/comp&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然而，由于这是一个文本属性，传递的数字是字符串类型的，如果要传递一个js的number类型，我们<br>需要使用<code>v-bind</code>它会将值预估为js的表达式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- this passes down an actual number --&gt;</span><br><span class="line">&lt;comp v-bind:some-prop=&quot;1&quot;&gt;&lt;/comp&gt;</span><br></pre></td></tr></table></figure>
<h4 id="单项数据流"><a href="#单项数据流" class="headerlink" title="单项数据流"></a>单项数据流</h4><blockquote>
<p>在父子组件中所有的数据都是单向流动的：当父组件的属性改变时，它会流向子组件，但是子组件的<br>变化不会流向父组件。这样可以阻止子组件意外变化而引起父组件状态的突变，这会让你的应用程序<br>很难找到原因。<br>另外，任何时候只要父组件更新了，子组件的所有props都会刷新到最近的值，这意味着你不要尝试<br>改变子组件的prop，如果你做了，Vue会在控制台警告你。<br>通常有两种情况你要改变prop：</p>
<ol>
<li>prop只是用来传递一个初始值，子组件只是想用它做一个局部的对象属性。</li>
<li>prop作为一个原始值传递<br>适当的使用场景是：</li>
<li>定义一个局部data属性，使用prop’s的初始值作为它的值：</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">props: [&apos;initialCounter&apos;],</span><br><span class="line">data: function () &#123;</span><br><span class="line">  return &#123; counter: this.initialCounter &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>定义一个属性的计算，通过prop’s的值计算：</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [&apos;size&apos;],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: function () &#123;</span><br><span class="line">    return this.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意对象和数组是引用传递，所以当传递数组和对象给子组件时，在子组件修改它会影响父组件的<br>状态。</p>
</blockquote>
<h4 id="Prop验证"><a href="#Prop验证" class="headerlink" title="Prop验证"></a>Prop验证</h4><blockquote>
<p>定义一个明确的获得的prop类型是很有用的，如果要求不满足，Vue会报警告，当多人开发时是很<br>有用的：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;example&apos;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    // basic type check (`null` means accept any type)</span><br><span class="line">    propA: Number,</span><br><span class="line">    // multiple possible types</span><br><span class="line">    propB: [String, Number],</span><br><span class="line">    // a required string</span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;,</span><br><span class="line">    // a number with default value</span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 100</span><br><span class="line">    &#125;,</span><br><span class="line">    // object/array defaults should be returned from a</span><br><span class="line">    // factory function</span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      default: function () &#123;</span><br><span class="line">        return &#123; message: &apos;hello&apos; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // custom validator function</span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: function (value) &#123;</span><br><span class="line">        return value &gt; 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>type</code>有以下原始类型：</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Bollean</li>
<li>Function</li>
<li>Object</li>
<li>Array<br>另外，<code>type</code>可以是自定义构造函数的类型，通过<code>instanceof</code>校验。</li>
</ul>
</blockquote>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><blockquote>
<p>子组件如何和父组件通信呢？使用Vue的自定义事件系统。</p>
</blockquote>
<h4 id="使用v-on来定义事件"><a href="#使用v-on来定义事件" class="headerlink" title="使用v-on来定义事件"></a>使用<code>v-on</code>来定义事件</h4><blockquote>
<p>每一个Vue实例都实现了<a href="https://vuejs.org/v2/api/#Instance-Methods-Events" target="_blank" rel="external">事件接口</a>,</p>
<ul>
<li>使用<code>$on(eventName)</code>监听事件</li>
<li>使用<code>$emit(eventName)</code>触发事件<br>注意Vue的事件系统和浏览器的<a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget" target="_blank" rel="external">事件API</a>是分开的。<br>尽管他们工作类似，但是<code>$on</code>和<code>$emit</code>不是<code>addEventListener</code>和<code>dispatchEvent</code>的别名。<br>另外，父组件可以监听子组件使用<code>$on</code>发出的事件：</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;counter-event-example&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;</span><br><span class="line">  &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;button-counter&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&apos;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      counter: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment: function () &#123;</span><br><span class="line">      this.counter += 1</span><br><span class="line">      this.$emit(&apos;increment&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#counter-event-example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    total: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    incrementTotal: function () &#123;</span><br><span class="line">      this.total += 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>绑定原生事件到组件</strong><br>在<code>v-on</code>指令添加后缀<code>.native</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-on:click.native=&quot;doTheThing&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>
<h4 id="form表单组件使用自定义事件"><a href="#form表单组件使用自定义事件" class="headerlink" title="form表单组件使用自定义事件"></a>form表单组件使用自定义事件</h4><blockquote>
<p>使用<code>v-modle</code>来创建自定义表单组件：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;something&quot;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>仅仅是语法糖：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当在组件中使用时：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-input v-bind:value=&quot;something&quot; v-on:input=&quot;something = arguments[0]&quot;&gt;&lt;/custom-input&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>目前组件与<code>v-modle</code>的工作，它必须：</p>
<ul>
<li>接收一个<code>value</code>属性</li>
<li>放射出一个<code>input</code>事件</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;currency-input v-model=&quot;price&quot;&gt;&lt;/currency-input&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.component(&apos;currency-input&apos;, &#123;</span><br><span class="line">  template: &apos;\</span><br><span class="line">    &lt;span&gt;\</span><br><span class="line">      $\</span><br><span class="line">      &lt;input\</span><br><span class="line">        ref=&quot;input&quot;\</span><br><span class="line">        v-bind:value=&quot;value&quot;\</span><br><span class="line">        v-on:input=&quot;updateValue($event.target.value)&quot;\</span><br><span class="line">      &gt;\</span><br><span class="line">    &lt;/span&gt;\</span><br><span class="line">  &apos;,</span><br><span class="line">  props: [&apos;value&apos;],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // Instead of updating the value directly, this</span><br><span class="line">    // method is used to format and place constraints</span><br><span class="line">    // on the input&apos;s value</span><br><span class="line">    updateValue: function (value) &#123;</span><br><span class="line">      var formattedValue = value</span><br><span class="line">        // Remove whitespace on either side</span><br><span class="line">        .trim()</span><br><span class="line">        // Shorten to 2 decimal places</span><br><span class="line">        .slice(0, value.indexOf(&apos;.&apos;) + 3)</span><br><span class="line">      // If the value was not already normalized,</span><br><span class="line">      // manually override it to conform</span><br><span class="line">      if (formattedValue !== value) &#123;</span><br><span class="line">        this.$refs.input.value = formattedValue</span><br><span class="line">      &#125;</span><br><span class="line">      // Emit the number value through the input event</span><br><span class="line">      this.$emit(&apos;input&apos;, Number(formattedValue))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的这个例子很天真，可以参考<a href="https://jsfiddle.net/chrisvfritz/1oqjojjx/?utm_source=website&amp;utm_medium=embed&amp;utm_campaign=1oqjojjx" target="_blank" rel="external">这个</a></p>
</blockquote>
<h3 id="非父子组件通信"><a href="#非父子组件通信" class="headerlink" title="非父子组件通信"></a>非父子组件通信</h3><blockquote>
<p>当两个不是父子关系的组件该如何通信呢？一个简单的场景，你可以创建一个vue空实例作为中央事<br>件汽车：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var bus = new Vue()</span><br><span class="line"></span><br><span class="line">// in component A&apos;s method</span><br><span class="line">bus.$emit(&apos;id-selected&apos;, 1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// in component B&apos;s created hook</span><br><span class="line">bus.$on(&apos;id-selected&apos;, function (id) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在更复杂的场景中，可以采用专门的<a href="https://vuejs.org/v2/guide/state-management.html" target="_blank" rel="external">事件管理模式</a></p>
</blockquote>
<h3 id="内容分发槽"><a href="#内容分发槽" class="headerlink" title="内容分发槽"></a>内容分发槽</h3><blockquote>
<p>当使用组件时，经常想要组合他们：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;app&gt;</span><br><span class="line">  &lt;app-header&gt;&lt;/app-header&gt;</span><br><span class="line">  &lt;app-footer&gt;&lt;/app-footer&gt;</span><br><span class="line">&lt;/app&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意两件事：</p>
<ol>
<li><code>&lt;app&gt;</code>组件不知道在其内部要呈现的内容是什么.</li>
<li><code>&lt;app&gt;</code>组件看起来像是有自己的模板。<br>使用特殊的<code>&lt;slot&gt;</code>元素。</li>
</ol>
</blockquote>
<h3 id="编辑范围"><a href="#编辑范围" class="headerlink" title="编辑范围"></a>编辑范围</h3><blockquote>
<p>想象一个这样的模板：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;child-component&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/child-component&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>message</code>会绑定到父组件的data还是子组件的data么？它会绑定到父组件的data。组件范围的一个<br>规则是：<br>在父模板中的一切都是在父模板范围内编译，在模板就是在子模板范围内编译。<br>一个常见的错误就是尝试在子模板中绑定一个子模板的property/method:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- does NOT work --&gt;</span><br><span class="line">&lt;child-component v-show=&quot;someChildProperty&quot;&gt;&lt;/child-component&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>假设<code>someChildProperty</code>是子组件的prop,上面的例子不能运行，因为父模板不会意识到子组件的<br>状态。如果你需要绑定子范围的指令到一个组件的根节点上，你需要在子组件范围的模板上绑定：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;child-component&apos;, &#123;</span><br><span class="line">  // this does work, because we are in the right scope</span><br><span class="line">  template: &apos;&lt;div v-show=&quot;someChildProperty&quot;&gt;Child&lt;/div&gt;&apos;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      someChildProperty: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="单个插槽"><a href="#单个插槽" class="headerlink" title="单个插槽"></a>单个插槽</h3><blockquote>
<p>父内容将会被抛弃除非子组件模板上至少包含一个<code>&lt;slot&gt;</code>插槽。当只有一个没任何属性的插槽时，<br>全部内容都会被替换。<code>&lt;slot&gt;</code>的原始内容会被作为回退内容，如果持有组件是空的或者没有内容<br>金额插入式回退内容才会显示。有一个<code>&lt;my-component&gt;</code>的组件：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h2&gt;I&apos;m the child title&lt;/h2&gt;</span><br><span class="line">  &lt;slot&gt;</span><br><span class="line">    This will only be displayed if there is no content</span><br><span class="line">    to be distributed.</span><br><span class="line">  &lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当一个父组件使用它时：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;I&apos;m the parent title&lt;/h1&gt;</span><br><span class="line">  &lt;my-component&gt;</span><br><span class="line">    &lt;p&gt;This is some original content&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;This is some more original content&lt;/p&gt;</span><br><span class="line">  &lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>渲染结果是：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;I&apos;m the parent title&lt;/h1&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;I&apos;m the child title&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;This is some original content&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;This is some more original content&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="命名的插槽"><a href="#命名的插槽" class="headerlink" title="命名的插槽"></a>命名的插槽</h3><blockquote>
<p><code>&lt;slot&gt;</code>有一个<code>name</code>属性，用来进一步定义内容如何被分配，你可以有多个不同名字的<code>&lt;slot&gt;</code>,<br>命名的<code>&lt;slot&gt;</code>将会匹配任何有相应的<code>slot</code>属性的元素。如果有没有名字的<code>&lt;slot&gt;</code>,它会匹配<br>任何没有被匹配上的内容，如果没有默认的<code>&lt;slot&gt;</code>,没有匹配上的内容将会被放弃。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>父标记：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;app-layout&gt;</span><br><span class="line">  &lt;h1 slot=&quot;header&quot;&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line">  &lt;p slot=&quot;footer&quot;&gt;Here&apos;s some contact info&lt;/p&gt;</span><br><span class="line">&lt;/app-layout&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>渲染的结果是：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;p&gt;Here&apos;s some contact info&lt;/p&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当设计组件组合时内容分发是一个有用的机制。</p>
</blockquote>
<h3 id="限定作用域的Slot"><a href="#限定作用域的Slot" class="headerlink" title="限定作用域的Slot"></a>限定作用域的Slot</h3><blockquote>
<p>2.1.0新出现的，限定作用域的slot是一种特殊的类型，作为一种可重用的模板用来代替已经渲染了<br>的元素。在子组件中，传递data给一个slot：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;child&quot;&gt;</span><br><span class="line">  &lt;slot text=&quot;hello from child&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在父组件中，<code>&lt;template&gt;</code>元素会持有一个特殊的<code>scope</code>属性来表示它是一个限定作用域的slot<br>模板，作用域的值是一个临时变量来掌控从子组件传递过来的data：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;child&gt;</span><br><span class="line">    &lt;template scope=&quot;props&quot;&gt;</span><br><span class="line">      &lt;span&gt;hello from parent&lt;/span&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它的渲染结果是：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">    &lt;span&gt;hello from parent&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;hello from child&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>列表中如何使用slot呢?</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-awesome-list :items=&quot;items&quot;&gt;</span><br><span class="line">  &lt;!-- scoped slot can be named too --&gt;</span><br><span class="line">  &lt;template slot=&quot;item&quot; scope=&quot;props&quot;&gt;</span><br><span class="line">    &lt;li class=&quot;my-fancy-item&quot;&gt;&#123;&#123; props.text &#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/my-awesome-list&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>list组件模板：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;slot name=&quot;item&quot;</span><br><span class="line">    v-for=&quot;item in items&quot;</span><br><span class="line">    :text=&quot;item.text&quot;&gt;</span><br><span class="line">    &lt;!-- fallback content here --&gt;</span><br><span class="line">  &lt;/slot&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<h3 id="动态的组件"><a href="#动态的组件" class="headerlink" title="动态的组件"></a>动态的组件</h3><blockquote>
<p>通过<code>is</code>属性动态的切换预定了的组件：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    currentView: &apos;home&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    home: &#123; /* ... */ &#125;,</span><br><span class="line">    posts: &#123; /* ... */ &#125;,</span><br><span class="line">    archive: &#123; /* ... */ &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;component v-bind:is=&quot;currentView&quot;&gt;</span><br><span class="line">  &lt;!-- component changes when vm.currentView changes! --&gt;</span><br><span class="line">&lt;/component&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者直接绑定组件对象：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var Home = &#123;</span><br><span class="line">  template: &apos;&lt;p&gt;Welcome home!&lt;/p&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    currentView: Home</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="保持活跃keep-alive"><a href="#保持活跃keep-alive" class="headerlink" title="保持活跃keep-alive"></a>保持活跃<code>keep-alive</code></h4><blockquote>
<p>如果你想在内存中保存切换出去的组件以避免重新渲染，可以使用<code>&lt;keep-alive&gt;</code>元素包装它：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component :is=&quot;currentView&quot;&gt;</span><br><span class="line">    &lt;!-- inactive components will be cached! --&gt;</span><br><span class="line">  &lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<a href="https://vuejs.org/v2/api/#keep-alive" target="_blank" rel="external">API引用</a>查阅详细信息</p>
</blockquote>
<h3 id="编写可重用组件"><a href="#编写可重用组件" class="headerlink" title="编写可重用组件"></a>编写可重用组件</h3><blockquote>
<p>当编写组件时应该思考后期会不会重用该组件，编写一次性的组件会紧耦合，编写可重用组件需要<br>思考写什么东西呢？有以下三点</p>
<ul>
<li>Props 允许外部环境传递props给组件</li>
<li>Events 允许在外部环境触发事件</li>
<li>Slots 允许外部环境组合具有额外内容的组件<br>在模板中可以清晰的传达出你的意图：</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  :foo=&quot;baz&quot;</span><br><span class="line">  :bar=&quot;qux&quot;</span><br><span class="line">  @event-a=&quot;doThis&quot;</span><br><span class="line">  @event-b=&quot;doThat&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;img slot=&quot;icon&quot; src=&quot;...&quot;&gt;</span><br><span class="line">  &lt;p slot=&quot;main-text&quot;&gt;Hello!&lt;/p&gt;</span><br><span class="line">&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>
<h3 id="子组件引用"><a href="#子组件引用" class="headerlink" title="子组件引用"></a>子组件引用</h3><blockquote>
<p>不管存在的props和events，有时候你需要在js中直接访问子组件，为了完成这个目标你需要给子组<br>件分配一个ref ID，然后通过<code>ref</code>来引用：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;user-profile ref=&quot;profile&quot;&gt;&lt;/user-profile&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var parent = new Vue(&#123; el: &apos;#parent&apos; &#125;)</span><br><span class="line">// access child component instance</span><br><span class="line">var child = parent.$refs.profile</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当<code>ref</code>和<code>v-for</code>一起使用时，你得到的ref将会是一个对象或数组,包含了子组件元数据的镜像。<br>注意：<code>$refs</code>在组件渲染之后才存在，并且它不是反应式的。你应该避免在模板以及属性计算中<br>使用<code>$refs</code></p>
</blockquote>
<h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><blockquote>
<p>在大型app中，我们会把组件拆成一个块，只有当需要的时候才会加载它，在Vue中很简单：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;async-example&apos;, function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    // Pass the component definition to the resolve callback</span><br><span class="line">    resolve(&#123;</span><br><span class="line">      template: &apos;&lt;div&gt;I am async!&lt;/div&gt;&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当从服务器得到组件的定义时调用<code>resolve</code>函数，调用<code>reject</code>表示获取组件定义失败。建议的<br>方式是使用<a href="http://webpack.github.io/docs/code-splitting.html" target="_blank" rel="external">Webpack的代码拆分特性</a>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;async-webpack-example&apos;, function (resolve) &#123;</span><br><span class="line">  // This special require syntax will instruct Webpack to</span><br><span class="line">  // automatically split your built code into bundles which</span><br><span class="line">  // are loaded over Ajax requests.</span><br><span class="line">  require([&apos;./my-async-component&apos;], resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用Es6语法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  &apos;async-webpack-example&apos;,</span><br><span class="line">  () =&gt; System.import(&apos;./my-async-component&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="组件命名惯例"><a href="#组件命名惯例" class="headerlink" title="组件命名惯例"></a>组件命名惯例</h3><blockquote>
<p>你可以使用驼峰式，<code>-</code>分界符等，Vue不关注这些：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// in a component definition</span><br><span class="line">components: &#123;</span><br><span class="line">  // register using kebab-case</span><br><span class="line">  &apos;kebab-cased-component&apos;: &#123; /* ... */ &#125;,</span><br><span class="line">  // register using camelCase</span><br><span class="line">  &apos;camelCasedComponent&apos;: &#123; /* ... */ &#125;,</span><br><span class="line">  // register using TitleCase</span><br><span class="line">  &apos;TitleCasedComponent&apos;: &#123; /* ... */ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在html的模板，需要使用<code>-</code>分界符命名规则：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- alway use kebab-case in HTML templates --&gt;</span><br><span class="line">&lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt;</span><br><span class="line">&lt;camel-cased-component&gt;&lt;/camel-cased-component&gt;</span><br><span class="line">&lt;title-cased-component&gt;&lt;/title-cased-component&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在字符串模板中也没有什么限制：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- use whatever you want in string templates! --&gt;</span><br><span class="line">&lt;my-component&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;myComponent&gt;&lt;/myComponent&gt;</span><br><span class="line">&lt;MyComponent&gt;&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你的模板不通过插槽传递内容，可以自闭合：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component/&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这个只能在字符串模板中 使用。</p>
</blockquote>
<h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><blockquote>
<p>在组建内部可以通过他们的模板来循环调用自己，这个是通过<code>name</code>选项工作的：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: &apos;unique-name-of-my-component&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当你使用<code>Vue.component</code>注册了一个全局组件，这个全局Id自动设置为组建的名字：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;unique-name-of-my-component&apos;, &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不小心，很有可能会引起无限循环：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: &apos;stack-overflow&apos;,</span><br><span class="line">template: &apos;&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样会引起栈溢出的，所以确保循环是有条件的。</p>
</blockquote>
<h3 id="组件之间的相互引用"><a href="#组件之间的相互引用" class="headerlink" title="组件之间的相互引用"></a>组件之间的相互引用</h3><blockquote>
<p>如果你在构建一个文件目录树，你有一个<code>tree-foler</code>组件有这样的一个模板：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">  &lt;span&gt;&#123;&#123; folder.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;tree-folder-contents :children=&quot;folder.children&quot;/&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后<code>tree-folder-contents</code>持有这样的一个模板：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;child in children&quot;&gt;</span><br><span class="line">    &lt;tree-folder v-if=&quot;child.children&quot; :folder=&quot;child&quot;/&gt;</span><br><span class="line">    &lt;span v-else&gt;&#123;&#123; child.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当你仔细看，会发现循环依赖了，也就是A need B， B need A等等，利用<code>beforeCreate</code>来解决<br>这个问题：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate: function () &#123;</span><br><span class="line">  this.$options.components.TreeFolderContents = require(&apos;./tree-folder-contents.vue&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="行内模板"><a href="#行内模板" class="headerlink" title="行内模板"></a>行内模板</h3><blockquote>
<p>建议在组建中通过<code>template</code>使用模板。</p>
</blockquote>
<h3 id="X-Templates"><a href="#X-Templates" class="headerlink" title="X-Templates"></a>X-Templates</h3><blockquote>
<p>用<code>text/x-template</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt;</span><br><span class="line">  &lt;p&gt;Hello hello hello&lt;/p&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;hello-world&apos;, &#123;</span><br><span class="line">  template: &apos;#hello-world-template&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个也不建议使用，因为它分离了组件的其它定义。</p>
</blockquote>
<h3 id="Cheap-Static-Components-with-v-once"><a href="#Cheap-Static-Components-with-v-once" class="headerlink" title="Cheap Static Components with v-once"></a>Cheap Static Components with v-once</h3><blockquote>
<p>在Vue中渲染简单的Html元素是很快的，但是有时候你需要渲染一个包含大量静态内容的组件。在这<br>种情况下可以使用<code>v-once</code>指令到根元素来解析一次并缓存：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;terms-of-service&apos;, &#123;</span><br><span class="line">  template: &apos;\</span><br><span class="line">    &lt;div v-once&gt;\</span><br><span class="line">      &lt;h1&gt;Terms of Service&lt;/h1&gt;\</span><br><span class="line">      ... a lot of static content ...\</span><br><span class="line">    &lt;/div&gt;\</span><br><span class="line">  &apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/30/vue/components/" data-id="ciw58i9y90036uko0rdl6r1c4" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/form_input" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/30/vue/form_input/" class="article-date">
  <time datetime="2016-11-29T17:17:23.058Z" itemprop="datePublished">2016-11-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/30/vue/form_input/">form input绑定</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><blockquote>
<p>可以在form表单中的input和textarea中使用<code>v-model</code>指令创建双向绑定。它会自动的挑选正确的<br>方式来更新基于input类型的元素。<code>v-model</code>本质上是基于用户输入事件来更改data的语法糖，以及<br>对一些边缘情况的特殊照顾。<code>v-model</code>不会关心input或textarea的初始值，它只会处理vue实例<br>的data。</p>
</blockquote>
<h4 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;</span><br><span class="line">&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>input输入框的值是’edit me’</p>
</blockquote>
<h4 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;Multiline message is:&lt;/span&gt;</span><br><span class="line">&lt;p style=&quot;white-space: pre&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在textarea插入文本值<code>&lt;textarea&gt;&lt;/textarea&gt;</code>不会工作，使用<code>v-model</code>代替。</p>
</blockquote>
<h4 id="Checkbox"><a href="#Checkbox" class="headerlink" title="Checkbox"></a>Checkbox</h4><blockquote>
<p>单个复选框，布尔值：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;</span><br><span class="line">&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多个复选框，绑定同一个数组：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class="line">&lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class="line">&lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class="line">&lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;...&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    checkedNames: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="Radio"><a href="#Radio" class="headerlink" title="Radio"></a>Radio</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;</span><br><span class="line">&lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;</span><br><span class="line">&lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select v-model=&quot;selected&quot;&gt;</span><br><span class="line">  &lt;option&gt;A&lt;/option&gt;</span><br><span class="line">  &lt;option&gt;B&lt;/option&gt;</span><br><span class="line">  &lt;option&gt;C&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多个选择，绑定数组：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select v-model=&quot;selected&quot; multiple&gt;</span><br><span class="line">  &lt;option&gt;A&lt;/option&gt;</span><br><span class="line">  &lt;option&gt;B&lt;/option&gt;</span><br><span class="line">  &lt;option&gt;C&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过<code>v-for</code>动态渲染的选项：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select v-model=&quot;selected&quot;&gt;</span><br><span class="line">  &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt;</span><br><span class="line">    &#123;&#123; option.text &#125;&#125;</span><br><span class="line">  &lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Value-Bindings"><a href="#Value-Bindings" class="headerlink" title="Value Bindings"></a>Value Bindings</h3><blockquote>
<p>对于radio,checkbox,select选项，<code>v-modle</code>的绑定值通常是静态的字符串（checkbox是布尔值）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- `picked` is a string &quot;a&quot; when checked --&gt;</span><br><span class="line">&lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;a&quot;&gt;</span><br><span class="line">&lt;!-- `toggle` is either true or false --&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot;&gt;</span><br><span class="line">&lt;!-- `selected` is a string &quot;abc&quot; when selected --&gt;</span><br><span class="line">&lt;select v-model=&quot;selected&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;abc&quot;&gt;ABC&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是有时候，我们需要绑定vue实例的动态的属性的值，我们可以通过<code>v-bind</code>来达到这个目的,<br>使用<code>v-bind</code>允许我们绑定input值为非字符串。</p>
</blockquote>
<h4 id="Checkbox-1"><a href="#Checkbox-1" class="headerlink" title="Checkbox"></a>Checkbox</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  type=&quot;checkbox&quot;</span><br><span class="line">  v-model=&quot;toggle&quot;</span><br><span class="line">  v-bind:true-value=&quot;a&quot;</span><br><span class="line">  v-bind:false-value=&quot;b&quot;</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">// when checked:</span><br><span class="line">vm.toggle === vm.a</span><br><span class="line">// when unchecked:</span><br><span class="line">vm.toggle === vm.b</span><br></pre></td></tr></table></figure>
<h4 id="Radio-1"><a href="#Radio-1" class="headerlink" title="Radio"></a>Radio</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; v-bind:value=&quot;a&quot;&gt;</span><br><span class="line"></span><br><span class="line">// when checked:</span><br><span class="line">vm.pick === vm.a</span><br></pre></td></tr></table></figure>
<h4 id="Select-Options"><a href="#Select-Options" class="headerlink" title="Select Options"></a>Select Options</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;select v-model=&quot;selected&quot;&gt;</span><br><span class="line">  &lt;!-- inline object literal --&gt;</span><br><span class="line">  &lt;option v-bind:value=&quot;&#123; number: 123 &#125;&quot;&gt;123&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">// when selected:</span><br><span class="line">typeof vm.selected // -&gt; &apos;object&apos;</span><br><span class="line">vm.selected.number // -&gt; 123</span><br></pre></td></tr></table></figure>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h4><blockquote>
<p>默认情况下，<code>v-model</code>在输入事件后同步输入值，你可以添加<code>.lazy</code>修饰符开代替<code>change</code>事件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- synced after &quot;change&quot; instead of &quot;input&quot; --&gt;</span><br><span class="line">&lt;input v-model.lazy=&quot;msg&quot; &gt;</span><br></pre></td></tr></table></figure>
<h4 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h4><blockquote>
<p>如果你想要用户输入自动转换为数字，以可以添加在<code>v-model</code>后添加<code>number</code>修饰符来控制输入</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个很有用，因为<code>type=&quot;number&quot;</code>返回的是一个字符串。</p>
</blockquote>
<h4 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h4><blockquote>
<p>如果你想自动的去掉用户输入的空格，可以在<code>v-model</code>后添加’.trim’来控制用户输入</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.trim=&quot;msg&quot;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="v-model-with-Components"><a href="#v-model-with-Components" class="headerlink" title="v-model with Components"></a>v-model with Components</h3><blockquote>
<p>Html的内置输入类型总是不能满足你的需求，幸运的是，Vue组件允许你构建具有完全自定义行为的<br>input,这些input实际上工作方式还是<code>v-model</code>,可以在自定义input中了解。</p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/30/vue/form_input/" data-id="ciw58i9yi003guko0yvnuwfq0" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/event_handle" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/29/vue/event_handle/" class="article-date">
  <time datetime="2016-11-29T15:36:58.389Z" itemprop="datePublished">2016-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/29/vue/event_handle/">事件处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="事件的监听"><a href="#事件的监听" class="headerlink" title="事件的监听"></a>事件的监听</h3><blockquote>
<p>可以使用<code>v-on</code>指令来监听DOM事件并执行js函数，例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example-1&quot;&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt;</span><br><span class="line">  &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var example1 = new Vue(&#123;</span><br><span class="line">  el: &apos;#example-1&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="事件处理方法"><a href="#事件处理方法" class="headerlink" title="事件处理方法"></a>事件处理方法</h3><blockquote>
<p>如果时间处理函数的逻辑很复杂，那么在<code>v-on</code>属性上写js是不可行的，所以<code>v-on</code>指令接受一个<br>你要执行的方法名：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example-2&quot;&gt;</span><br><span class="line">  &lt;!-- `greet` is the name of a method defined below --&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var example2 = new Vue(&#123;</span><br><span class="line">  el: &apos;#example-2&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: &apos;Vue.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  // define methods under the `methods` object</span><br><span class="line">  methods: &#123;</span><br><span class="line">    greet: function (event) &#123;</span><br><span class="line">      // `this` inside methods points to the Vue instance</span><br><span class="line">      alert(&apos;Hello &apos; + this.name + &apos;!&apos;)</span><br><span class="line">      // `event` is the native DOM event</span><br><span class="line">      alert(event.target.tagName)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// you can invoke methods in JavaScript too</span><br><span class="line">example2.greet() // -&gt; &apos;Hello Vue.js!&apos;</span><br></pre></td></tr></table></figure>
<h3 id="行内处理方法"><a href="#行内处理方法" class="headerlink" title="行内处理方法"></a>行内处理方法</h3><blockquote>
<p>我们也可以使用行内的js语法而不是直接绑定函数名：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example-3&quot;&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;say(&apos;hi&apos;)&quot;&gt;Say hi&lt;/button&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;say(&apos;what&apos;)&quot;&gt;Say what&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#example-3&apos;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    say: function (message) &#123;</span><br><span class="line">      alert(message)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有时候我们需要在行内访问原始DOM的事件，你可以使用<code>$event</code>传递给函数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click=&quot;warn(&apos;Form cannot be submitted yet.&apos;, $event)&quot;&gt;Submit&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line">methods: &#123;</span><br><span class="line">  warn: function (message, event) &#123;</span><br><span class="line">    // now we have access to the native event</span><br><span class="line">    if (event) event.preventDefault()</span><br><span class="line">    alert(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><blockquote>
<p>在事件处理中调用<code>event.preventDefault</code>或者<code>event.stopPropagation()</code>是很常见的需要。<br>虽然我们可以在方法中处理，但是保持方法的纯净是很有必要的，我们只需要处理数据相关的逻辑<br>不用关心DOM的逻辑，为了解决这个问题，Vue为<code>v-on</code>提供了事件修饰符,它由一个后缀<code>.</code>表示：</p>
<ul>
<li>.stop</li>
<li>.prevent</li>
<li>.capture</li>
<li>.self</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- the click event&apos;s propagation will be stopped --&gt;</span><br><span class="line">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- the submit event will no longer reload the page --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class="line">&lt;!-- modifiers can be chained --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- just the modifier --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class="line">&lt;!-- use capture mode when adding the event listener --&gt;</span><br><span class="line">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class="line">&lt;!-- only trigger handler if event.target is the element itself --&gt;</span><br><span class="line">&lt;!-- i.e. not from a child element --&gt;</span><br><span class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Key修饰符"><a href="#Key修饰符" class="headerlink" title="Key修饰符"></a>Key修饰符</h3><blockquote>
<p>当监听键盘事件时，我们需要查看key code,Vue也为<code>v-on</code>提供了键盘事件的修饰符：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- only call vm.submit() when the keyCode is 13 --&gt;</span><br><span class="line">&lt;input v-on:keyup.13=&quot;submit&quot;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>技术所有的key code是很难的，为此Vue提供了常用key code的别名：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- same as above --&gt;</span><br><span class="line">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;</span><br><span class="line">&lt;!-- also works for shorthand --&gt;</span><br><span class="line">&lt;input @keyup.enter=&quot;submit&quot;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里是键盘事件的别名列表</p>
<ul>
<li>.enter</li>
<li>.tab</li>
<li>.delete</li>
<li>.esc</li>
<li>.space</li>
<li>.up</li>
<li>.down</li>
<li>.left</li>
<li>.right<br>你也可以通过全局<code>config.keyCodes</code>对象自定义键盘事件修饰符：</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// enable v-on:keyup.f1</span><br><span class="line">Vue.config.keyCodes.f1 = 112</span><br></pre></td></tr></table></figure>
<h3 id="鼠标事件修饰符"><a href="#鼠标事件修饰符" class="headerlink" title="鼠标事件修饰符"></a>鼠标事件修饰符</h3><blockquote>
<p>2.1.0新出来的，当相关的建按下时，你可以使用一下的别名修饰符监听鼠标事件：</p>
<ul>
<li>.ctrl</li>
<li>.alt</li>
<li>.shift</li>
<li>.meta</li>
</ul>
</blockquote>
<h3 id="Why-Listeners-in-HTML"><a href="#Why-Listeners-in-HTML" class="headerlink" title="Why Listeners in HTML?"></a>Why Listeners in HTML?</h3><blockquote>
<p>你可能关心整个事件监听方式违反了”关注点分离”原则，放心，由于所有的事件处理函数和表达式<br>严格的绑定在当前正在处理的视图上，不会引起维护困难，事实上使用<code>v-on</code>有以下优点：</p>
<ol>
<li>通过略读Html模板可以很容易在js找到事件处理函数</li>
<li>由于你不用手动在js中添加事件监听，ViewModel代码是纯粹的逻辑，易于测试。</li>
<li>当ViewModel销毁时，所有的事件监听都会自动的被移除，你不需要自己去清理</li>
</ol>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/29/vue/event_handle/" data-id="ciw58i9yg003euko0gcnxl1dp" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/list_render" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/29/vue/list_render/" class="article-date">
  <time datetime="2016-11-29T10:56:17.881Z" itemprop="datePublished">2016-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/29/vue/list_render/">Vue的列表渲染</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><blockquote>
<p>使用<code>v-for</code>指令渲染基于数组的列表，<code>v-for</code>的语法格式为<code>item in items</code>,<code>items</code>是data<br>里的属性，<code>item</code>是每个数组中每个元素的别名。</p>
</blockquote>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;example-1&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in items&quot;&gt;</span><br><span class="line">    &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">var example1 = new Vue(&#123;</span><br><span class="line">  el: &apos;#example-1&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [</span><br><span class="line">      &#123; message: &apos;Foo&apos; &#125;,</span><br><span class="line">      &#123; message: &apos;Bar&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>v-for</code>块里，有到父属性范围的访问权限，<code>v-for</code>也支持一个可选的第二个参数，用来表示当前<br>元素的索引:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;example-2&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;(item, index) in items&quot;&gt;</span><br><span class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">var example2 = new Vue(&#123;</span><br><span class="line">  el: &apos;#example-2&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    parentMessage: &apos;Parent&apos;,</span><br><span class="line">    items: [</span><br><span class="line">      &#123; message: &apos;Foo&apos; &#125;,</span><br><span class="line">      &#123; message: &apos;Bar&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以使用<code>of</code>代替<code>in</code>作为定界符，这更接近js中迭代器的语法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="模板v-for"><a href="#模板v-for" class="headerlink" title="模板v-for"></a>模板<code>v-for</code></h3><blockquote>
<p>和模板<code>v-if</code>相似，可以在<code>&lt;template&gt;</code>中使用<code>v-for</code>用来渲染多个元素的块，比如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;template v-for=&quot;item in items&quot;&gt;</span><br><span class="line">    &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<h3 id="对象v-for"><a href="#对象v-for" class="headerlink" title="对象v-for"></a>对象<code>v-for</code></h3><blockquote>
<p>也可以使用<code>v-for</code>来迭代一个对象的所有属性：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;repeat-object&quot; class=&quot;demo&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;value in object&quot;&gt;</span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#repeat-object&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    object: &#123;</span><br><span class="line">      FirstName: &apos;John&apos;,</span><br><span class="line">      LastName: &apos;Doe&apos;,</span><br><span class="line">      Age: 30</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以对这个<code>key</code>提供第二个参数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;(value, key) in object&quot;&gt;</span><br><span class="line">  &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以及相应的索引：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;(value, key, index) in object&quot;&gt;</span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="范围性的v-for"><a href="#范围性的v-for" class="headerlink" title="范围性的v-for"></a>范围性的<code>v-for</code></h3><blockquote>
<p><code>v-for</code>也接收一个整数，在这种场景中，它会重复渲染此模板多次：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="组件和v-for"><a href="#组件和v-for" class="headerlink" title="组件和v-for"></a>组件和<code>v-for</code></h3><blockquote>
<p>可以在自定义组件中使用<code>v-for</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-for=&quot;item in items&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然而这不会将任何数据自动的传递给组件，因为组件有独立的基于它自己的作用域，为了将一个可迭代<br>的数据传递个给组件，需要使用属性：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-for=&quot;(item, index) in items&quot;</span><br><span class="line">  v-bind:item=&quot;item&quot;</span><br><span class="line">  v-bind:index=&quot;index&quot;&gt;</span><br><span class="line">&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不自动注入<code>item</code>到组件的原因是这会使组件紧耦合于<code>v-for</code>是如何工作的。为了明确data的<br>来源并使组件在其他情况下也可复用，这里有个例子：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;todo-list-example&quot;&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    v-model=&quot;newTodoText&quot;</span><br><span class="line">    v-on:keyup.enter=&quot;addNewTodo&quot;</span><br><span class="line">    placeholder=&quot;Add a todo&quot;</span><br><span class="line">  &gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">      is=&quot;todo-item&quot;</span><br><span class="line">      v-for=&quot;(todo, index) in todos&quot;</span><br><span class="line">      v-bind:title=&quot;todo&quot;</span><br><span class="line">      v-on:remove=&quot;todos.splice(index, 1)&quot;</span><br><span class="line">    &gt;&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;todo-item&apos;, &#123;</span><br><span class="line">  template: &apos;\</span><br><span class="line">    &lt;li&gt;\</span><br><span class="line">      &#123;&#123; title &#125;&#125;\</span><br><span class="line">      &lt;button v-on:click=&quot;$emit(\&apos;remove\&apos;)&quot;&gt;X&lt;/button&gt;\</span><br><span class="line">    &lt;/li&gt;\</span><br><span class="line">  &apos;,</span><br><span class="line">  props: [&apos;title&apos;]</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#todo-list-example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    newTodoText: &apos;&apos;,</span><br><span class="line">    todos: [</span><br><span class="line">      &apos;Do the dishes&apos;,</span><br><span class="line">      &apos;Take out the trash&apos;,</span><br><span class="line">      &apos;Mow the lawn&apos;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addNewTodo: function () &#123;</span><br><span class="line">      this.todos.push(this.newTodoText)</span><br><span class="line">      this.newTodoText = &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><blockquote>
<p>当Vue更新一个由<code>v-for</code>渲染的列表时，默认情况下使用的是”原地修补”的策略，如果数据列表的<br>顺序改变了，移动DOM元素来匹配最新的顺序，Vue会原地简单的修正每一个元素确保特定索引初应该<br>渲染什么。这种默认方式是有效率的，但是只适用于你的列表渲染不依赖于子组件或临时DOM状态（例<br>如，input输入值）。你需要给每一个节点提供一个唯一的<code>key</code>属性，给Vue一个线索以便可以追踪<br>每个节点的身份，从而复用且重排序存在的节点.你需要使用<code>v-bind</code>来绑定动态的值，在这里使用<br>的是简写形式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">  &lt;!-- content --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不管是否需要建议给<code>v-for</code>提供一个<code>key</code>,除非迭代的DOM内容很简单，或者你故意依赖默认行为来<br>提高性能增益。由于它是Vue标识节点的通用机制，<code>key</code>还有其它用途不仅仅是很<code>v-for</code>相关联。</p>
</blockquote>
<h3 id="数组改变的探测"><a href="#数组改变的探测" class="headerlink" title="数组改变的探测"></a>数组改变的探测</h3><h4 id="突变方法"><a href="#突变方法" class="headerlink" title="突变方法"></a>突变方法</h4><blockquote>
<p>Vue包装了观察数组突变的方法，所以它们也会触发视图的更新，包装的方法有：</p>
<ul>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()<br>可以在浏览器的控制台中调用这些突变方法，比如： <code>example1.items.push({ message: &#39;Baz&#39; })</code></li>
</ul>
</blockquote>
<h4 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h4><blockquote>
<p>突变方法，顾名思义就是调用这些方法之后改变的是原始数组。和不是突变的方法相比较，比如：<br><code>filter()</code>, <code>concat()</code>,他们不改变原始数组而是返回一个新数组，当使用非突变方法时，你需<br>要用新数组替换原始数组：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example1.items = example1.items.filter(function (item) &#123;</span><br><span class="line">  return item.message.match(/Foo/)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Vue实现了一些智能的启发式技术来最大化的复用DOM元素，所以替换一个数组是一个非常有效的操作。</p>
</blockquote>
<h4 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h4><blockquote>
<p>由于js的限制，Vue不能发现以下数组的改变：</p>
<ol>
<li>直接通过索引给数组赋值，比如：<code>vm.items[indexOfItem] = newValue</code></li>
<li>改变数组的长度。 比如： <code>vm.items.length = newLength</code><br>为了克服警告1，下面的两种方式完成的效果和<code>vm.items[indexOfItem] = newValue</code>是一样的,<br>但是会触发反应系统：</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Vue.set</span><br><span class="line">Vue.set(example1.items, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line">// Array.prototype.splice`</span><br><span class="line">example1.items.splice(indexOfItem, 1, newValue)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>处理警告2的方式，也使用<code>splice</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example1.items.splice(newLength)</span><br></pre></td></tr></table></figure>
<h3 id="排序或筛选结果的显示"><a href="#排序或筛选结果的显示" class="headerlink" title="排序或筛选结果的显示"></a>排序或筛选结果的显示</h3><blockquote>
<p>有时候我们需要显示数字的筛选或排序结果没有必要去重置原始数组，在这种情况下，使用属性的计算<br>来返回筛选的或者排序好的数组：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;n in evenNumbers&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  numbers: [ 1, 2, 3, 4, 5 ]</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  evenNumbers: function () &#123;</span><br><span class="line">    return this.numbers.filter(function (number) &#123;</span><br><span class="line">      return number % 2 === 0</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;n in even(numbers)&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  numbers: [ 1, 2, 3, 4, 5 ]</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  even: function (numbers) &#123;</span><br><span class="line">    return numbers.filter(function (number) &#123;</span><br><span class="line">      return number % 2 === 0</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/29/vue/list_render/" data-id="ciw58i9ym003luko08m1md53k" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/conditional_render" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/29/vue/conditional_render/" class="article-date">
  <time datetime="2016-11-29T10:14:00.554Z" itemprop="datePublished">2016-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/29/vue/conditional_render/">条件渲染</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><blockquote>
<p>在字符串模板中，我们需要按照下面的方式写一个条件块：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Handlebars template --&gt;</span><br><span class="line">&#123;&#123;#if ok&#125;&#125;</span><br><span class="line">  &lt;h1&gt;Yes&lt;/h1&gt;</span><br><span class="line">&#123;&#123;/if&#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Vue中，我们使用<code>v-if</code>指令来得到相同的效果：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然可以使用<code>v-else</code>指令来添加”else”块：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;No&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<h3 id="在中添加v-if条件组"><a href="#在中添加v-if条件组" class="headerlink" title="在中添加v-if条件组"></a>在<template>中添加<code>v-if</code>条件组</template></h3><blockquote>
<p>因为<code>v-if</code>是一个指令，它需要附属在一个元素上，但是当我们需要切换不止一个元素时怎么办呢？<br>在这种情况下，我们需要使用在<code>&lt;template&gt;</code>中使用<code>v-if</code>，作为一个看不见的包装，最终的渲染<br>结果是不包含<code>&lt;template&gt;</code>元素：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;ok&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Title&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 1&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 2&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h4 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h4><blockquote>
<p>可以使用<code>v-else</code>指令来指出一个<code>v-if</code>的”else 块”：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;</span><br><span class="line">  Now you see me</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Now you don&apos;t</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>v-else</code>指令必须跟在<code>v-if</code>或<code>v-else-if</code>元素后面，否则它不会起作用。</p>
</blockquote>
<h4 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h4><blockquote>
<p>在2.1.0中新添加的特性，可以多次链式的使用：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;</span><br><span class="line">  A</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;</span><br><span class="line">  B</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt;</span><br><span class="line">  C</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Not A/B/C</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样必须跟在<code>v-if</code>或<code>v-else-if</code>元素后面。</p>
</blockquote>
<h3 id="通过key控制元素的复用"><a href="#通过key控制元素的复用" class="headerlink" title="通过key控制元素的复用"></a>通过<code>key</code>控制元素的复用</h3><blockquote>
<p>Vue尝试尽可能高效的渲染元素，经常重新使用它们而不是重新从零开始渲染他们，为了使Vue更快<br>这儿有一些有用的优点，比如，允许用户切换等了类型：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your username&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your email address&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后切换<code>loginType</code>,将不会擦除用户已经输入的内容，因为两个模板都使用了同一个<code>&lt;input&gt;</code><br>改变的仅仅是<code>placeholder</code>.这样不是很好，Vue提供了一种方式来完善这个缺点，只需要添加<br>一个唯一的<code>key</code>属性：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<code>&lt;label&gt;</code>还是会重用的，因为它们有<code>key</code>属性。</p>
</blockquote>
<h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><blockquote>
<p><code>v-show</code>是一个有条件显示一个元素的指令，它的用法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>区别是一个带有<code>v-show</code>的元素会在DOM中渲染并保留在DOM中，<code>v-show</code>仅仅是改变元素的<code>display</code><br>属性，<strong>注意:</strong>,<code>v-show</code>不支持<code>&lt;template&gt;</code>，与不与<code>v-else</code>一起工作。</p>
</blockquote>
<h4 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if vs v-show</h4><blockquote>
<p><code>v-if</code>条件为真时才渲染因为他要保证在切换过程中事件监听以及子组件正确的销毁并重建。<br><code>v-if</code>是”懒惰的”,如果在初始渲染时，条件为false，它不会干任何事，只有当条件为true时，<br>才会渲染。<br><code>v-show</code>的元素会不管初始条件渲染，它仅仅是基本的CSS切换。<br>通常来讲，<code>v-if</code>切换时有较高的消耗，而<code>v-show</code>在初始化的时候有较高的消耗，如果你需要经常<br>切换选择<code>v-show</code>,如果在运行时不太可能改变则选择<code>v-if</code></p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/29/vue/conditional_render/" data-id="ciw58i9yp003ouko0rfapcno4" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/style_class_binding" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/29/vue/style_class_binding/" class="article-date">
  <time datetime="2016-11-29T08:47:31.342Z" itemprop="datePublished">2016-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/29/vue/style_class_binding/">样式绑定</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Class和Style的绑定"><a href="#Class和Style的绑定" class="headerlink" title="Class和Style的绑定"></a>Class和Style的绑定</h3><blockquote>
<p>对数据绑定的共同需求是操纵元素的列表样式及行内样式，由于他们都是属性，可以通过<code>v-bind</code><br>来处理他们。当<code>v-bind</code>绑定的是<code>class</code>以及<code>style</code>时，除了字符串，表达式也可以被评估为<br>对象或者数组。</p>
</blockquote>
<h3 id="绑定HTML的类"><a href="#绑定HTML的类" class="headerlink" title="绑定HTML的类"></a>绑定HTML的类</h3><h4 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h4><blockquote>
<p>我们可以传递一个对象给<code>v-bind:class</code>来动态的切换class：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的语法意味着class的存在由<code>isActive</code>是否为真决定。可以通过对象中的多个字段来切换多个<br>类，另外<code>v-bind:class</code>指令可以与<code>class</code>属性共同存在，下面的例子：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;static&quot;</span><br><span class="line">     v-bind:class=&quot;&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以及相应的数据对象：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它的渲染结果是：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当<code>isActive</code>和<code>hasError</code>改变时，类列表页会相应的变化，比如，当<code>hasError</code>为<code>true</code>时，<br>相应的类列表会变为<code>&quot;static active text-danger&quot;</code>.<br>绑定的对象不一定非得内联：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: true,</span><br><span class="line">    &apos;text-danger&apos;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>渲染结果是相同的，我们也可以绑定一个返回对象的计算属性，例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  error: null</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      active: this.isActive &amp;&amp; !this.error,</span><br><span class="line">      &apos;text-danger&apos;: this.error &amp;&amp; this.error.type === &apos;fatal&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h4><blockquote>
<p>我们可以传递一个数组给<code>v-bind:class</code>应用于类列表：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: &apos;active&apos;,</span><br><span class="line">  errorClass: &apos;text-danger&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它的渲染结果是:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你想在列表中有条件的切换类，你可以使用三元运算符：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>errorClass</code>会一直应用，但是只有当<code>isActive</code>为真时<code>activeClass</code>才会被应用。但是当你<br>有多个条件切换的类在列表中会有点罗嗦，可以在列表语法中使用对象语法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="With-Components"><a href="#With-Components" class="headerlink" title="With Components"></a>With Components</h3><blockquote>
<p>当你在自定义组建中使用<code>class</code>属性时，类将会被添加到组件的根节点上，该元素已存在的类不会<br>被覆盖，比如，你这么声明一个组件：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在使用它时又添加了一些类：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最终的渲染结果是：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于类绑定也是同样的效果：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当<code>isActive</code>为true时，渲染结果为：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;foo bar active&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h3 id="行内样式的绑定"><a href="#行内样式的绑定" class="headerlink" title="行内样式的绑定"></a>行内样式的绑定</h3><h4 id="类语法"><a href="#类语法" class="headerlink" title="类语法"></a>类语法</h4><blockquote>
<p><code>v-bind:style</code>的对象语法简单易懂，看起来很像CSS，你可以使用驼峰式或者”-“形式的属性命名:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: &apos;red&apos;,</span><br><span class="line">  fontSize: 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>直接绑定一个样式对象让模板看起来很干净是一个好主意：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: &apos;red&apos;,</span><br><span class="line">    fontSize: &apos;13px&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对象语法经常结合返回对象的计算属性来使用。</p>
</blockquote>
<h4 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h4><blockquote>
<p><code>v-bind:style</code>的数组语法允许你对一个元素应用多个样式对象：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Auto-prefixing-自动添加前缀"><a href="#Auto-prefixing-自动添加前缀" class="headerlink" title="Auto-prefixing(自动添加前缀)"></a>Auto-prefixing(自动添加前缀)</h4><blockquote>
<p>当你在<code>v-bind:style</code>中使用一个需要添加供应商前缀的属性时，Vue会自动的检测出并且添加一个<br>合适的前缀来应用该样式，比如<code>transform</code></p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/29/vue/style_class_binding/" data-id="ciw58i9yz003quko0yb7j4nd7" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/computed_properties" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/29/vue/computed_properties/" class="article-date">
  <time datetime="2016-11-29T06:24:55.080Z" itemprop="datePublished">2016-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/29/vue/computed_properties/">Vue属性的计算及监听器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Vue属性计算及监听器"><a href="#Vue属性计算及监听器" class="headerlink" title="Vue属性计算及监听器"></a>Vue属性计算及监听器</h3><h3 id="属性计算"><a href="#属性计算" class="headerlink" title="属性计算"></a>属性计算</h3><blockquote>
<p>模板内使用表达式是很方便的，但只是对于简单的操作。如果在模板中放入大量的逻辑，只会让模板<br>变得庞大且难以管理：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你需要看一会才知道这个模板显示的是倒序的字符串，如果你要在模板中多次使用的话，这会变得很<br>糟糕。对于复杂逻辑，应该使用属性的计算。</p>
</blockquote>
<h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // a computed getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` points to the vm instance</span><br><span class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里我们已经宣布了一个计算的属性<code>reversedMessage</code>,我们提供的这个函数和属性的getter函数<br>类似<code>rm.reversedMessage</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(vm.reversedMessage) // -&gt; &apos;olleH&apos;</span><br><span class="line">vm.message = &apos;Goodbye&apos;</span><br><span class="line">console.log(vm.reversedMessage) // -&gt; &apos;eybdooG&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>vm.reversedMessage</code>的值依赖于<code>vm.message</code>的值。你可以将计算的属性像普通属性一样绑定到<br>模板上，Vue会意识到<code>vm.reversedMessage</code>依赖<code>vm.message</code>,所以当<code>vm.message</code>改变的时候<br>修改对应绑定的<code>vm.reversedMessage</code>的值，当然最好的部分是我们已经以声明的方式创建了依赖<br>关系:计算的getter函数是纯函数并且没有副作用，这样可以很轻松的测试。</p>
</blockquote>
<h3 id="计算的缓存VS方法"><a href="#计算的缓存VS方法" class="headerlink" title="计算的缓存VS方法"></a>计算的缓存VS方法</h3><blockquote>
<p>你可能已经注意到我们可以通过在表达式中调用方法得到相同的结果：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Reversed message: &quot;&#123;&#123; reverseMessage() &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// in component</span><br><span class="line">methods: &#123;</span><br><span class="line">  reverseMessage: function () &#123;</span><br><span class="line">    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以定义一个方法来代替属性的计算。对于最终结果，这两种方式确实完全相同。但是，不同之<br>处是，计算的属性会缓存基于它的依赖，一个计算的属性只有当它的依赖项发生改变时才会重新计算<br>这意味着只要<code>message</code>没有改变，多次访问计算的属性<code>reversedMessage</code>会返回上次计算的结果<br>而不是重新运行该函数。下面的计算的属性永远不会发生变化，因为<code>Date.now()</code>不是一个反应式<br>的依赖项：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  now: function () &#123;</span><br><span class="line">    return Date.now()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>作为比较，不管是否重新渲染，一个方法的调用都需要重新运行该方法。我们为什么需要缓存呢？<br>想象一个非常耗时的计算属性A，它需要在一个很大的数组中循环并且进行大量的计算，然后可能有<br>其余的计算属性依赖于A的计算属性，如果没有还从的话，我们将毫无必要的执行多次A的计算，当在<br>不需要使用缓存的情况下，使用方法代替。</p>
</blockquote>
<h3 id="计算的属性VS监听的属性"><a href="#计算的属性VS监听的属性" class="headerlink" title="计算的属性VS监听的属性"></a>计算的属性VS监听的属性</h3><blockquote>
<p>Vue确实提供了一种通用的方法来观察Vue实例中data的变化做出反应：<code>watch properties</code>.当你<br>的一些数据需要基于其它一些数据做出改变时，可以尝试使用<code>watch</code>属性。但是使用属性的计算相对<br>来说更好一点，考虑下面的例子：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Foo&apos;,</span><br><span class="line">    lastName: &apos;Bar&apos;,</span><br><span class="line">    fullName: &apos;Foo Bar&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: function (val) &#123;</span><br><span class="line">      this.fullName = val + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: function (val) &#123;</span><br><span class="line">      this.fullName = this.firstName + &apos; &apos; + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的代码有重复，和属性的计算相比较：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Foo&apos;,</span><br><span class="line">    lastName: &apos;Bar&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: function () &#123;</span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样更好一点。</p>
</blockquote>
<h3 id="计算属性的Setter"><a href="#计算属性的Setter" class="headerlink" title="计算属性的Setter"></a>计算属性的Setter</h3><blockquote>
<p>默认情况下计算的属性时只读的，但是当你需要时你可以提供一个setter函数：    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    // getter</span><br><span class="line">    get: function () &#123;</span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    // setter</span><br><span class="line">    set: function (newValue) &#123;</span><br><span class="line">      var names = newValue.split(&apos; &apos;)</span><br><span class="line">      this.firstName = names[0]</span><br><span class="line">      this.lastName = names[names.length - 1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在当你执行<code>vm.fullName = &#39;John Doe&#39;</code>,setter函数将会被执行，相应的<code>vm.firstName</code>和<br><code>vm.lastName</code>也会改变。</p>
</blockquote>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><blockquote>
<p>虽然在多数情况下，属性的计算是很合适的，但是有时候自定义监听器也是有必要的。这也是为什么<br>Vue提供了一个同用的方式，通过<code>watch</code>选项来对数据的变化做出反应。当你要响应不断变化的数据<br>执行异步操作或者昂贵操作的时候很有用。例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;watch-example&quot;&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    &lt;input v-model=&quot;question&quot;&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Since there is already a rich ecosystem of ajax libraries    --&gt;</span><br><span class="line">&lt;!-- and collections of general-purpose utility methods, Vue core --&gt;</span><br><span class="line">&lt;!-- is able to remain small by not reinventing them. This also   --&gt;</span><br><span class="line">&lt;!-- gives you the freedom to just use what you&apos;re familiar with. --&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/axios@0.12.0/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/lodash@4.13.1/lodash.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var watchExampleVM = new Vue(&#123;</span><br><span class="line">  el: &apos;#watch-example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    question: &apos;&apos;,</span><br><span class="line">    answer: &apos;I cannot give you an answer until you ask a question!&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    // whenever question changes, this function will run</span><br><span class="line">    question: function (newQuestion) &#123;</span><br><span class="line">      this.answer = &apos;Waiting for you to stop typing...&apos;</span><br><span class="line">      this.getAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // _.debounce is a function provided by lodash to limit how</span><br><span class="line">    // often a particularly expensive operation can be run.</span><br><span class="line">    // In this case, we want to limit how often we access</span><br><span class="line">    // yesno.wtf/api, waiting until the user has completely</span><br><span class="line">    // finished typing before making the ajax request. To learn</span><br><span class="line">    // more about the _.debounce function (and its cousin</span><br><span class="line">    // _.throttle), visit: https://lodash.com/docs#debounce</span><br><span class="line">    getAnswer: _.debounce(</span><br><span class="line">      function () &#123;</span><br><span class="line">        var vm = this</span><br><span class="line">        if (this.question.indexOf(&apos;?&apos;) === -1) &#123;</span><br><span class="line">          vm.answer = &apos;Questions usually contain a question mark. ;-)&apos;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        vm.answer = &apos;Thinking...&apos;</span><br><span class="line">        axios.get(&apos;https://yesno.wtf/api&apos;)</span><br><span class="line">          .then(function (response) &#123;</span><br><span class="line">            vm.answer = _.capitalize(response.data.answer)</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(function (error) &#123;</span><br><span class="line">            vm.answer = &apos;Error! Could not reach the API. &apos; + error</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      // This is the number of milliseconds we wait for the</span><br><span class="line">      // user to stop typing.</span><br><span class="line">      500</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这个场景中，使用<code>watch</code>选项允许我们执行异步操作，限制多久执行操作，以及只有获取到数据<br>才设置state。而这些在属性计算都是不可用的。除了这个选项你还可以使用必要的<a href="https://vuejs.org/v2/api/#vm-watch" target="_blank" rel="external">vm.$watch API</a></p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/29/vue/computed_properties/" data-id="ciw58i9yd003buko0g5uovjdc" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/template_syntax" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/29/vue/template_syntax/" class="article-date">
  <time datetime="2016-11-28T16:31:05.488Z" itemprop="datePublished">2016-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/29/vue/template_syntax/">Vue模板语法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><blockquote>
<p>Vue使用基于HTML的模板语法，允许你以声明式的方式绑定渲染的DOM到Vue实例的data。<br>所有的Vue模板是有效的html，它可以被特定兼容性的浏览器及html解析器解析。在引擎下，Vue编<br>译模板到虚拟DOM的render函数里，与反应系统相结合，聪明的计算出最小数量的组件重新渲染当<br>应用程序state发生变化时，最小数量的DOM操作。如果很熟悉虚拟DOM的概念，并更喜欢原生js的<br>特性，可以直接写render函数来代替模板。</p>
</blockquote>
<h3 id="文本插入"><a href="#文本插入" class="headerlink" title="文本插入"></a>文本插入</h3><h4 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h4><blockquote>
<p>最常用的文本绑定就是使用双括号语法这种格式，比如: <code>&lt;span&gt;Message: &lt;/span&gt;</code><br><code></code>将会替换为相应data对象的属性值，当data的msg属性值改变时，<code></code>也会改变。<br>通过使用<code>v-once</code>指令让data属性改变时相应的<code></code>不更新。但是记住，这回影响任何在该<br>节点绑定的数据。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-once&gt;This will never change: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<h4 id="原始html"><a href="#原始html" class="headerlink" title="原始html"></a>原始html</h4><blockquote>
<p>双花括号的语法以文本格式解释data，而不是HTML,如果要输出HTML，使用<code>v-html</code>指令.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div v-html=&quot;raw&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var vue = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">    raw: &apos;&lt;p style=&apos;color:red&apos;&gt;测试&lt;/p&gt;&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>Vue不是基于字符串模板引擎，组件是UI重用和组成首选的基本单位。注意：在网站动态的渲染任何<br>HTML是非常危险的，因为会引起XSS攻击，只有使用HTML插入在信赖的内容上并永远不会使用用户提<br>供的内容才是安全的。</p>
</blockquote>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><blockquote>
<p>双花括号语法不能使用在HTML的属性中，替换方案是使用<code>v-bind</code>命令:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于boolean类型的属性同样有效，当值为false时，移除此属性：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-bind:disabled=&quot;someDynamicCondition&quot;&gt;Button&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<h4 id="使用JS表达式"><a href="#使用JS表达式" class="headerlink" title="使用JS表达式"></a>使用JS表达式</h4><blockquote>
<p>Vue支持在数据绑定时使用js表达式，比如:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line">&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;</span><br><span class="line">&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class="line">&lt;div v-bind:id=&quot;&apos;list-&apos; + id&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样绑定的限制是，在双花括号语法中只能使用一个表达式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- this is a statement, not an expression: --&gt;</span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line">&lt;!-- flow control won&apos;t work either, use ternary expressions --&gt;</span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>模板表达式是沙箱式的，你可以访问类似<code>Math</code>和<code>Date</code>的全局变量，但是不能在模板表达式中<br>访问用户自定义的全局变量。</p>
</blockquote>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><blockquote>
<p>指令是以<code>v</code>为前缀的特殊的属性，指令属性值期望的是一个简单的js表达式，指令的作用就是当表<br>达式的值更改时，将响应作用应用到DOM上：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当<code>seen</code>表达式的值为false时，<code>v-if</code>指令将移除<code>p</code>元素，反之则插入<code>p</code>元素。</p>
</blockquote>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><blockquote>
<p>一些指令可以携带一个参数，它由指令<code>:</code>后的名字表示。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>href</code>是一个参数，它告诉<code>v-bind</code>指令绑定元素的<code>href</code>属性到<code>url</code>表达式的值，还有就是<br><code>v-on</code>指令，用来监听DOM事件:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间名称就是要监听的DOM时间.</p>
</blockquote>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><blockquote>
<p>修饰符是一个特殊的后缀又一个<code>.</code>表示，它表明一个指令由一种特殊的方式绑定，比如<code>.prevent</code><br>让<code>v-on</code>指令调用<code>e.preventDefault()</code>阻止事件的默认执行。</p>
</blockquote>
<h4 id="筛选器"><a href="#筛选器" class="headerlink" title="筛选器"></a>筛选器</h4><blockquote>
<p>Vue.js允许你定义筛选器，可以应用于常见的文本格式，筛选器常用在两个地方,双花括号以及<code>v-bind</code><br>表达式，筛选器添加在js表达式的后面，由管道<code>|</code>符号表示：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- in mustaches --&gt;</span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line">&lt;!-- in v-bind --&gt;</span><br><span class="line">&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：Vue2.x的筛选器只能用在双花括号以及<code>v-bind</code>表达式中，因为筛选器的主要设计用来文本<br>转换的目的，对于更复杂的指令，使用<a href="https://vuejs.org/v2/guide/computed.html" target="_blank" rel="external">计算的属性</a>来代替。<br>筛选器函数总是接收表达式的值作为第一个参数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  filters: &#123;</span><br><span class="line">    capitalize: function (value) &#123;</span><br><span class="line">      if (!value) return &apos;&apos;</span><br><span class="line">      value = value.toString()</span><br><span class="line">      return value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>筛选器可以使链式的：   </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>筛选器是js函数，所以他们可以接收参数：    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA(&apos;arg1&apos;, arg2) &#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里，<code>&#39;arg1&#39;</code>将作为第二个参数传递给filter函数,而<code>arg2</code>表达式会评估它的值并作为第三<br>个参数传递。</p>
</blockquote>
<h4 id="速记"><a href="#速记" class="headerlink" title="速记"></a>速记</h4><blockquote>
<p>频繁的使用<code>v-</code>前缀的指令很繁琐，所以Vue提供了两种常用指令的简写方式<code>v-bind</code>,<code>v-on</code>:</p>
</blockquote>
<h5 id="v-bind的速记方式"><a href="#v-bind的速记方式" class="headerlink" title="v-bind的速记方式"></a><code>v-bind</code>的速记方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- full syntax --&gt;</span><br><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- shorthand --&gt;</span><br><span class="line">&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<h5 id="v-on的速记方式"><a href="#v-on的速记方式" class="headerlink" title="v-on的速记方式"></a><code>v-on</code>的速记方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- full syntax --&gt;</span><br><span class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- shorthand --&gt;</span><br><span class="line">&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/29/vue/template_syntax/" data-id="ciw58i9z2003tuko0sqggcz6m" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/get_started" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/28/vue/get_started/" class="article-date">
  <time datetime="2016-11-28T12:44:58.565Z" itemprop="datePublished">2016-11-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/28/vue/get_started/">Vue纵览</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Vue实例的属性和方法"><a href="#Vue实例的属性和方法" class="headerlink" title="Vue实例的属性和方法"></a>Vue实例的属性和方法</h3><blockquote>
<p>Vue实例通过<code>var app = new Vue({})</code>来创建，构造参数接收一个对象，该对象包含的属性有<br><code>data</code>, <code>template</code>, <code>el</code>, <code>methods</code>, 生命周期回调函数等等，简单的实例:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      a: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      hello: function() &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Vue的生命周期钩子"><a href="#Vue的生命周期钩子" class="headerlink" title="Vue的生命周期钩子"></a>Vue的生命周期钩子</h3><blockquote>
<p>每一个Vue实例在创建的时候都需要经过几个初始化步骤。比如，它需要设置data的监听器，模板的<br>编译，将实例镶嵌到DOM上，以及当data修改时更新DOM。沿着这个途径，它会调用一些生命周期的<br>钩子,以便给我们一些执行自定义逻辑的机会。比如：<code>created</code>钩子当实例创建完成后会调用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      a: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    created: function() &#123;</span><br><span class="line">      console.log(this.msg);</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    updated: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这些生命钩子调用时，他们的上下文(this)指向当前vue实例。</p>
</blockquote>
<h3 id="生命周期图"><a href="#生命周期图" class="headerlink" title="生命周期图"></a>生命周期图</h3><p><img src="/images/lifecycle.png" alt="lifecycleImg"></p>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/28/vue/get_started/" data-id="ciw58i9zd0044uko0lwoq81mj" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-phabricator/what_is_docker" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/24/phabricator/what_is_docker/" class="article-date">
  <time datetime="2016-11-23T16:23:08.071Z" itemprop="datePublished">2016-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/development-tools/">development tools</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/24/phabricator/what_is_docker/">docker</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Docker-容器引擎"><a href="#Docker-容器引擎" class="headerlink" title="Docker(容器引擎)"></a>Docker(容器引擎)</h3><blockquote>
<p>docker是一个开源的可以运行任何app的轻量级的容器。docker容器既’hardware-agnostic(硬件不可知？)’又<br>‘platform-agnostic(平台不可知？)’.这意味着它可以运行在任何地方，在你的笔记本也行，在云平台亦可以。<br>并且不要求使用特定的语言，框架，包系统。这使得应用程序的部署，web app的规模调整，后端服务能更好的构建<br>而不依赖于特定的堆栈或提供者。<br>docker是一个开放源码的部署引擎,它是由<a href="http://web.archive.org/web/20130530031104/https://www.dotcloud.com/" target="_blank" rel="external">dotCloud</a>驱动的。</p>
</blockquote>
<h3 id="比VMs好"><a href="#比VMs好" class="headerlink" title="比VMs好"></a>比VMs好</h3><blockquote>
<p>分发应用程序及沙坑执行的常用方法是使用虚拟机。典型的VM格式有VMware的vmdk，Oracle的VirtualBox<br>亚马逊的ESC2,理论上这些格式允许每个开发者可以自动的打包应用程序到一个指定的机器以便于分发及部署。<br>实际上，几乎不会有这种情况，因为受到以下原因的制裁：</p>
<ul>
<li>Size: VMs很大，存储及移动他们不是很明智。</li>
<li>性能: 运行VMs消耗CPU和内存很大，所以在很多场景下使用它们很不明智，安装过虚拟机的我深有体会。</li>
<li>可移植性</li>
<li>以硬件为中心: VMs的设计是基于机器管理员的想法，而不是软件开发者 。因此，它提供了非常有限的<br>的工具给开发者，building, testing, running,比如，VMs提供应用程序的版本控制，监控，配置，<br>日志记录等等。<br>相比之下，Docker依赖于一种不同于集装箱化的沙盒方法，不像传统的虚拟化，集装箱化发生在内核<br>级别。Docker容器非常小，几乎0内存0cpu消耗，可完全移植，并且是以程序为中心设计而设计的。<br>也许最重要的是，Docker可以在操作系统中运行，也可以在虚拟机中运行。</li>
</ul>
</blockquote>
<h3 id="Play-Well-With-Others"><a href="#Play-Well-With-Others" class="headerlink" title="Play Well With Others"></a>Play Well With Others</h3><blockquote>
<p>Docker不需要你购买特定的语言，特定的框架，特定的打包系统，特定的配置语言。<br>你的程序是Unix进程么？使用文件了么？tcp链接？环境变量？标准Unix流以及命令行参数作为输入<br>输出，在Docker都可以。</p>
</blockquote>
<h3 id="Escape-dependecy-hell-逃脱地狱依赖"><a href="#Escape-dependecy-hell-逃脱地狱依赖" class="headerlink" title="Escape dependecy hell(逃脱地狱依赖)"></a>Escape dependecy hell(逃脱地狱依赖)</h3><blockquote>
<p>一个常见的问题就是开发人员很难以一个简单自动的方式管理一个程序的所有依赖，常见的原因有以下一些:</p>
<ul>
<li>跨平台依赖(cross-platform dependencies).现在的应用程序经常依赖系统库、二进制文件、特定语言包，<br>特定的框架模块、作为另外一个项目开发的内部组件等等的组合。这些依赖处在不同的”世界”并且需要不同的工具<br>而且相互之间不一定能正常的工作，所以需要尴尬的自定义集成。</li>
<li>依赖冲突.不同的应用程序有可能需要依赖一个库的不同版本。</li>
<li>自定义依赖.开发者可能需要准备应用程序依赖的一个自定义版本，一些打包工具可以处理依赖的自定义版本,<br>但是有些工具则不行，并且每种的处理方式又不同。<br>Docker让开发者在一个地方描述所有的程序依赖来轻松的解决了地狱依赖的这些常见的问题，同时精简了组装过程。<br>Docker通过运行Unix命令序列来定义一个build,在同一个容器里一个接一个的。构造命令修改了容器里的内容(经常<br>是安装新文件，新文件系统)，下一个命令修改了更多的内容等等。由于每一个命令都是基于上一个命令的结果，命令<br>执行的顺序标识依赖项。下面的是一个典型的Docker构造过程：</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:12.04</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y python python-pip curl</span><br><span class="line">RUN curl -sSL https://github.com/shykes/helloflask/archive/master.tar.gz | tar -xzv</span><br><span class="line">RUN cd helloflask-master &amp;&amp; pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Docker不关心依赖的构建关系，只要他们可以在容器中可以通过Unix命令构建。</p>
</blockquote>
<h3 id="ToDo（入门）"><a href="#ToDo（入门）" class="headerlink" title="ToDo（入门）"></a>ToDo（入门）</h3>
      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/24/phabricator/what_is_docker/" data-id="ciw58i9xx002wuko0x3rt3rtv" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          
            <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Canvas/">Canvas</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Electron/">Electron</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Http/">Http</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Redux/">React Redux</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Webpack/">Webpack</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/development-tools/">development tools</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget recents">
      <ul>
        
          <li>
            <a href="/2016/11/30/vue/components/">组件</a>
          </li>
        
          <li>
            <a href="/2016/11/30/vue/form_input/">form input绑定</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/event_handle/">事件处理</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/list_render/">Vue的列表渲染</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/conditional_render/">条件渲染</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">我的文章</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">23</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
</aside>
          
        
      </div>
      <!--<div id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a></br>
      &copy; 2016 zhuxin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</div>-->
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">我的文章</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>