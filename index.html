<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>zhuxin_blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="zhuxin_blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="zhuxin_blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zhuxin_blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="zhuxin_blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  
  <link href="//fonts.googleapis.com/css?family=Inconsolata:400,700|Open+Sans:700,400" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <div id="header-title">
        <h1 id="logo-wrap">
          <a href="/" id="logo">
          
              <span id="subtitle">每天进步一点点</span>
          
          </a>
        </h1>
      </div>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">我的文章</a>
        
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</div>
      <div class="outer">
        <section id="main">
  
    <article id="post-vue/event_handle" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/29/vue/event_handle/" class="article-date">
  <time datetime="2016-11-29T15:36:58.389Z" itemprop="datePublished">2016-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/29/vue/event_handle/">事件处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="事件的监听"><a href="#事件的监听" class="headerlink" title="事件的监听"></a>事件的监听</h3><blockquote>
<p>可以使用<code>v-on</code>指令来监听DOM事件并执行js函数，例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example-1&quot;&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt;</span><br><span class="line">  &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var example1 = new Vue(&#123;</span><br><span class="line">  el: &apos;#example-1&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="事件处理方法"><a href="#事件处理方法" class="headerlink" title="事件处理方法"></a>事件处理方法</h3><blockquote>
<p>如果时间处理函数的逻辑很复杂，那么在<code>v-on</code>属性上写js是不可行的，所以<code>v-on</code>指令接受一个<br>你要执行的方法名：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example-2&quot;&gt;</span><br><span class="line">  &lt;!-- `greet` is the name of a method defined below --&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var example2 = new Vue(&#123;</span><br><span class="line">  el: &apos;#example-2&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: &apos;Vue.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  // define methods under the `methods` object</span><br><span class="line">  methods: &#123;</span><br><span class="line">    greet: function (event) &#123;</span><br><span class="line">      // `this` inside methods points to the Vue instance</span><br><span class="line">      alert(&apos;Hello &apos; + this.name + &apos;!&apos;)</span><br><span class="line">      // `event` is the native DOM event</span><br><span class="line">      alert(event.target.tagName)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// you can invoke methods in JavaScript too</span><br><span class="line">example2.greet() // -&gt; &apos;Hello Vue.js!&apos;</span><br></pre></td></tr></table></figure>
<h3 id="行内处理方法"><a href="#行内处理方法" class="headerlink" title="行内处理方法"></a>行内处理方法</h3><blockquote>
<p>我们也可以使用行内的js语法而不是直接绑定函数名：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example-3&quot;&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;say(&apos;hi&apos;)&quot;&gt;Say hi&lt;/button&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;say(&apos;what&apos;)&quot;&gt;Say what&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#example-3&apos;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    say: function (message) &#123;</span><br><span class="line">      alert(message)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有时候我们需要在行内访问原始DOM的事件，你可以使用<code>$event</code>传递给函数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click=&quot;warn(&apos;Form cannot be submitted yet.&apos;, $event)&quot;&gt;Submit&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line">methods: &#123;</span><br><span class="line">  warn: function (message, event) &#123;</span><br><span class="line">    // now we have access to the native event</span><br><span class="line">    if (event) event.preventDefault()</span><br><span class="line">    alert(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><blockquote>
<p>在事件处理中调用<code>event.preventDefault</code>或者<code>event.stopPropagation()</code>是很常见的需要。<br>虽然我们可以在方法中处理，但是保持方法的纯净是很有必要的，我们只需要处理数据相关的逻辑<br>不用关心DOM的逻辑，为了解决这个问题，Vue为<code>v-on</code>提供了事件修饰符,它由一个后缀<code>.</code>表示：</p>
<ul>
<li>.stop</li>
<li>.prevent</li>
<li>.capture</li>
<li>.self</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- the click event&apos;s propagation will be stopped --&gt;</span><br><span class="line">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- the submit event will no longer reload the page --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class="line">&lt;!-- modifiers can be chained --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- just the modifier --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class="line">&lt;!-- use capture mode when adding the event listener --&gt;</span><br><span class="line">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class="line">&lt;!-- only trigger handler if event.target is the element itself --&gt;</span><br><span class="line">&lt;!-- i.e. not from a child element --&gt;</span><br><span class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Key修饰符"><a href="#Key修饰符" class="headerlink" title="Key修饰符"></a>Key修饰符</h3><blockquote>
<p>当监听键盘事件时，我们需要查看key code,Vue也为<code>v-on</code>提供了键盘事件的修饰符：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- only call vm.submit() when the keyCode is 13 --&gt;</span><br><span class="line">&lt;input v-on:keyup.13=&quot;submit&quot;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>技术所有的key code是很难的，为此Vue提供了常用key code的别名：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- same as above --&gt;</span><br><span class="line">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;</span><br><span class="line">&lt;!-- also works for shorthand --&gt;</span><br><span class="line">&lt;input @keyup.enter=&quot;submit&quot;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里是键盘事件的别名列表</p>
<ul>
<li>.enter</li>
<li>.tab</li>
<li>.delete</li>
<li>.esc</li>
<li>.space</li>
<li>.up</li>
<li>.down</li>
<li>.left</li>
<li>.right<br>你也可以通过全局<code>config.keyCodes</code>对象自定义键盘事件修饰符：</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// enable v-on:keyup.f1</span><br><span class="line">Vue.config.keyCodes.f1 = 112</span><br></pre></td></tr></table></figure>
<h3 id="鼠标事件修饰符"><a href="#鼠标事件修饰符" class="headerlink" title="鼠标事件修饰符"></a>鼠标事件修饰符</h3><blockquote>
<p>2.1.0新出来的，当相关的建按下时，你可以使用一下的别名修饰符监听鼠标事件：</p>
<ul>
<li>.ctrl</li>
<li>.alt</li>
<li>.shift</li>
<li>.meta</li>
</ul>
</blockquote>
<h3 id="Why-Listeners-in-HTML"><a href="#Why-Listeners-in-HTML" class="headerlink" title="Why Listeners in HTML?"></a>Why Listeners in HTML?</h3><blockquote>
<p>你可能关心整个事件监听方式违反了”关注点分离”原则，放心，由于所有的事件处理函数和表达式<br>严格的绑定在当前正在处理的视图上，不会引起维护困难，事实上使用<code>v-on</code>有以下优点：</p>
<ol>
<li>通过略读Html模板可以很容易在js找到事件处理函数</li>
<li>由于你不用手动在js中添加事件监听，ViewModel代码是纯粹的逻辑，易于测试。</li>
<li>当ViewModel销毁时，所有的事件监听都会自动的被移除，你不需要自己去清理</li>
</ol>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/29/vue/event_handle/" data-id="ciw3pesjo003epco04lh32yzs" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/list_render" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/29/vue/list_render/" class="article-date">
  <time datetime="2016-11-29T10:56:17.881Z" itemprop="datePublished">2016-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/29/vue/list_render/">Vue的列表渲染</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><blockquote>
<p>使用<code>v-for</code>指令渲染基于数组的列表，<code>v-for</code>的语法格式为<code>item in items</code>,<code>items</code>是data<br>里的属性，<code>item</code>是每个数组中每个元素的别名。</p>
</blockquote>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;example-1&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in items&quot;&gt;</span><br><span class="line">    &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">var example1 = new Vue(&#123;</span><br><span class="line">  el: &apos;#example-1&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [</span><br><span class="line">      &#123; message: &apos;Foo&apos; &#125;,</span><br><span class="line">      &#123; message: &apos;Bar&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>v-for</code>块里，有到父属性范围的访问权限，<code>v-for</code>也支持一个可选的第二个参数，用来表示当前<br>元素的索引:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;example-2&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;(item, index) in items&quot;&gt;</span><br><span class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">var example2 = new Vue(&#123;</span><br><span class="line">  el: &apos;#example-2&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    parentMessage: &apos;Parent&apos;,</span><br><span class="line">    items: [</span><br><span class="line">      &#123; message: &apos;Foo&apos; &#125;,</span><br><span class="line">      &#123; message: &apos;Bar&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以使用<code>of</code>代替<code>in</code>作为定界符，这更接近js中迭代器的语法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="模板v-for"><a href="#模板v-for" class="headerlink" title="模板v-for"></a>模板<code>v-for</code></h3><blockquote>
<p>和模板<code>v-if</code>相似，可以在<code>&lt;template&gt;</code>中使用<code>v-for</code>用来渲染多个元素的块，比如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;template v-for=&quot;item in items&quot;&gt;</span><br><span class="line">    &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<h3 id="对象v-for"><a href="#对象v-for" class="headerlink" title="对象v-for"></a>对象<code>v-for</code></h3><blockquote>
<p>也可以使用<code>v-for</code>来迭代一个对象的所有属性：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;repeat-object&quot; class=&quot;demo&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;value in object&quot;&gt;</span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#repeat-object&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    object: &#123;</span><br><span class="line">      FirstName: &apos;John&apos;,</span><br><span class="line">      LastName: &apos;Doe&apos;,</span><br><span class="line">      Age: 30</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以对这个<code>key</code>提供第二个参数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;(value, key) in object&quot;&gt;</span><br><span class="line">  &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以及相应的索引：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;(value, key, index) in object&quot;&gt;</span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="范围性的v-for"><a href="#范围性的v-for" class="headerlink" title="范围性的v-for"></a>范围性的<code>v-for</code></h3><blockquote>
<p><code>v-for</code>也接收一个整数，在这种场景中，它会重复渲染此模板多次：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="组件和v-for"><a href="#组件和v-for" class="headerlink" title="组件和v-for"></a>组件和<code>v-for</code></h3><blockquote>
<p>可以在自定义组件中使用<code>v-for</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-for=&quot;item in items&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然而这不会将任何数据自动的传递给组件，因为组件有独立的基于它自己的作用域，为了将一个可迭代<br>的数据传递个给组件，需要使用属性：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-for=&quot;(item, index) in items&quot;</span><br><span class="line">  v-bind:item=&quot;item&quot;</span><br><span class="line">  v-bind:index=&quot;index&quot;&gt;</span><br><span class="line">&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不自动注入<code>item</code>到组件的原因是这会使组件紧耦合于<code>v-for</code>是如何工作的。为了明确data的<br>来源并使组件在其他情况下也可复用，这里有个例子：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;todo-list-example&quot;&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    v-model=&quot;newTodoText&quot;</span><br><span class="line">    v-on:keyup.enter=&quot;addNewTodo&quot;</span><br><span class="line">    placeholder=&quot;Add a todo&quot;</span><br><span class="line">  &gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">      is=&quot;todo-item&quot;</span><br><span class="line">      v-for=&quot;(todo, index) in todos&quot;</span><br><span class="line">      v-bind:title=&quot;todo&quot;</span><br><span class="line">      v-on:remove=&quot;todos.splice(index, 1)&quot;</span><br><span class="line">    &gt;&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;todo-item&apos;, &#123;</span><br><span class="line">  template: &apos;\</span><br><span class="line">    &lt;li&gt;\</span><br><span class="line">      &#123;&#123; title &#125;&#125;\</span><br><span class="line">      &lt;button v-on:click=&quot;$emit(\&apos;remove\&apos;)&quot;&gt;X&lt;/button&gt;\</span><br><span class="line">    &lt;/li&gt;\</span><br><span class="line">  &apos;,</span><br><span class="line">  props: [&apos;title&apos;]</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#todo-list-example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    newTodoText: &apos;&apos;,</span><br><span class="line">    todos: [</span><br><span class="line">      &apos;Do the dishes&apos;,</span><br><span class="line">      &apos;Take out the trash&apos;,</span><br><span class="line">      &apos;Mow the lawn&apos;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addNewTodo: function () &#123;</span><br><span class="line">      this.todos.push(this.newTodoText)</span><br><span class="line">      this.newTodoText = &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><blockquote>
<p>当Vue更新一个由<code>v-for</code>渲染的列表时，默认情况下使用的是”原地修补”的策略，如果数据列表的<br>顺序改变了，移动DOM元素来匹配最新的顺序，Vue会原地简单的修正每一个元素确保特定索引初应该<br>渲染什么。这种默认方式是有效率的，但是只适用于你的列表渲染不依赖于子组件或临时DOM状态（例<br>如，input输入值）。你需要给每一个节点提供一个唯一的<code>key</code>属性，给Vue一个线索以便可以追踪<br>每个节点的身份，从而复用且重排序存在的节点.你需要使用<code>v-bind</code>来绑定动态的值，在这里使用<br>的是简写形式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">  &lt;!-- content --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不管是否需要建议给<code>v-for</code>提供一个<code>key</code>,除非迭代的DOM内容很简单，或者你故意依赖默认行为来<br>提高性能增益。由于它是Vue标识节点的通用机制，<code>key</code>还有其它用途不仅仅是很<code>v-for</code>相关联。</p>
</blockquote>
<h3 id="数组改变的探测"><a href="#数组改变的探测" class="headerlink" title="数组改变的探测"></a>数组改变的探测</h3><h4 id="突变方法"><a href="#突变方法" class="headerlink" title="突变方法"></a>突变方法</h4><blockquote>
<p>Vue包装了观察数组突变的方法，所以它们也会触发视图的更新，包装的方法有：</p>
<ul>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()<br>可以在浏览器的控制台中调用这些突变方法，比如： <code>example1.items.push({ message: &#39;Baz&#39; })</code></li>
</ul>
</blockquote>
<h4 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h4><blockquote>
<p>突变方法，顾名思义就是调用这些方法之后改变的是原始数组。和不是突变的方法相比较，比如：<br><code>filter()</code>, <code>concat()</code>,他们不改变原始数组而是返回一个新数组，当使用非突变方法时，你需<br>要用新数组替换原始数组：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example1.items = example1.items.filter(function (item) &#123;</span><br><span class="line">  return item.message.match(/Foo/)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Vue实现了一些智能的启发式技术来最大化的复用DOM元素，所以替换一个数组是一个非常有效的操作。</p>
</blockquote>
<h4 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h4><blockquote>
<p>由于js的限制，Vue不能发现以下数组的改变：</p>
<ol>
<li>直接通过索引给数组赋值，比如：<code>vm.items[indexOfItem] = newValue</code></li>
<li>改变数组的长度。 比如： <code>vm.items.length = newLength</code><br>为了克服警告1，下面的两种方式完成的效果和<code>vm.items[indexOfItem] = newValue</code>是一样的,<br>但是会触发反应系统：</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Vue.set</span><br><span class="line">Vue.set(example1.items, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line">// Array.prototype.splice`</span><br><span class="line">example1.items.splice(indexOfItem, 1, newValue)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>处理警告2的方式，也使用<code>splice</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example1.items.splice(newLength)</span><br></pre></td></tr></table></figure>
<h3 id="排序或筛选结果的显示"><a href="#排序或筛选结果的显示" class="headerlink" title="排序或筛选结果的显示"></a>排序或筛选结果的显示</h3><blockquote>
<p>有时候我们需要显示数字的筛选或排序结果没有必要去重置原始数组，在这种情况下，使用属性的计算<br>来返回筛选的或者排序好的数组：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;n in evenNumbers&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  numbers: [ 1, 2, 3, 4, 5 ]</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  evenNumbers: function () &#123;</span><br><span class="line">    return this.numbers.filter(function (number) &#123;</span><br><span class="line">      return number % 2 === 0</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;n in even(numbers)&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  numbers: [ 1, 2, 3, 4, 5 ]</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  even: function (numbers) &#123;</span><br><span class="line">    return numbers.filter(function (number) &#123;</span><br><span class="line">      return number % 2 === 0</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/29/vue/list_render/" data-id="ciw3pesju003ipco04vzqccg6" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/conditional_render" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/29/vue/conditional_render/" class="article-date">
  <time datetime="2016-11-29T10:14:00.554Z" itemprop="datePublished">2016-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/29/vue/conditional_render/">条件渲染</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><blockquote>
<p>在字符串模板中，我们需要按照下面的方式写一个条件块：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Handlebars template --&gt;</span><br><span class="line">&#123;&#123;#if ok&#125;&#125;</span><br><span class="line">  &lt;h1&gt;Yes&lt;/h1&gt;</span><br><span class="line">&#123;&#123;/if&#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Vue中，我们使用<code>v-if</code>指令来得到相同的效果：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然可以使用<code>v-else</code>指令来添加”else”块：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;No&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<h3 id="在中添加v-if条件组"><a href="#在中添加v-if条件组" class="headerlink" title="在中添加v-if条件组"></a>在<template>中添加<code>v-if</code>条件组</template></h3><blockquote>
<p>因为<code>v-if</code>是一个指令，它需要附属在一个元素上，但是当我们需要切换不止一个元素时怎么办呢？<br>在这种情况下，我们需要使用在<code>&lt;template&gt;</code>中使用<code>v-if</code>，作为一个看不见的包装，最终的渲染<br>结果是不包含<code>&lt;template&gt;</code>元素：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;ok&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Title&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 1&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 2&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h4 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h4><blockquote>
<p>可以使用<code>v-else</code>指令来指出一个<code>v-if</code>的”else 块”：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;</span><br><span class="line">  Now you see me</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Now you don&apos;t</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>v-else</code>指令必须跟在<code>v-if</code>或<code>v-else-if</code>元素后面，否则它不会起作用。</p>
</blockquote>
<h4 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h4><blockquote>
<p>在2.1.0中新添加的特性，可以多次链式的使用：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;</span><br><span class="line">  A</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;</span><br><span class="line">  B</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt;</span><br><span class="line">  C</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Not A/B/C</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样必须跟在<code>v-if</code>或<code>v-else-if</code>元素后面。</p>
</blockquote>
<h3 id="通过key控制元素的复用"><a href="#通过key控制元素的复用" class="headerlink" title="通过key控制元素的复用"></a>通过<code>key</code>控制元素的复用</h3><blockquote>
<p>Vue尝试尽可能高效的渲染元素，经常重新使用它们而不是重新从零开始渲染他们，为了使Vue更快<br>这儿有一些有用的优点，比如，允许用户切换等了类型：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your username&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your email address&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后切换<code>loginType</code>,将不会擦除用户已经输入的内容，因为两个模板都使用了同一个<code>&lt;input&gt;</code><br>改变的仅仅是<code>placeholder</code>.这样不是很好，Vue提供了一种方式来完善这个缺点，只需要添加<br>一个唯一的<code>key</code>属性：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<code>&lt;label&gt;</code>还是会重用的，因为它们有<code>key</code>属性。</p>
</blockquote>
<h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><blockquote>
<p><code>v-show</code>是一个有条件显示一个元素的指令，它的用法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>区别是一个带有<code>v-show</code>的元素会在DOM中渲染并保留在DOM中，<code>v-show</code>仅仅是改变元素的<code>display</code><br>属性，<strong>注意:</strong>,<code>v-show</code>不支持<code>&lt;template&gt;</code>，与不与<code>v-else</code>一起工作。</p>
</blockquote>
<h4 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if vs v-show</h4><blockquote>
<p><code>v-if</code>条件为真时才渲染因为他要保证在切换过程中事件监听以及子组件正确的销毁并重建。<br><code>v-if</code>是”懒惰的”,如果在初始渲染时，条件为false，它不会干任何事，只有当条件为true时，<br>才会渲染。<br><code>v-show</code>的元素会不管初始条件渲染，它仅仅是基本的CSS切换。<br>通常来讲，<code>v-if</code>切换时有较高的消耗，而<code>v-show</code>在初始化的时候有较高的消耗，如果你需要经常<br>切换选择<code>v-show</code>,如果在运行时不太可能改变则选择<code>v-if</code></p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/29/vue/conditional_render/" data-id="ciw3pesja003apco0t2vibdu8" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/style_class_binding" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/29/vue/style_class_binding/" class="article-date">
  <time datetime="2016-11-29T08:47:31.342Z" itemprop="datePublished">2016-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/29/vue/style_class_binding/">样式绑定</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Class和Style的绑定"><a href="#Class和Style的绑定" class="headerlink" title="Class和Style的绑定"></a>Class和Style的绑定</h3><blockquote>
<p>对数据绑定的共同需求是操纵元素的列表样式及行内样式，由于他们都是属性，可以通过<code>v-bind</code><br>来处理他们。当<code>v-bind</code>绑定的是<code>class</code>以及<code>style</code>时，除了字符串，表达式也可以被评估为<br>对象或者数组。</p>
</blockquote>
<h3 id="绑定HTML的类"><a href="#绑定HTML的类" class="headerlink" title="绑定HTML的类"></a>绑定HTML的类</h3><h4 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h4><blockquote>
<p>我们可以传递一个对象给<code>v-bind:class</code>来动态的切换class：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的语法意味着class的存在由<code>isActive</code>是否为真决定。可以通过对象中的多个字段来切换多个<br>类，另外<code>v-bind:class</code>指令可以与<code>class</code>属性共同存在，下面的例子：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;static&quot;</span><br><span class="line">     v-bind:class=&quot;&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以及相应的数据对象：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它的渲染结果是：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当<code>isActive</code>和<code>hasError</code>改变时，类列表页会相应的变化，比如，当<code>hasError</code>为<code>true</code>时，<br>相应的类列表会变为<code>&quot;static active text-danger&quot;</code>.<br>绑定的对象不一定非得内联：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: true,</span><br><span class="line">    &apos;text-danger&apos;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>渲染结果是相同的，我们也可以绑定一个返回对象的计算属性，例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  error: null</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      active: this.isActive &amp;&amp; !this.error,</span><br><span class="line">      &apos;text-danger&apos;: this.error &amp;&amp; this.error.type === &apos;fatal&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h4><blockquote>
<p>我们可以传递一个数组给<code>v-bind:class</code>应用于类列表：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: &apos;active&apos;,</span><br><span class="line">  errorClass: &apos;text-danger&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它的渲染结果是:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你想在列表中有条件的切换类，你可以使用三元运算符：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>errorClass</code>会一直应用，但是只有当<code>isActive</code>为真时<code>activeClass</code>才会被应用。但是当你<br>有多个条件切换的类在列表中会有点罗嗦，可以在列表语法中使用对象语法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="With-Components"><a href="#With-Components" class="headerlink" title="With Components"></a>With Components</h3><blockquote>
<p>当你在自定义组建中使用<code>class</code>属性时，类将会被添加到组件的根节点上，该元素已存在的类不会<br>被覆盖，比如，你这么声明一个组件：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在使用它时又添加了一些类：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最终的渲染结果是：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于类绑定也是同样的效果：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当<code>isActive</code>为true时，渲染结果为：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;foo bar active&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h3 id="行内样式的绑定"><a href="#行内样式的绑定" class="headerlink" title="行内样式的绑定"></a>行内样式的绑定</h3><h4 id="类语法"><a href="#类语法" class="headerlink" title="类语法"></a>类语法</h4><blockquote>
<p><code>v-bind:style</code>的对象语法简单易懂，看起来很像CSS，你可以使用驼峰式或者”-“形式的属性命名:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: &apos;red&apos;,</span><br><span class="line">  fontSize: 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>直接绑定一个样式对象让模板看起来很干净是一个好主意：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: &apos;red&apos;,</span><br><span class="line">    fontSize: &apos;13px&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对象语法经常结合返回对象的计算属性来使用。</p>
</blockquote>
<h4 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h4><blockquote>
<p><code>v-bind:style</code>的数组语法允许你对一个元素应用多个样式对象：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Auto-prefixing-自动添加前缀"><a href="#Auto-prefixing-自动添加前缀" class="headerlink" title="Auto-prefixing(自动添加前缀)"></a>Auto-prefixing(自动添加前缀)</h4><blockquote>
<p>当你在<code>v-bind:style</code>中使用一个需要添加供应商前缀的属性时，Vue会自动的检测出并且添加一个<br>合适的前缀来应用该样式，比如<code>transform</code></p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/29/vue/style_class_binding/" data-id="ciw3peskb003lpco0ahl70gj7" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/computed_properties" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/29/vue/computed_properties/" class="article-date">
  <time datetime="2016-11-29T06:24:55.080Z" itemprop="datePublished">2016-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/29/vue/computed_properties/">Vue属性的计算及监听器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Vue属性计算及监听器"><a href="#Vue属性计算及监听器" class="headerlink" title="Vue属性计算及监听器"></a>Vue属性计算及监听器</h3><h3 id="属性计算"><a href="#属性计算" class="headerlink" title="属性计算"></a>属性计算</h3><blockquote>
<p>模板内使用表达式是很方便的，但只是对于简单的操作。如果在模板中放入大量的逻辑，只会让模板<br>变得庞大且难以管理：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你需要看一会才知道这个模板显示的是倒序的字符串，如果你要在模板中多次使用的话，这会变得很<br>糟糕。对于复杂逻辑，应该使用属性的计算。</p>
</blockquote>
<h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // a computed getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` points to the vm instance</span><br><span class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里我们已经宣布了一个计算的属性<code>reversedMessage</code>,我们提供的这个函数和属性的getter函数<br>类似<code>rm.reversedMessage</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(vm.reversedMessage) // -&gt; &apos;olleH&apos;</span><br><span class="line">vm.message = &apos;Goodbye&apos;</span><br><span class="line">console.log(vm.reversedMessage) // -&gt; &apos;eybdooG&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>vm.reversedMessage</code>的值依赖于<code>vm.message</code>的值。你可以将计算的属性像普通属性一样绑定到<br>模板上，Vue会意识到<code>vm.reversedMessage</code>依赖<code>vm.message</code>,所以当<code>vm.message</code>改变的时候<br>修改对应绑定的<code>vm.reversedMessage</code>的值，当然最好的部分是我们已经以声明的方式创建了依赖<br>关系:计算的getter函数是纯函数并且没有副作用，这样可以很轻松的测试。</p>
</blockquote>
<h3 id="计算的缓存VS方法"><a href="#计算的缓存VS方法" class="headerlink" title="计算的缓存VS方法"></a>计算的缓存VS方法</h3><blockquote>
<p>你可能已经注意到我们可以通过在表达式中调用方法得到相同的结果：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Reversed message: &quot;&#123;&#123; reverseMessage() &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// in component</span><br><span class="line">methods: &#123;</span><br><span class="line">  reverseMessage: function () &#123;</span><br><span class="line">    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以定义一个方法来代替属性的计算。对于最终结果，这两种方式确实完全相同。但是，不同之<br>处是，计算的属性会缓存基于它的依赖，一个计算的属性只有当它的依赖项发生改变时才会重新计算<br>这意味着只要<code>message</code>没有改变，多次访问计算的属性<code>reversedMessage</code>会返回上次计算的结果<br>而不是重新运行该函数。下面的计算的属性永远不会发生变化，因为<code>Date.now()</code>不是一个反应式<br>的依赖项：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  now: function () &#123;</span><br><span class="line">    return Date.now()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>作为比较，不管是否重新渲染，一个方法的调用都需要重新运行该方法。我们为什么需要缓存呢？<br>想象一个非常耗时的计算属性A，它需要在一个很大的数组中循环并且进行大量的计算，然后可能有<br>其余的计算属性依赖于A的计算属性，如果没有还从的话，我们将毫无必要的执行多次A的计算，当在<br>不需要使用缓存的情况下，使用方法代替。</p>
</blockquote>
<h3 id="计算的属性VS监听的属性"><a href="#计算的属性VS监听的属性" class="headerlink" title="计算的属性VS监听的属性"></a>计算的属性VS监听的属性</h3><blockquote>
<p>Vue确实提供了一种通用的方法来观察Vue实例中data的变化做出反应：<code>watch properties</code>.当你<br>的一些数据需要基于其它一些数据做出改变时，可以尝试使用<code>watch</code>属性。但是使用属性的计算相对<br>来说更好一点，考虑下面的例子：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Foo&apos;,</span><br><span class="line">    lastName: &apos;Bar&apos;,</span><br><span class="line">    fullName: &apos;Foo Bar&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: function (val) &#123;</span><br><span class="line">      this.fullName = val + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: function (val) &#123;</span><br><span class="line">      this.fullName = this.firstName + &apos; &apos; + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的代码有重复，和属性的计算相比较：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Foo&apos;,</span><br><span class="line">    lastName: &apos;Bar&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: function () &#123;</span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样更好一点。</p>
</blockquote>
<h3 id="计算属性的Setter"><a href="#计算属性的Setter" class="headerlink" title="计算属性的Setter"></a>计算属性的Setter</h3><blockquote>
<p>默认情况下计算的属性时只读的，但是当你需要时你可以提供一个setter函数：    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    // getter</span><br><span class="line">    get: function () &#123;</span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    // setter</span><br><span class="line">    set: function (newValue) &#123;</span><br><span class="line">      var names = newValue.split(&apos; &apos;)</span><br><span class="line">      this.firstName = names[0]</span><br><span class="line">      this.lastName = names[names.length - 1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在当你执行<code>vm.fullName = &#39;John Doe&#39;</code>,setter函数将会被执行，相应的<code>vm.firstName</code>和<br><code>vm.lastName</code>也会改变。</p>
</blockquote>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><blockquote>
<p>虽然在多数情况下，属性的计算是很合适的，但是有时候自定义监听器也是有必要的。这也是为什么<br>Vue提供了一个同用的方式，通过<code>watch</code>选项来对数据的变化做出反应。当你要响应不断变化的数据<br>执行异步操作或者昂贵操作的时候很有用。例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;watch-example&quot;&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    &lt;input v-model=&quot;question&quot;&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Since there is already a rich ecosystem of ajax libraries    --&gt;</span><br><span class="line">&lt;!-- and collections of general-purpose utility methods, Vue core --&gt;</span><br><span class="line">&lt;!-- is able to remain small by not reinventing them. This also   --&gt;</span><br><span class="line">&lt;!-- gives you the freedom to just use what you&apos;re familiar with. --&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/axios@0.12.0/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/lodash@4.13.1/lodash.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var watchExampleVM = new Vue(&#123;</span><br><span class="line">  el: &apos;#watch-example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    question: &apos;&apos;,</span><br><span class="line">    answer: &apos;I cannot give you an answer until you ask a question!&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    // whenever question changes, this function will run</span><br><span class="line">    question: function (newQuestion) &#123;</span><br><span class="line">      this.answer = &apos;Waiting for you to stop typing...&apos;</span><br><span class="line">      this.getAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // _.debounce is a function provided by lodash to limit how</span><br><span class="line">    // often a particularly expensive operation can be run.</span><br><span class="line">    // In this case, we want to limit how often we access</span><br><span class="line">    // yesno.wtf/api, waiting until the user has completely</span><br><span class="line">    // finished typing before making the ajax request. To learn</span><br><span class="line">    // more about the _.debounce function (and its cousin</span><br><span class="line">    // _.throttle), visit: https://lodash.com/docs#debounce</span><br><span class="line">    getAnswer: _.debounce(</span><br><span class="line">      function () &#123;</span><br><span class="line">        var vm = this</span><br><span class="line">        if (this.question.indexOf(&apos;?&apos;) === -1) &#123;</span><br><span class="line">          vm.answer = &apos;Questions usually contain a question mark. ;-)&apos;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        vm.answer = &apos;Thinking...&apos;</span><br><span class="line">        axios.get(&apos;https://yesno.wtf/api&apos;)</span><br><span class="line">          .then(function (response) &#123;</span><br><span class="line">            vm.answer = _.capitalize(response.data.answer)</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(function (error) &#123;</span><br><span class="line">            vm.answer = &apos;Error! Could not reach the API. &apos; + error</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      // This is the number of milliseconds we wait for the</span><br><span class="line">      // user to stop typing.</span><br><span class="line">      500</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这个场景中，使用<code>watch</code>选项允许我们执行异步操作，限制多久执行操作，以及只有获取到数据<br>才设置state。而这些在属性计算都是不可用的。除了这个选项你还可以使用必要的<a href="https://vuejs.org/v2/api/#vm-watch" target="_blank" rel="external">vm.$watch API</a></p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/29/vue/computed_properties/" data-id="ciw3pesje003cpco0v17mrc3q" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/template_syntax" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/29/vue/template_syntax/" class="article-date">
  <time datetime="2016-11-28T16:31:05.488Z" itemprop="datePublished">2016-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/29/vue/template_syntax/">Vue模板语法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><blockquote>
<p>Vue使用基于HTML的模板语法，允许你以声明式的方式绑定渲染的DOM到Vue实例的data。<br>所有的Vue模板是有效的html，它可以被特定兼容性的浏览器及html解析器解析。在引擎下，Vue编<br>译模板到虚拟DOM的render函数里，与反应系统相结合，聪明的计算出最小数量的组件重新渲染当<br>应用程序state发生变化时，最小数量的DOM操作。如果很熟悉虚拟DOM的概念，并更喜欢原生js的<br>特性，可以直接写render函数来代替模板。</p>
</blockquote>
<h3 id="文本插入"><a href="#文本插入" class="headerlink" title="文本插入"></a>文本插入</h3><h4 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h4><blockquote>
<p>最常用的文本绑定就是使用双括号语法这种格式，比如: <code>&lt;span&gt;Message: &lt;/span&gt;</code><br><code></code>将会替换为相应data对象的属性值，当data的msg属性值改变时，<code></code>也会改变。<br>通过使用<code>v-once</code>指令让data属性改变时相应的<code></code>不更新。但是记住，这回影响任何在该<br>节点绑定的数据。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-once&gt;This will never change: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<h4 id="原始html"><a href="#原始html" class="headerlink" title="原始html"></a>原始html</h4><blockquote>
<p>双花括号的语法以文本格式解释data，而不是HTML,如果要输出HTML，使用<code>v-html</code>指令.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div v-html=&quot;raw&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var vue = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">    raw: &apos;&lt;p style=&apos;color:red&apos;&gt;测试&lt;/p&gt;&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>Vue不是基于字符串模板引擎，组件是UI重用和组成首选的基本单位。注意：在网站动态的渲染任何<br>HTML是非常危险的，因为会引起XSS攻击，只有使用HTML插入在信赖的内容上并永远不会使用用户提<br>供的内容才是安全的。</p>
</blockquote>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><blockquote>
<p>双花括号语法不能使用在HTML的属性中，替换方案是使用<code>v-bind</code>命令:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于boolean类型的属性同样有效，当值为false时，移除此属性：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-bind:disabled=&quot;someDynamicCondition&quot;&gt;Button&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<h4 id="使用JS表达式"><a href="#使用JS表达式" class="headerlink" title="使用JS表达式"></a>使用JS表达式</h4><blockquote>
<p>Vue支持在数据绑定时使用js表达式，比如:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line">&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;</span><br><span class="line">&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class="line">&lt;div v-bind:id=&quot;&apos;list-&apos; + id&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样绑定的限制是，在双花括号语法中只能使用一个表达式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- this is a statement, not an expression: --&gt;</span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line">&lt;!-- flow control won&apos;t work either, use ternary expressions --&gt;</span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>模板表达式是沙箱式的，你可以访问类似<code>Math</code>和<code>Date</code>的全局变量，但是不能在模板表达式中<br>访问用户自定义的全局变量。</p>
</blockquote>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><blockquote>
<p>指令是以<code>v</code>为前缀的特殊的属性，指令属性值期望的是一个简单的js表达式，指令的作用就是当表<br>达式的值更改时，将响应作用应用到DOM上：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当<code>seen</code>表达式的值为false时，<code>v-if</code>指令将移除<code>p</code>元素，反之则插入<code>p</code>元素。</p>
</blockquote>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><blockquote>
<p>一些指令可以携带一个参数，它由指令<code>:</code>后的名字表示。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>href</code>是一个参数，它告诉<code>v-bind</code>指令绑定元素的<code>href</code>属性到<code>url</code>表达式的值，还有就是<br><code>v-on</code>指令，用来监听DOM事件:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间名称就是要监听的DOM时间.</p>
</blockquote>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><blockquote>
<p>修饰符是一个特殊的后缀又一个<code>.</code>表示，它表明一个指令由一种特殊的方式绑定，比如<code>.prevent</code><br>让<code>v-on</code>指令调用<code>e.preventDefault()</code>阻止事件的默认执行。</p>
</blockquote>
<h4 id="筛选器"><a href="#筛选器" class="headerlink" title="筛选器"></a>筛选器</h4><blockquote>
<p>Vue.js允许你定义筛选器，可以应用于常见的文本格式，筛选器常用在两个地方,双花括号以及<code>v-bind</code><br>表达式，筛选器添加在js表达式的后面，由管道<code>|</code>符号表示：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- in mustaches --&gt;</span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line">&lt;!-- in v-bind --&gt;</span><br><span class="line">&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：Vue2.x的筛选器只能用在双花括号以及<code>v-bind</code>表达式中，因为筛选器的主要设计用来文本<br>转换的目的，对于更复杂的指令，使用<a href="https://vuejs.org/v2/guide/computed.html" target="_blank" rel="external">计算的属性</a>来代替。<br>筛选器函数总是接收表达式的值作为第一个参数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  filters: &#123;</span><br><span class="line">    capitalize: function (value) &#123;</span><br><span class="line">      if (!value) return &apos;&apos;</span><br><span class="line">      value = value.toString()</span><br><span class="line">      return value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>筛选器可以使链式的：   </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>筛选器是js函数，所以他们可以接收参数：    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA(&apos;arg1&apos;, arg2) &#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里，<code>&#39;arg1&#39;</code>将作为第二个参数传递给filter函数,而<code>arg2</code>表达式会评估它的值并作为第三<br>个参数传递。</p>
</blockquote>
<h4 id="速记"><a href="#速记" class="headerlink" title="速记"></a>速记</h4><blockquote>
<p>频繁的使用<code>v-</code>前缀的指令很繁琐，所以Vue提供了两种常用指令的简写方式<code>v-bind</code>,<code>v-on</code>:</p>
</blockquote>
<h5 id="v-bind的速记方式"><a href="#v-bind的速记方式" class="headerlink" title="v-bind的速记方式"></a><code>v-bind</code>的速记方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- full syntax --&gt;</span><br><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- shorthand --&gt;</span><br><span class="line">&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<h5 id="v-on的速记方式"><a href="#v-on的速记方式" class="headerlink" title="v-on的速记方式"></a><code>v-on</code>的速记方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- full syntax --&gt;</span><br><span class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- shorthand --&gt;</span><br><span class="line">&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/29/vue/template_syntax/" data-id="ciw3pesko003opco0he6yl94t" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/get_started" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/28/vue/get_started/" class="article-date">
  <time datetime="2016-11-28T12:44:58.565Z" itemprop="datePublished">2016-11-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/28/vue/get_started/">Vue纵览</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Vue实例的属性和方法"><a href="#Vue实例的属性和方法" class="headerlink" title="Vue实例的属性和方法"></a>Vue实例的属性和方法</h3><blockquote>
<p>Vue实例通过<code>var app = new Vue({})</code>来创建，构造参数接收一个对象，该对象包含的属性有<br><code>data</code>, <code>template</code>, <code>el</code>, <code>methods</code>, 生命周期回调函数等等，简单的实例:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      a: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      hello: function() &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Vue的生命周期钩子"><a href="#Vue的生命周期钩子" class="headerlink" title="Vue的生命周期钩子"></a>Vue的生命周期钩子</h3><blockquote>
<p>每一个Vue实例在创建的时候都需要经过几个初始化步骤。比如，它需要设置data的监听器，模板的<br>编译，将实例镶嵌到DOM上，以及当data修改时更新DOM。沿着这个途径，它会调用一些生命周期的<br>钩子,以便给我们一些执行自定义逻辑的机会。比如：<code>created</code>钩子当实例创建完成后会调用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      a: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    created: function() &#123;</span><br><span class="line">      console.log(this.msg);</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    updated: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这些生命钩子调用时，他们的上下文(this)指向当前vue实例。</p>
</blockquote>
<h3 id="生命周期图"><a href="#生命周期图" class="headerlink" title="生命周期图"></a>生命周期图</h3><p><img src="/images/lifecycle.png" alt="lifecycleImg"></p>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/28/vue/get_started/" data-id="ciw3pesjr003gpco0vemjcexg" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-phabricator/what_is_docker" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/24/phabricator/what_is_docker/" class="article-date">
  <time datetime="2016-11-23T16:23:08.071Z" itemprop="datePublished">2016-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/development-tools/">development tools</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/24/phabricator/what_is_docker/">docker</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Docker-容器引擎"><a href="#Docker-容器引擎" class="headerlink" title="Docker(容器引擎)"></a>Docker(容器引擎)</h3><blockquote>
<p>docker是一个开源的可以运行任何app的轻量级的容器。docker容器既’hardware-agnostic(硬件不可知？)’又<br>‘platform-agnostic(平台不可知？)’.这意味着它可以运行在任何地方，在你的笔记本也行，在云平台亦可以。<br>并且不要求使用特定的语言，框架，包系统。这使得应用程序的部署，web app的规模调整，后端服务能更好的构建<br>而不依赖于特定的堆栈或提供者。<br>docker是一个开放源码的部署引擎,它是由<a href="http://web.archive.org/web/20130530031104/https://www.dotcloud.com/" target="_blank" rel="external">dotCloud</a>驱动的。</p>
</blockquote>
<h3 id="比VMs好"><a href="#比VMs好" class="headerlink" title="比VMs好"></a>比VMs好</h3><blockquote>
<p>分发应用程序及沙坑执行的常用方法是使用虚拟机。典型的VM格式有VMware的vmdk，Oracle的VirtualBox<br>亚马逊的ESC2,理论上这些格式允许每个开发者可以自动的打包应用程序到一个指定的机器以便于分发及部署。<br>实际上，几乎不会有这种情况，因为受到以下原因的制裁：</p>
<ul>
<li>Size: VMs很大，存储及移动他们不是很明智。</li>
<li>性能: 运行VMs消耗CPU和内存很大，所以在很多场景下使用它们很不明智，安装过虚拟机的我深有体会。</li>
<li>可移植性</li>
<li>以硬件为中心: VMs的设计是基于机器管理员的想法，而不是软件开发者 。因此，它提供了非常有限的<br>的工具给开发者，building, testing, running,比如，VMs提供应用程序的版本控制，监控，配置，<br>日志记录等等。<br>相比之下，Docker依赖于一种不同于集装箱化的沙盒方法，不像传统的虚拟化，集装箱化发生在内核<br>级别。Docker容器非常小，几乎0内存0cpu消耗，可完全移植，并且是以程序为中心设计而设计的。<br>也许最重要的是，Docker可以在操作系统中运行，也可以在虚拟机中运行。</li>
</ul>
</blockquote>
<h3 id="Play-Well-With-Others"><a href="#Play-Well-With-Others" class="headerlink" title="Play Well With Others"></a>Play Well With Others</h3><blockquote>
<p>Docker不需要你购买特定的语言，特定的框架，特定的打包系统，特定的配置语言。<br>你的程序是Unix进程么？使用文件了么？tcp链接？环境变量？标准Unix流以及命令行参数作为输入<br>输出，在Docker都可以。</p>
</blockquote>
<h3 id="Escape-dependecy-hell-逃脱地狱依赖"><a href="#Escape-dependecy-hell-逃脱地狱依赖" class="headerlink" title="Escape dependecy hell(逃脱地狱依赖)"></a>Escape dependecy hell(逃脱地狱依赖)</h3><blockquote>
<p>一个常见的问题就是开发人员很难以一个简单自动的方式管理一个程序的所有依赖，常见的原因有以下一些:</p>
<ul>
<li>跨平台依赖(cross-platform dependencies).现在的应用程序经常依赖系统库、二进制文件、特定语言包，<br>特定的框架模块、作为另外一个项目开发的内部组件等等的组合。这些依赖处在不同的”世界”并且需要不同的工具<br>而且相互之间不一定能正常的工作，所以需要尴尬的自定义集成。</li>
<li>依赖冲突.不同的应用程序有可能需要依赖一个库的不同版本。</li>
<li>自定义依赖.开发者可能需要准备应用程序依赖的一个自定义版本，一些打包工具可以处理依赖的自定义版本,<br>但是有些工具则不行，并且每种的处理方式又不同。<br>Docker让开发者在一个地方描述所有的程序依赖来轻松的解决了地狱依赖的这些常见的问题，同时精简了组装过程。<br>Docker通过运行Unix命令序列来定义一个build,在同一个容器里一个接一个的。构造命令修改了容器里的内容(经常<br>是安装新文件，新文件系统)，下一个命令修改了更多的内容等等。由于每一个命令都是基于上一个命令的结果，命令<br>执行的顺序标识依赖项。下面的是一个典型的Docker构造过程：</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:12.04</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y python python-pip curl</span><br><span class="line">RUN curl -sSL https://github.com/shykes/helloflask/archive/master.tar.gz | tar -xzv</span><br><span class="line">RUN cd helloflask-master &amp;&amp; pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Docker不关心依赖的构建关系，只要他们可以在容器中可以通过Unix命令构建。</p>
</blockquote>
<h3 id="ToDo（入门）"><a href="#ToDo（入门）" class="headerlink" title="ToDo（入门）"></a>ToDo（入门）</h3>
      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/24/phabricator/what_is_docker/" data-id="ciw3pesh2002opco0bunktnfi" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-phabricator/eslint" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/21/phabricator/eslint/" class="article-date">
  <time datetime="2016-11-21T15:42:13.212Z" itemprop="datePublished">2016-11-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/development-tools/">development tools</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/21/phabricator/eslint/">eslint</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Why-We-Need-Eslint"><a href="#Why-We-Need-Eslint" class="headerlink" title="Why We Need Eslint?"></a>Why We Need Eslint?</h3><blockquote>
<p>在团队配合中，有的人是Mac开发，有的人是Windows来发，使用Eslint来强制开发人员统一代码<br>格式，比如常见的<code>tab</code>以及空格,以及windows和Mac的回车标识，也可强制开发人员删除无用的<br>垃圾代码，比如<code>alert(1212), console.log(111)</code>等等，或者条件语句中使用<code>if(true){}</code>,<br>总之它就是用来检测开发人员代码书写规范的一个集成工具。so beautiful!</p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/21/phabricator/eslint/" data-id="ciw3pesg1002ipco0t4b1z791" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
    <article id="post-vue/movitation_design" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/17/vue/movitation_design/" class="article-date">
  <time datetime="2016-11-17T11:43:37.495Z" itemprop="datePublished">2016-11-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/17/vue/movitation_design/">了解Vue</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>vue是一个用来构建交互式web界面的库。它的核心集中于视图层，它很容易与其他库或现有的项目集成。<br>另一方面，Vue完全有能力服务员复杂的单页面应用。但是Vue和其它的框架有什么不同呢？</p>
</blockquote>
<h3 id="和React的比较"><a href="#和React的比较" class="headerlink" title="和React的比较"></a>和React的比较</h3><blockquote>
<p>React和Vue有很多相似之处:</p>
<ul>
<li>利用虚拟DOM</li>
<li>提供了reactive(反应性)和可组合的视图组件<br>在代码核心库中，保持对相关库管理的routing，全局state的关注。作用域也很相似。我们想保证的不仅<br>有技术上的准确也要确保技术的平衡，我们找出React哪里优于Vue，比如，React庞大的生态圈以及<br>自定义渲染器的丰富性。</li>
</ul>
</blockquote>
<h5 id="性能（渲染性能）"><a href="#性能（渲染性能）" class="headerlink" title="性能（渲染性能）"></a>性能（渲染性能）</h5><blockquote>
<p>Vue胜过React，当渲染UI时，DOM的操作通常是非常昂贵的，没有库可以使那些原生的操作更快，我们能做的<br>最好的就是:</p>
<ol>
<li>尽量减少必要的DOM变化的数量，React和Vue都使用了虚拟DOM来解决这个问题。</li>
<li>尽可能在顶层的DOM操作上添加较小的开销(纯js计算)，这里是React和Vue的区别。<br>javascript开销和计算必要的DOM操作机制有直接关系，Vue和React都利用虚拟DOM来达到它，但是Vue的实现更<br>轻量级，因此比React的开销更少。<br>React和Vue都提供了功能组件，他们是stateless，instanceless的因此需要的开销很少。当它们用于性能关键<br>的场景中，Vue更快，为了证明这个，我们渲染1万个item100次，强烈建议自己实践，因为它和软件、浏览器相关。<br>相关比较如下:</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                  Vue       React</span><br><span class="line">Fatest            23ms      63ms</span><br><span class="line">Mediam            42ms      81ms</span><br><span class="line">Average           51ms      94ms</span><br><span class="line">95thPerc.         73ms      164ms</span><br><span class="line">Slowest           343ms     453ms</span><br></pre></td></tr></table></figure>
<h5 id="更新性能"><a href="#更新性能" class="headerlink" title="更新性能"></a>更新性能</h5><blockquote>
<p>在React中，当一个组件的state改变了，它会触发整个组件的sub-tree的重新渲染，为了避免child组件不必要<br>的渲染，你需要在该组件中使用<code>shouldComponentUpdate</code>并定义不变的结构，而在Vue中，在渲染过程中，会自<br>动的追踪组件的依赖项，所以系统会精确的知道哪个组件需要正真的重新渲染。这就意味着未优化的Vue比未优化的<br>React要快。由于Vue的加强了渲染性能，即使React进行了全部的优化操作，通常也比Vue慢。</p>
</blockquote>
<h5 id="在开发过程中"><a href="#在开发过程中" class="headerlink" title="在开发过程中"></a>在开发过程中</h5><blockquote>
<p>虽然在生产环境中的性能指标是非常重要的，因为这和用户体验相关联。但是在开发时的性能仍然重要，因为这与<br>我们开发者相关联.<br>Vue和React在大多数程序中开发可以保持足够快速。但是，在高帧速率的可视化或动画时，Vue每秒处理10帧，而<br>React每秒只有1帧。这是因为在开发环境中React需要检查大量的不变量，这是用来提示一些重要的错误或警告用的。<br>当然在Vue中也是同意这是很重要的，但是当执行这些检查时，我们对性能保持密切关注。</p>
</blockquote>
<h5 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML &amp; CSS"></a>HTML &amp; CSS</h5><blockquote>
<p>在React中，所有的东西是javascript，虽然听起来很简单且高雅但是当你向下挖掘时，在javascript中写HTML和CSS，<br>当解决问题时，会很痛苦。而在Vue中，我们信奉web的技术并将它们，将css写在html顶部。</p>
<p>####### JSX vs Templates<br>在React中，所有的组件在JSX中来表示他们的UI，下面是个例子:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  let &#123; items &#125; = this.props</span><br><span class="line">  let children</span><br><span class="line">  if (items.length &gt; 0) &#123;</span><br><span class="line">    children = (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;items.map(item =&gt;</span><br><span class="line">          &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    children = &lt;p&gt;No items found.&lt;/p&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&apos;list-container&apos;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JSX有以下优点：</p>
<ul>
<li>使用编程语言（js）构建你的视图。</li>
<li>在某些方式下，对JSX的工具支持比vue的模板更先进。<br>在Vue中，我们有<code>render functions</code>甚至还有支持<code>jsx</code>。</li>
</ul>
</blockquote>
<h3 id="HTML-amp-CSS-1"><a href="#HTML-amp-CSS-1" class="headerlink" title="HTML &amp; CSS"></a>HTML &amp; CSS</h3><blockquote>
<p>在Vue中，有渲染器函数并且支持<code>jsx</code>,默认情况下，我们提供模板作为选择方案:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;list-container&quot;&gt;</span><br><span class="line">    &lt;ul v-if=&quot;items.length&quot;&gt;</span><br><span class="line">      &lt;li v-for=&quot;item in items&quot;&gt;</span><br><span class="line">        &#123;&#123; item.name &#125;&#125;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;p v-else&gt;No items found.&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它的优势：</p>
<ul>
<li>模板中有少量的实现并且代码风格优雅</li>
<li>模板一直是称述性质的</li>
<li>任何有效的HTML在模板中也是有效的</li>
<li>读起来很像英语</li>
<li>不需要再高版本的javascript中增加可读性。<br>另外一个好处就是你可以使用预处理器处理<code>HTML-compliant</code>模板，比如Pug书写你的Vue模板:</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.list-container</span><br><span class="line">  ul(v-if=&quot;items.length&quot;)</span><br><span class="line">    li(v-for=&quot;item in items&quot;) &#123;&#123; item.name &#125;&#125;</span><br><span class="line">  p(v-else) No items found.</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Component-Scoped CSS（组件范围的CSS）</strong><br>除非你的组件分布在多个文件中（比如CSS Modules），范围性的CSS在React中通常是在js中。而在<br>Vue中，你完全可以在单个文件中访问到CSS：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">  @media (min-width: 250px) &#123;</span><br><span class="line">    .list-container:hover &#123;</span><br><span class="line">      background: orange;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>scoped</code>属性自动的对组件范围内的元素通过添加一个唯一的属性来编译。</p>
</blockquote>
<h3 id="规模"><a href="#规模" class="headerlink" title="规模"></a>规模</h3><blockquote>
<p>React社区在状态管理上引入了<code>flux/redux</code>,状态管理方式可以在Vue很容易的集成进来。但是尽管<br>如此，React的生态圈还是要比Vue丰富。Vue提供了一个十分简单生成Vue项目的<a href="https://github.com/vuejs/vue-cli" target="_blank" rel="external">命令行工具</a>。</p>
</blockquote>
<h3 id="Scaling-Down"><a href="#Scaling-Down" class="headerlink" title="Scaling Down"></a>Scaling Down</h3><blockquote>
<p>React的学习曲线比较陡峭，在你学习之前你需要了解JSX以及ES2015.Vue中可以简单的通过在html引入vue库<br>来使用vue，React也行啊！！！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Native-Rendering"><a href="#Native-Rendering" class="headerlink" title="Native Rendering"></a>Native Rendering</h3><blockquote>
<p>React Native可以已React组件的形式写原生的IOS、Android程序，在这方面，Vue已经与<a href="https://alibaba.github.io/weex/" target="_blank" rel="external">Weex</a>合作了。<br>Weex是由阿里巴巴开发的一个跨平台UI框架，这意味着使用Weex，你可以以Vue的组件语法规则开发出的程序可以在浏览器，IOS，Android运行。<br>额，这点我承认确实比react-native强悍啊。。。。，当然Weex正在活跃的开发，和react-native一样不成熟。但是Vue和Weex合作开发啊，选择<br>React社区还是选择Vue社区呢？如果Weex和Vue成熟稳定的话选择Vue生态圈我觉得还是不错的。</p>
</blockquote>

      
    </div>
   <!-- <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/17/vue/movitation_design/" data-id="ciw3pesk8003kpco0vbn0t9cl" class="article-share-link">Share</a>
      
      
    </footer>-->
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          
            <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Canvas/">Canvas</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Electron/">Electron</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Http/">Http</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Redux/">React Redux</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Webpack/">Webpack</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/development-tools/">development tools</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget recents">
      <ul>
        
          <li>
            <a href="/2016/11/29/vue/event_handle/">事件处理</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/list_render/">Vue的列表渲染</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/conditional_render/">条件渲染</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/style_class_binding/">样式绑定</a>
          </li>
        
          <li>
            <a href="/2016/11/29/vue/computed_properties/">Vue属性的计算及监听器</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">我的文章</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
</aside>
          
        
      </div>
      <!--<div id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a></br>
      &copy; 2016 zhuxin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</div>-->
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">我的文章</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>